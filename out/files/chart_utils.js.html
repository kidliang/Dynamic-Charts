<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>chart_utils.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Array.html">Array</a></li>
            
                <li><a href="..&#x2F;classes/BasicBarChart.html">BasicBarChart</a></li>
            
                <li><a href="..&#x2F;classes/ChartUtils.html">ChartUtils</a></li>
            
                <li><a href="..&#x2F;classes/DynamicChart.html">DynamicChart</a></li>
            
                <li><a href="..&#x2F;classes/FixedWidthBarChart.html">FixedWidthBarChart</a></li>
            
                <li><a href="..&#x2F;classes/Legend.html">Legend</a></li>
            
                <li><a href="..&#x2F;classes/Object.html">Object</a></li>
            
                <li><a href="..&#x2F;classes/SlidingBarChart.html">SlidingBarChart</a></li>
            
                <li><a href="..&#x2F;classes/TimeWheelChart.html">TimeWheelChart</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/ChartUtils.html">ChartUtils</a></li>
            
                <li><a href="..&#x2F;modules/DynamicChart.html">DynamicChart</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: chart_utils.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
if (!window.ChartUtils){
	&#x2F;**
		Module ChartUtils
        
Extends Object class with several useful methods to allow better encapsulation mechanisms.&lt;br&gt;
Exposes a few utility functions
        
        @module ChartUtils       
        
	*&#x2F;
	var ChartUtils = (function(){
		&quot;use strict&quot;;

		&#x2F;&#x2F;Add a init method to Object
		if (!Object.hasOwnProperty(&quot;init&quot;)) {
        
                          &#x2F;** 
                                Creates an object inheriting from a given prototype and then, if required, 
                                inits it with a list of properties tha can be passed as its second argument.
                                
                                @method init
                                @for Object
                                @param {Object} proto  The protetype to inherit from;
                                @param {Object} [properties] A dictionary of key-value properties to be used for the new object&#x27;s initialization;
                                @return {Object} The newly created object.
                                @throws Error, if the wrong number of arguments is passed.
                            *&#x2F;
			Object.init = function (proto, properties){
				if (arguments.length !== 2){
					throw new Error(&#x27;Object.init implementation only accepts 2 parameters.&#x27;);
				}
				var key, new_obj = Object.create(proto);
				
				if (properties){
					for (key in properties){
						if (properties.hasHownProperty(key)){
							Object.defineProperty(new_obj, key, {
									value: properties[key],
									writable: true,
									enumerable: true,
									configurable: false
								}
							);
						}
					}
				}
				return new_obj;
			};
		}
		
		if (Object.prototype.clear){
                                        &#x2F;**
                                            Deletes every property from an object
                                            
                                            @method clear
                                            @for Object
                                            @chainable
                                            @return {Object} The same object on whom this method is called.
                                          *&#x2F;
			Object.prototype.clear = 	function(){
											for (var prop in this){
												if (this.hasOwnProperty(prop)){
													delete this[prop]; 
												}
											}
											return this;
										};
		
		}

        
        &#x2F;** addPublicMethod(methodName, method)
            
            Shortcut for defyning a method which will be considered
            public by createSafeProxy;&lt;br&gt;
            Usage: obj.addPublicMethod(&quot;name&quot;, method)&lt;br&gt;
            to add function method to obj as property obj[&quot;name&quot;].
            
            @method addPublicMethod
            @for Object
            @chainable
            @param  {String} methodName    The name of the new property to be added to this object&lt;br&gt;
                                          &lt;b&gt;WARNING&lt;&#x2F;b&gt;: if Object[methodName] exists, then it will
                                                          be overwritten.
            @param method {Function}       The method body.
            @return {Object} This object, to enable method chaining
            @throws   
                    &lt;ul&gt;
                        &lt;li&gt;    Wrong number of arguments Exception, if either is missing or null;&lt;&#x2F;li&gt;
                        &lt;li&gt;    Illegal Argument Exception, if methodName is not a String;&lt;&#x2F;li&gt;
                        &lt;li&gt;    Illegal Argument Exception, if method is not a Function.&lt;&#x2F;li&gt;
                    &lt;&#x2F;ul&gt;     
          *&#x2F;
        function addPublicMethod(methodName, method){
            
            if (!methodName || !method){
                throw &quot;Wrong number of arguments Exception&quot;;
            }
            if (!Object.isString(methodName)){
                throw &quot;Illegal Argument Exception: methodName must be a string&quot;;
            }                                                            
            if (!Object.isFunction(method)){
                throw &quot;Illegal Argument Exception: method must be a function&quot;;
            }
            Object.defineProperty(this, methodName, {
                value: method,
                writable: false,
                enumerable: true,
                configurable:false
            });
            return this;    &#x2F;&#x2F;Chainable
        }   
        
        if (!Object.prototype.addPublicMethod){
            Object.defineProperty(Object.prototype, &quot;addPublicMethod&quot;, {
                                    value: addPublicMethod,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
        }
        
	
        &#x2F;** addProtectedMethod(methodName, method)
            
            Shortcut for defyning a method which will be considered
            protected by createSafeProxy;&lt;br&gt;
            Usage: obj.addProtectedMethod(&quot;name&quot;, method)&lt;br&gt;
            to add function method to obj as property obj[&quot;name&quot;].
            
            @method addProtectedMethod
            @for Object
            @chainable
            @param  {String} methodName    The name of the new property to be added to this object&lt;br&gt;
                                          &lt;b&gt;WARNING&lt;&#x2F;b&gt;: if Object[methodName] exists, then it will
                                                          be overwritten.
            @param method {Function}       The method body.
            @return {Object} This object, to enable method chaining
            @throws   
                    &lt;ul&gt;
                        &lt;li&gt;    Wrong number of arguments Exception, if either is missing or null;&lt;&#x2F;li&gt;
                        &lt;li&gt;    Illegal Argument Exception, if methodName is not a String;&lt;&#x2F;li&gt;
                        &lt;li&gt;    Illegal Argument Exception, if method is not a Function.&lt;&#x2F;li&gt;
                    &lt;&#x2F;ul&gt;     
          *&#x2F;
        function addProtectedMethod(methodName, method){
            
            if (!methodName || !method){
                throw &quot;Wrong number of arguments Exception&quot;;
            }
            if (!Object.isString(methodName)){
                throw &quot;Illegal Argument Exception: methodName must be a string&quot;;
            }                                                            
            if (!Object.isFunction(method)){
                throw &quot;Illegal Argument Exception: method must be a function&quot;;
            }
            Object.defineProperty(this, methodName, {
                value: method,
                writable: false,
                enumerable: false,
                configurable:false
            });
        }    
        
        if (!Object.prototype.addProtectedMethod){
            Object.defineProperty(Object.prototype, &quot;addProtectedMethod&quot;, {
                                    value: addProtectedMethod,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
        }        
                    
        if (!Object.prototype.createSafeProxy){
                                                &#x2F;** createSafeProxy()
                                                
                                                    Creates and returns a safe proxy for the object passed, 
                                                    that will wrap around it and expose only those methods
                                                    marked as public (i.e. those that are declared as enumerable).
                                                    
                                                    @method createSafeProxy
                                                    @for Object
                                                    @chainable
                                                    @param {Boolean} [canDestroy=false] States if the proxy consumer has the authority 
                                                                     to call destroy on the original object;&lt;br&gt;
                                                                     We assume the convention that object&#x27;s uses destroy method
                                                                     as their destructor.
                                                    @return {Object} A proxy wrapping this object.
                                                    @throws  Any exception the original object pseudo-constructor might throw.
                                                  *&#x2F;
            Object.prototype.createSafeProxy = function(canDestroy){
                var property;
                var proxy = Object.create(null);
                var obj = this; &#x2F;&#x2F;We must retain the &quot;this&quot; pointer to the current object to use it inside different contexts
                
                for (property in obj){
                    &#x2F;&#x2F;DO NOT check hasOwnProperty: the proxy must work for obj&#x27;s prototype methods as well
                    &#x2F;&#x2F;ONLY enumerable methods will be added to proxy&#x27;s interface
                    if (Object.isFunction(obj[property])){
                        
                        &#x2F;&#x2F;If it&#x27;s a method not marked as protected, it is added to the proxy interface;
                        proxy[property] = ( function(p){
                                                return  function(){
                                                            var result;
                                                            if (obj){
                                                                result = obj[p].apply(obj, Array.prototype.slice.apply(arguments, [0]));
                                                                &#x2F;&#x2F;Special care is needed to support method chaining
                                                                if (result === obj){
                                                                    &#x2F;&#x2F;obj.property returns obj itself, but we must return this proxy instead;
                                                                    return proxy;
                                                                }else{
                                                                    return result;
                                                                }
                                                            }else{
                                                                throw &quot;Null reference: the object has been already destroyed&quot;;
                                                            }
                                                        };
                                            })(property);
                    }
                }
                
                &#x2F;&#x2F;Adds a wrapping destroy method to allow withdrawal of the privileges given up introducing 
                &#x2F;&#x2F;the consumer to obj;
                proxy.destroy = function(){
                                    try{
                                        if (canDestroy){
                                            obj.destroy();  &#x2F;&#x2F;Destroys the original object only if authorized to
                                        }
                                    }finally{
                                        obj = null;
                                    }
                                };
                                    
                return proxy;
            };
        }        
      
        &#x2F;** superMethod(methodName)
           
           Checks if the super object of this object has a method (i.e. a property which is a function) whose name is methodName, 
           and then calls it. Otherwise checks recursively its super object, i.e. its prototype.
           
           @method superMethod
           @for Object
           @param {String} methodName The name of the method to look up for in this object&#x27;s super objects.
           @param [args]* The arguments to be passed to the super method, if any is needed;
           @return The result of the call to the method named methodName of this object&#x27;s super object.
           @throws
                    &lt;ul&gt;
                        &lt;li&gt;Wrong number of arguments Exception, if methodName is missing or null;&lt;&#x2F;li&gt;
                        &lt;li&gt;Illegal Argument Exception, if methodName is not a String;&lt;&#x2F;li&gt;                                                                    
                        &lt;li&gt;Method not found Exception, if there isn&#x27;t such a method in the whole inheritance chain.&lt;&#x2F;li&gt;
                    &lt;&#x2F;ul&gt;
         *&#x2F;
        function superMethod(methodName &#x2F;*, args*&#x2F;){
            if (!methodName){
                throw &quot;Wrong number of arguments Exception&quot;;
            }
            if (!Object.isString(methodName)){
                throw &quot;Illegal Argument Exception: methodName must be a string&quot;;
            }    
            
            &#x2F;&#x2F;Looks up for this object&#x27;s prototype
            var proto = this.prototype &amp;&amp; this.prototype[methodName] ? this.prototype : this.__proto__;
            if (proto &amp;&amp; proto[methodName] &amp;&amp; Object.isFunction(proto[methodName])){
                return proto[methodName].apply(proto, Array.prototype.slice.apply(arguments, [1]));
            }else{
                throw &quot;Super object has no method &quot; + methodName;
            }
        }
        
        if (!Object.prototype.superMethod){
            Object.defineProperty(Object.prototype, &quot;superMethod&quot;, {
                                    value: superMethod,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
        }                    
      
      
        &#x2F;** setProperty(property, value)
           
           Assign the value &quot;value&quot; to the property &quot;property&quot; of the current object.&lt;br&gt;
           &quot;property&quot; MUST be an existing property of current object or of its ancestors:
           if this[property] is undefined, it recursively checks along its inheritance chain. 
           
           @method setProperty
           @for Object
           @chainable
           @param {String} property The name of the property to look up for in this object and its super object.
           @param value The value to be assigned to the property.
           @return This object, to allow for method chaining
           @throws
                    &lt;ul&gt;
                        &lt;li&gt;Wrong number of arguments Exception, if property is missing or null; (undefined is accepted for value)&lt;&#x2F;li&gt;
                        &lt;li&gt;Illegal Argument Exception, if property is not a String;&lt;&#x2F;li&gt;                                                                    
                        &lt;li&gt;Method not found Exception, if neither this object or its super object has such a property.&lt;&#x2F;li&gt;
                        &lt;li&gt;TypeError, if property exists but it isn&#x27;t writable.&lt;&#x2F;li&gt;
                    &lt;&#x2F;ul&gt;
         *&#x2F;
        function setProperty(property, value){
            if (!property){
                throw &quot;Wrong number of arguments Exception&quot;;
            }
            if (!Object.isString(property)){
                throw &quot;Illegal Argument Exception: property must be a string&quot;;
            }    
            
            if (this.hasOwnProperty(property)){
                this[property] = value;
                return this;
            }
            
            &#x2F;&#x2F;Looks up for this object&#x27;s prototype
            var proto = this.prototype &amp;&amp; this.prototype[property] ? this.prototype : this.__proto__;
            if (proto &amp;&amp; !Object.isUndefined(proto[property])){
                proto.setProperty(property, value);
                return this;
            }else{
                throw &quot;Super object has no property &quot; + property;
            }
            
        }
        
        if (!Object.prototype.setProperty){
            Object.defineProperty(Object.prototype, &quot;setProperty&quot;, {
                                    value: setProperty,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
        }
        
		if (Array.prototype.clear){
                &#x2F;** 
                    Clears an Array, removing all its elements;
                    @method clear
                    @for Array
                    @param {Boolean} [deepClear=false] If it is required for all the array elements to be cleared,
                                                       this paramenter should be true; can  be omitted otherwise; &lt;br&gt;
                                                       If deep clearance is required, thie method will try to 
                                                       call the clear method for each and every element of this array
                                                       (Object class has already been extended with a clear method).
                    @return {Array} This array.
                  *&#x2F;
			Array.prototype.clear = function(deepClear){
                                        if (deepClear){
                                            &#x2F;&#x2F;If a deep clear is required, try to execute clear method of every element
                                            for (var i=0; i&lt;this.length; i++){
                                                if (Object.isFunction(this[i].clear)){
                                                    this[i].clear();
                                                }
                                            }
                                        }
                                        &#x2F;&#x2F;Clear this array (the efficient way)
										this.length = 0;
										return this;
									};	
		}	
		
		if (!Array.prototype.map){
                                &#x2F;**
                                    Maps a function on every element of the array, creting a new array populated
                                    with the results of these calls.
                                    
                                    @method map
                                    @for Array
                                    @param {Function} f The function to map on the array;
                                    @param {Object} [contest=window] The new this pointer for the function to map, if needed;
                                    @return {Array} The array of the results of mapping f over the elements this array.
                                    @throws TypeError if f isn&#x27;t a function.
                                  *&#x2F;
			Array.prototype.map = function(f &#x2F;*,contest*&#x2F;){
				if (!Function.isFunction(f)){
					throw new TypeError();
				}else{
					var len = this.length;
					var res = new Array(len);
					var contest = arguments[1];
					for (var i = 0; i &lt; len; i++){
						if (i in this){
							res[i] = f.call(contest, this[i], i, this);
						}
					}

					return res;
				}
			};	
		}

		if (!Array.prototype.sum){
                                &#x2F;**
                                    Sums the elements of an array.

                                    @method sum
                                    @for Array
                                    @return {Number|String} The sum of the elements in the array;&lt;br&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;: 
                                        &lt;ul&gt;
                                            &lt;li&gt;If all the elements in the array are numbers, then returs their arithmetic sum&lt;&#x2F;li&gt;
                                            &lt;li&gt;If any element of the array isn&#x27;t a number, returns a string obtained by concatenating
                                                the partial arithmetic sum until that element, and the concatenation
                                                of the string conversion of every other element in the array.&lt;&#x2F;li&gt;
                                        &lt;&#x2F;ul&gt;                                    
                                  *&#x2F;        
			Array.prototype.sum = function(){
                var len = this.length;
                var res = 0;
                for (var i = 0; i &lt; len; i++){
                    res += this[i];
                }

                return res;
				
			};	
		}       

        
		if (!Array.prototype.shallowCopy){
                                        &#x2F;** Array.shallowCopy([n])
                                            Creates a new array (shallow) copying the elements of the current one
                                            
                                            @method shallowCopy
                                            @for Array
                                            @param [n] If defined, the max number of elements to copy from the current array
                                            @return {Array} A new array, with a shallow copy of all the elements in the original one.
                                        *&#x2F;
			Array.prototype.shallowCopy =  function(n){
                                                var len = this.length;
                                                if (Object.isUndefined(n)){
                                                    n = len;
                                                }else{
                                                    n = parseInt(n, 10);
                                                    if (isNaN(n) || n &lt;= 0){
                                                        throw &quot;Invalid argument: n&quot;;
                                                    }else{
                                                        n = Math.min(n, len);
                                                    }
                                                }
                                                
                                                var res = new Array(n);
                                                for (var i = 0; i &lt; n; i++){
                                                    res[i] = this[i];
                                                }

                                                return res;
                                            };	
		}	        
		
		if (!Array.prototype.max){
                                    &#x2F;** 
                                        Return the maximum element of an array.
                                        
                                        @method max
                                        @for Array
                                        @param [extract_element_key] A function that, given any element of the array, will produce
                                                                     a numeric value used for ranking the element itself (its sorting key)
                                        @return {Number|NaN} The maximum value in the array, if all elements (or their keys)
                                                             are Number;&lt;br&gt;
                                                             NaN otherwise
                                    *&#x2F;
			Array.prototype.max = function(extract_element_key){
										if (Function.isFunction(extract_element_key)){
											return Math.max.apply(Math, this.map(extract_element_key));
										}else{
											return Math.max.apply(Math, this);
										}
									};	
		}	
		
		if (!Array.prototype.min){
                                    &#x2F;** 
                                        Return the minimum element of an array.
                                        
                                        @method min
                                        @for Array
                                        @param [extract_element_key]  A function that, given any element of the array, will produce
                                                                      a numeric value used for ranking the element itself (its sorting key)
                                        @return {Number|NaN} The minimum value in the array, if all elements (or their keys)
                                                             are Number;&lt;br&gt;
                                                             NaN otherwise
                                    *&#x2F;        
			Array.prototype.min = function(extract_element_key){
										if (Function.isFunction(extract_element_key)){
											return Math.min.apply(Math, this.map(extract_element_key));
										}else{
											return Math.min.apply(Math, this);
										}
									};	
		}	

        if (!Object.prototype.isArray){
            &#x2F;** 
                Checks if its argument is an array.
                
                @method isArray
                @for Object
                @param {Object} obj The argument to be checked.
                @return {Boolean} true &lt;=&gt; the object is an Array.
            *&#x2F;         
        	Object.prototype.isArray = function(obj) {
				return obj &amp;&amp; (obj.constructor === Array);
			};
        }
        
        if (!Object.prototype.isString){
            &#x2F;** 
                Checks if its argument is a string.
                
                @method isString
                @for Object
                @param {Object} obj The argument to be checked.
                @return {Boolean} true &lt;=&gt; the object is a String.
            *&#x2F;          
        	Object.prototype.isString = function(arg) {
				return typeof(arg)===&#x27;string&#x27;;
			};
        }    
        
        if (!Object.prototype.isFunction){
            &#x2F;** 
                Checks if its argument is a Function.
                
                @method isFunction
                @for Object
                @param {Object} arg The argument to be checked.
                @return {Boolean} true &lt;=&gt; the object is a Function.
            *&#x2F;              
        	Object.prototype.isFunction = function(arg){
				return typeof(arg) === &#x27;function&#x27;;
			};
        }        
		
        if (!Object.prototype.isNumber){
            &#x2F;** 
                Checks if its argument is a Number.
                
                @method isNumber
                @for Object
                @param {Object} obj The argument to be checked.
                @return {Boolean} true &lt;=&gt; the object is a Number.
            *&#x2F;              
            Object.prototype.isNumber = function(n){
              return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
            };
        } 

        if (!Object.prototype.isUndefined){
            &#x2F;** 
                Checks if its argument is undefined.
                
                @method isUndefined
                @for Object
                @param {Object} arg The argument to be checked.
                @return {Boolean} true &lt;=&gt; the argument is undefined.
            *&#x2F;              
        	Object.prototype.isUndefined = function(arg){
				return typeof(arg) === &quot;undefined&quot;;
			};
        }         
           
		if (!Object.prototype.shallowCopy){
                                        &#x2F;** Array.shallowCopy()
                                            Creates a new object (shallow)copying the elements of the current one.
                                            
                                            @method shallowCopy
                                            @for Object
                                            @return {Object} A new object, with a shallow copy of all the properties in the original one.
                                        *&#x2F;
			Object.prototype.shallowCopy =  function(){
                                                var res = {};
                                                for (var key in this){
                                                    if (this.hasOwnProperty(key)){
                                                        res[key] = this[key];
                                                    }
                                                }

                                                return res;
                                            };	
		}           
		
        var TIME_REGEXP = &#x2F;^\d\d?:\d\d?$&#x2F;;
            
            
            &#x2F;** formatTimeString(HH, MM)
                Format a hours, minutes couple into a proper time string&lt;br&gt;
                &lt;br&gt;
                &lt;b&gt;INVARIANT&lt;&#x2F;b&gt;: HH and MM must be valid, positive integers 
                                  (since it&#x27;s a private method, defensive programming is avoided&lt;br&gt;
                           If the overcome their range, proper formatting is enforced:
                           F.i. HH=23, MM=60 -&gt; &quot;00:00&quot;
                @method formatTimeString
                @for ChartUtils
                @private
                @param {Number} HH An int value (between 0 and 23), representing the hours
                @param {Number} MM An int value (between 0 and 59), representing the minutes
                            
                @return {String} The properly formatted time string.
              *&#x2F;                        
            function formatTimeString(HH, MM){ 
                HH = (HH + Math.floor(MM&#x2F;60)) % 24;
                MM = MM % 60;
                return (HH &lt; 10 ? &quot;0&quot; + HH : HH) + &quot;:&quot; + (MM &lt; 10 ? &quot;0&quot; + MM : MM);
            } 

        &#x2F;** 
            Abbreviations suffixes for large numbers;
            @property SUFFIXES
            @for ChartUtils
            @type {Array}
            @final
            @private     
          *&#x2F;    
        var SUFFIXES = [&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;G&quot;, &quot;T&quot;, &quot;P&quot;, &quot;E&quot;];              
                              
		var utils = {

                                &#x2F;** abbreviateNumber(val)
                                    Takes a value and returns it&#x27;s abbreviated text representation.&lt;br&gt;
                                    &lt;ul&gt;
                                        &lt;li&gt;If abs(val) &gt; 1, the following standard abbreviations will be used:
                                            &lt;ul&gt;
                                                &lt;li&gt;&lt;b&gt;K&lt;&#x2F;b&gt; thousands&lt;&#x2F;li&gt;
                                                &lt;li&gt;&lt;b&gt;M&lt;&#x2F;b&gt; million&lt;&#x2F;li&gt;
                                                &lt;li&gt;&lt;b&gt;G&lt;&#x2F;b&gt; billion&lt;&#x2F;li&gt;
                                                &lt;li&gt;&lt;b&gt;T&lt;&#x2F;b&gt; trillion&lt;&#x2F;li&gt;
                                                &lt;li&gt;&lt;b&gt;P&lt;&#x2F;b&gt; quadrillion&lt;&#x2F;li&gt;
                                                &lt;li&gt;&lt;b&gt;E&lt;&#x2F;b&gt; quintillion&lt;&#x2F;li&gt;
                                            &lt;&#x2F;ul&gt;
                                            One decimal place is always kept.&lt;br&gt;
                                            F.i.:
                                            &lt;ul&gt;
                                                &lt;li&gt;123 -&gt; &quot;123&quot;&lt;&#x2F;li&gt;
                                                &lt;li&gt;1234 -&gt; &quot;1.2K&quot;&lt;&#x2F;li&gt;
                                                &lt;li&gt;12345 -&gt; &quot;12.3K&quot;&lt;&#x2F;li&gt;
                                                &lt;li&gt;123456789 -&gt; &quot;123.4M&quot;&lt;&#x2F;li&gt;
                                            &lt;&#x2F;ul&gt;                                            
                                        &lt;&#x2F;li&gt;
                                        &lt;li&gt; If abs(val)
                                        &lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:   since shallow copy is used, only works for
                                                      primitive (immutable) values                            
                                    @method abbreviateNumber
                                    @for ChartUtils
                                    @param {String|Number} value The value to assign to each element of the newly created array.
                                                                 If value is a function, it is called  n times, with no parameters
                                    @param {Number} n The size of the final array;&lt;br&gt;
                                                      Must be a positive integer.
                                    @return {Array} The newly created array.
                                    @throws {Invalid Argument Exception} if n isn&#x27;t passed, it&#x27;s not a number, or it&#x27;s not positive.

                                *&#x2F;
            abbreviateNumber:   function (val){
                                    var index;
                                    if (val === 0){
                                        return &quot;0&quot;;
                                    }
                                    if (Math.abs(val) &lt; 1){
                                        &#x2F;&#x2F;Very small number
                                        index = 0;  &#x2F;&#x2F;WARNING: Reusing the variable index as the exponent of scientific notation
                                        while (Math.abs(val) &lt; 1){
                                            index += 1;
                                            val *= 10;
                                        }                                              
                                        return (Math.round(val * 100) &#x2F; 100.0) + &quot;e-&quot; + index;
                                    } else{
                                        index = 0;  &#x2F;&#x2F;WARNING: Reusing the variable index as the index of the suffixes array
                                        while (index &lt; SUFFIXES.length - 1){
                                            if (Math.abs(val) &lt; 1000){
                                                if (index === 0){
                                                    val = Math.round(val * 100.0) &#x2F; 100.0;   &#x2F;&#x2F;Keeps only two decimal digits for numbers smaller than 100
                                                }                                            
                                                return val + SUFFIXES[index];
                                            }else{
                                                index += 1;
                                                val = Math.round(val &#x2F; 100.0) &#x2F; 10.0;   &#x2F;&#x2F;Keep one decimal digits when dividing by 1K
                                            }
                                        }
                                        &#x2F;&#x2F;Here, index == SUFFIXES.length - 1
                                        if (Math.abs(val) &lt; 1000){
                                            return val + SUFFIXES[index];
                                        }else{
                                            &#x2F;&#x2F;If it reaches here, the number is too long for the suffixes list: we abbreviate as much as we can anyway
                                            return val + SUFFIXES[SUFFIXES.length - 1];
                                        }                
                                    }
                                },        
                        &#x2F;** fillArray(value, n)
                            Takes a value and a positive integer n and returns an Array of n copies of that value.&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:   since shallow copy is used, only works for
                                              primitive (immutable) values                            
                            @method fillArray
                            @for ChartUtils
                            @param {String|Number} value The value to assign to each element of the newly created array.
                                                         If value is a function, it is called  n times, with no parameters
                            @param {Number} n The size of the final array;&lt;br&gt;
                                              Must be a positive integer.
                            @return {Array} The newly created array.
                            @throws {Invalid Argument Exception} if n isn&#x27;t passed, it&#x27;s not a number, or it&#x27;s not positive.

                        *&#x2F;
			fillArray:  function(value, n){
                            n = parseInt(n, 10);
                            if (isNaN(n) || n &lt;= 0){
                                throw &quot;Invalid Argument: n&quot;;
                            }

                            var i, res = new Array(n);
                            if (Function.isFunction(value)){
                                for (i = 0; i &lt; n; i++){
                                    res[i] = value();
                                }                            
                            }else{
                                for (i = 0; i &lt; n; i++){
                                    res[i] = value;
                                }
                            }

                            return res;
                        },
            &#x2F;** validateTimeString(timeString)
            
                Takes a string as input and checks if it is a valid
                time representation, according to the format HH:MM
                
                @method validateTimeString
                @for ChartUtils
                @param {String} timeString The string to be evaluated
                @return {Array|null} &lt;ul&gt;
                                        &lt;li&gt;An array with two integers, the values for hours and minutes
                                            &lt;=&gt; The input string validates successfully&lt;&#x2F;li&gt;
                                        &lt;li&gt;null &lt;-&gt; Otherwise&lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;
              *&#x2F;                        
            validateTimeString:     function(timeString){
                                        if (!TIME_REGEXP.test(timeString)){
                                            return null;
                                        }&#x2F;&#x2F;else, the formatting is fine, but we MUST check the values (i.e.: HH &lt; 24, MM &lt; 60
                                        var v = timeString.split(&quot;:&quot;).map(function(s){return parseInt(s, 10);});
                                        if (v[0] &gt;= 24 || v[1] &gt;= 60){
                                            return null;
                                        }else{
                                            return  v;
                                        }
                                    },
                        
            &#x2F;** addTimeStrings(timeString_1, timeString_2)
                Takes two strings as input and checks if they are valid
                time representations, according to the format HH:MM&lt;br&gt;
                If it is so, sums them and returns a new string representing
                the resulting time;
                
                @method addTimeStrings
                @for ChartUtils
                @param {String} timeString_1 The first time string to be added
                @param {String} timeString_2 The second time string to be added                                                    
                @return {String} A string representation of the sum of the two timeStamps, in the format HH:MM (modulo 24 hours)
                                &lt;=&gt; Both strings validates successfully
                                
                @throws {Invalid Argument Exception} if either input fails to validate.
              *&#x2F;
            addTimeStrings:     function(timeString_1, timeString_2){
                                    var t1 = this.validateTimeString(timeString_1);
                                    
                                    if (!t1){
                                            throw &quot;Invalid Argument: timeString_1&quot;;
                                    }
                                    var t2 = this.validateTimeString(timeString_2);
                                    
                                    if (!t2){
                                            throw &quot;Invalid Argument: timeString_2&quot;;
                                    }
                                    &#x2F;&#x2F;INVARIANT: either validateTimeString returns null, or it returns an array with integers;
                                    t1[1] += t2[1];
                                    t1[0] += t2[0];

                                    return formatTimeString(t1[0], t1[1]);   
                                },
                                
            &#x2F;** addIntToTimeString(timeString, minutes)
            
                Takes a string and an int value and checks if it is a valid
                time representation, according to the format HH:MM
                
                @method addIntToTimeString
                @for ChartUtils                
                @param {String} timeString The time string taken as initial time
                @param {Number} minutes How many minutes needs to be added to the time string;                                  
                @return {String} A string representation of the sum of the two time values, in the format HH:MM (modulo 24 hours)
                                &lt;=&gt; Both inputs validates successfully
                @throws {Invalid Argument Exception} if either input fails to validate
              *&#x2F;
            addIntToTimeString:     function(timeString, minutes){
                                    var t = this.validateTimeString(timeString);
                                    
                                    if (!t){
                                        throw &quot;Invalid Argument: timeString&quot;;
                                    }
                                    
                                    if (minutes &lt; 0){
                                        throw &quot;Invalid Argument: minutes&quot;;
                                    }
                                    &#x2F;&#x2F;INVARIANT: either validateTimeString returns null, or it returns an array with integers;
                                    t[1] += minutes;
                                    
                                    return formatTimeString(t[0], t[1]);  
                                }                                 
		};
		Object.freeze(utils);
		return utils;
	})();
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
