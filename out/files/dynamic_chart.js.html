<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>dynamic_chart.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/BasicBarChart.html">BasicBarChart</a></li>
            
                <li><a href="..&#x2F;classes/DynamicChart.html">DynamicChart</a></li>
            
                <li><a href="..&#x2F;classes/FixedWidthBarChart.html">FixedWidthBarChart</a></li>
            
                <li><a href="..&#x2F;classes/Legend.html">Legend</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/DynamicChart.html">DynamicChart</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: dynamic_chart.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F;require d3.v2.js
&#x2F;&#x2F;require chart_utils.js

if (!window.DynamicChart){
	&#x2F;**
		Module DynamicChart

        This module requires:
        
        {{#crossLinkModule &quot;chart_utils.js&quot;}}{{&#x2F;crossLinkModule}}
        {{#crossLink &quot;http:&#x2F;&#x2F;d3js.org&#x2F;d3.v2.js&quot;}}{{&#x2F;crossLink}} 

        Exposes methods for creating different types of dynamic charts:
        * BasicBarChart
        * FixedWidthBarChart
        * SlidingBarChart
        * TimeWheelChart
        
        @module DynamicChart
	*&#x2F;
	var DynamicChart = (function (){
		&quot;use strict&quot;;
		
        
        &#x2F;&#x2F;      -----       CONSTANTS       --------
        &#x2F;** 
            Maximum dimension of the input space, i.e. max number of subvalues for each single point
            @property MAX_SPACE_DIMENSION
            @for DynamicChart
            @type {Number}
            @final
            @private     
          *&#x2F;             
        var MAX_SPACE_DIMENSION = 10;
        &#x2F;** 
            Default fill colors bor graphic elements;
            @property FILL_COLORS
            @for DynamicChart
            @type {Array}
            @final
            @private     
          *&#x2F;    
        var FILL_COLORS = [&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;orange&quot;, &quot;purple&quot;, &quot;cyan&quot;, &quot;magenta&quot;, &quot;yellow&quot;, &quot;limegreen&quot;, &quot;brown&quot;];
        &#x2F;** 
            Default size for chart&#x27;s labels (in points);
            @property DEFAULT_LABEL_SIZE
            @for DynamicChart
            @type {Number}
            @final
            @private     
          *&#x2F;
        var DEFAULT_LABEL_SIZE = 12;
        &#x2F;** 
            Default size for chart&#x27;s title text (in points);
            @property DEFAULT_TITLE_SIZE
            @for DynamicChart
            @type {Number}
            @final
            @private     
          *&#x2F;        
        var DEFAULT_TITLE_SIZE = 22;
            &#x2F;** 
                Default width for legend&#x27;s item boxes (in pixel);
                @property LEGEND_ITEM_WIDTH
                @for DynamicChart
                @type {Number}
                @final
                @private     
              *&#x2F;               
        var LEGEND_ITEM_WIDTH = 25,
            &#x2F;** 
                Default height for legend&#x27;s item boxes (in pixel);
                @property LEGEND_ITEM_HEIGHT
                @for DynamicChart
                @type {Number}
                @final
                @private     
              *&#x2F;          
            LEGEND_ITEM_HEIGHT = 15,
            &#x2F;** 
                Default margin for legends (in pixel);
                @property LEGEND_MARGIN
                @for DynamicChart
                @type {Number}
                @final
                @private     
              *&#x2F;              
            LEGEND_MARGIN = 5,
            &#x2F;** 
                Default left margin for legend&#x27;s items (in pixel);
                @property LEGEND_ITEM_LEFT
                @for DynamicChart
                @type {Number}
                @final
                @private     
              *&#x2F;               
            LEGEND_ITEM_LEFT = LEGEND_MARGIN,
            &#x2F;** 
                Default font size for labels attached to legend&#x27;s items (in pixel);
                @property LEGEND_ITEM_FONT_SIZE
                @for DynamicChart
                @type {Number}
                @final
                @private     
              *&#x2F;              
            LEGEND_ITEM_FONT_SIZE = 11;      
        &#x2F;&#x2F;      -----       &#x2F;CONSTANTS       --------
        
        
        &#x2F;&#x2F;      -----       LEGEND       --------
        
        var legendPrototype = {
                            &#x2F;** setPosition(left, top)
                                Sets the position of the legend in the page. Position is assumed to be absolute.
                                
                                @method setPosition
                                @for Legend
                                @chainable
                                @param {Number} left [Mandatory]
                                                      The horizontal position of the legend bounding box;
                                                      Only Integers and values that can be converted to integers are accepted.
                                @param {Number} top [Mandatory]
                                                    The vertical position of the legend bounding box;
                                                    Only Integers and values that can be converted to integers are accepted.
                                @return {Object}    This legend object, to allow for method chaining.
                                @throws     Never: if either argument is not valid, simply ignores the action.
                            *&#x2F;
			setPosition:	function(left, top){
								left = parseInt(left, 10);
								top = parseInt(top, 10);
								if (this.__divElement__ &amp;&amp; !isNaN(left) &amp;&amp; !isNaN(top)){
									this.__divElement__.attr(&quot;style&quot;, &quot;position:absolute; left:&quot; + left + &quot;; top:&quot;+top +&quot;;&quot; );
								}	
                                return this;	&#x2F;&#x2F;Method chaining support
							},	
                            
                        &#x2F;** setWidth(width)
                            Sets the width of the legend bounding box.
                            
                            @method setWidth
                            @for Legend
                            @chainable
                            @param {Number} width   [Mandatory]
                                                    The new width of the legend;
                                                    Only positive integers and values that can be converted
                                                    to positive Integers are accepted.
                            @return {Object}    This legend object, to allow for method chaining.
                            @throws {Illegal Argument Exception} if the argument is not valid (see above). 
                        *&#x2F;                            
			setWidth: 	function(width){
							width = parseInt(width, 10);
							if (this.__svgElement__ &amp;&amp; !isNaN(width) &amp;&amp; width &gt;= 0){
								this.__svgElement__.attr(&quot;width&quot;, width);
                                this.__divElement__.attr(&quot;width&quot;, width);
							}else{
                                throw &quot;Illegal Argument: width&quot;;
                            }
							return this;	&#x2F;&#x2F;Method chaining support
						},	
                        
                        &#x2F;** setHeight(height)
                            Sets the height of the legend bounding box.
                            
                            @method setHeight
                            @for Legend
                            @chainable
                            @param {Number} height  [Mandatory]
                                                    The new height of the legend; 
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.
                            @return {Object}    This legend object, to allow for method chaining.
                            @throws &lt;ul&gt;
                                        &lt;li&gt; Illegal Argument Exception, if the argument is not valid (see above). &lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;    
                        *&#x2F;                             
			setHeight: function(height){
							height = parseInt(height, 10);
							if (this.__svgElement__ &amp;&amp; !isNaN(height) &amp;&amp; height &gt;= 0){
								this.__svgElement__.attr(&quot;height&quot;, height);
							}else{
                                throw &quot;Illegal Argument: height&quot;;
                            }
							return this;	&#x2F;&#x2F;Method chaining support
						},	
                           
                        &#x2F;** addItem(label, color)
                            Adds an item to the legend and then redraws it;
                            
                            @method addItem
                            @for Legend
                            @chainable
                            @param {String} labelText   [Mandatory]
                                                        The text of the label for this new item;
                            @param {String} labelColor  [Mandatory]
                                                        The color to be used to draw new item&#x27;s label;
                            @param {String} fillColor   [Mandatory]
                                                        The color associated with this new item;                                            
                            @return {Object}    This legend object, to allow for method chaining;
                            @throws &lt;ul&gt;
                                        &lt;li&gt; Wrong Number of arguments Exception, if either argument is missing. &lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;
                          *&#x2F;                        
            addItem:    function(labelText, labelColor, fillColor){
                            if (labelText === undefined || labelColor === undefined || fillColor === undefined){
                                throw &quot;Wrong number of arguments: label and color are both mandatory&quot;;
                            }
                            this.__items__.push({labelText: labelText, labelColor: labelColor, fillColor: fillColor});
                            var n = this.__items__.length - 1;
                            this.__svgElement__.append(&quot;rect&quot;)
                                           .attr(&quot;stroke&quot;, &quot;black&quot;)
                                           .attr(&quot;fill&quot;, fillColor)
                                           .attr(&quot;width&quot;, LEGEND_ITEM_WIDTH)
                                           .attr(&quot;height&quot;, LEGEND_ITEM_HEIGHT)
                                           .attr(&quot;x&quot;, LEGEND_ITEM_LEFT)
                                           .attr(&quot;y&quot;, LEGEND_MARGIN + n * (LEGEND_ITEM_HEIGHT + LEGEND_MARGIN));
                            this.__svgElement__.append(&quot;text&quot;)
                                           .text(labelText)
                                           .attr(&quot;fill&quot;, labelColor)
                                           .attr(&quot;x&quot;, LEGEND_ITEM_LEFT + LEGEND_ITEM_WIDTH + LEGEND_MARGIN)         &#x2F;&#x2F;Aligns to the bottom of the rect
                                           .attr(&quot;y&quot;, n * (LEGEND_ITEM_HEIGHT + LEGEND_MARGIN) + LEGEND_ITEM_HEIGHT)
											.attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
											.attr(&quot;font-size&quot;, LEGEND_ITEM_FONT_SIZE)
                                            .attr(&quot;text-anchor&quot;, &quot;left&quot;);                                         
                        }, 
                        &#x2F;** removeItem(index)
                            @method removeItem
                            @for Legend
                            @chainable
                            @param {Number} index   [Mandatory] 
                                                    The index of the item to update; 
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.
                            @return {Object}   This legend object, to allow for method chaining;                                
                            @throws &lt;ul&gt;
                                        &lt;li&gt;Illegal Argument Exception, if index is not in its valid range.&lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;
                         *&#x2F;
            removeItem: function(index){
                            index = parseInt(index, 10);
                            if (isNaN(index) || index &lt; 0 || index &gt;= this.__items__.length){
                                throw &quot;Illegal Argument: index&quot;;
                            }  
                            this.__items__.splice(index,1);
                            this.__svgElement__.selectAll(&quot;rect&quot;).data(this.__items__).exit().remove();
                            this.__svgElement__.selectAll(&quot;text&quot;).data(this.__items__).exit().remove();
                            this.__redrawLegend__();
                            return this;    &#x2F;&#x2F;Method chaining support
                        },
                        
                        &#x2F;** updateItem(index [, newLabelText, newLabelColor, newFillColor])
                            
                            Updates the attributes of an item of the legend and then redraws it;
                            
                            @method updateItem
                            @for Legend
                            @chainable
                            @param {Number} index   [Mandatory]
                                            The index of the item to update;
                            @param {String} [labelText]   [Optional]
                                                The new text for the label of the index-th item;
                                                If omitted or undefined won&#x27;t be changed;
                            @param {String} [labelColor]  [Optional]
                                                The new color to be used to draw the index-th item&#x27;s label;
                                                If omitted or undefined won&#x27;t be changed;
                            @param {String} [fillColor]   [Optional]
                                                The new color associated with the index-th item;
                                                If omitted or undefined won&#x27;t be changed;
                            @return {Object}    This legend object, to allow for method chaining;                                
                            @throws 
                                    - Illegal Argument Exception, if index is not in its valid range.
                         *&#x2F;
            updateItem: function(index, newLabelText, newLabelColor, newFillColor){
                            index = parseInt(index, 10);
                            if (isNaN(index) || index &lt; 0 || index &gt;= this.__items__.length){
                                throw &quot;Illegal Argument: index&quot;;
                            }
                            var oldItem = this.__items__[index];
                            if (newLabelText !== undefined){
                                oldItem.labelText = newLabelText;
                            }
                            if (newLabelColor !== undefined){
                                oldItem.labelColor = newLabelColor;
                            }    
                            if (newFillColor !== undefined){
                                oldItem.fillColor = newFillColor;
                            }                            
                            this.__redrawLegend__();
                            
                            return this;    &#x2F;&#x2F;Method chaining support
                        },
                        
                        &#x2F;** destroy()
                            
                            Object&#x27;s destructor: helps garbage collector freeing memory, and removes legend&#x27;s DOM elements.
                            
                            Object&#x27;s destructor: helps garbage collector freeing memory, and removes chart DOM elements.&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;: calling destroy on an object will force any further reference 
                                            to its attributes &#x2F; methods to throw exceptions.&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;NOTE&lt;&#x2F;b&gt;:   This function should be override by any class inheriting from this object.&lt;br&gt;
                                           In order to properly work, any overriding destroyer should:
                                            &lt;ol&gt;
                                                &lt;li&gt; Free any array specific to the object on which is called;&lt;&#x2F;li&gt;
                                                &lt;li&gt; Remove any event listener on chart objects;&lt;&#x2F;li&gt;
                                                &lt;li&gt; Call super object&#x27;s destroy method.&lt;&#x2F;li&gt;
                                            &lt;&#x2F;ol&gt;
                            @method destroy
                            @for Legend
                            @return {null} to state that the object has been destroyed.
                          *&#x2F;                        
            destroy: 	function(){
                                
                                &#x2F;&#x2F;Deletes all the elements from object&#x27;s arrays
                                this.__items__.length = 0;
                                
                                &#x2F;&#x2F;Removes DOM objects
                                this.__svgElement__.remove();
                                this.__divElement__.remove();

                                return null;
                            }
        };
        
        &#x2F;**
            @class Legend
            @private
          *&#x2F;
          &#x2F;&#x2F;@for BasicBarChart 
        
        &#x2F;** LegendFactory(width, height [, left, top, parent])
            [Private Object, only accessible to DynamicChart classes]
            
            Creates, upon request, a new Legend object and returns it;

            @method LegendFactory
            @for Legend
            @param {Number} [width]    [Mandatory]
                                    The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)
                                    Can be any value that is or can be converted to a positive integer.
            @param {Number} [height]  [Mandatory]
                                    The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)
                                    Can be any value that is or can be converted to a positive integer.
            @param {Number} [left]    [Optional]
                                    The horizontal position of the legend bounding box;
            @param {Number} [top]     [Optional]
                                    The vertical position of the legend bounding box;
            @param {Object} [parent= page&#x27;s body element]   [Optional]
                                    The DOM element to which the diagram should be appended as a child
            @return {Object}    A new Legend object;
            @throws
                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                    -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                        (through setWidth or setHeight)
                    -   Illegal Argument exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                    -   Exception, if dataDim exceeds the maximum data dimension
                    -   Exception, if parent is passed but it is not a valid DOM element
        *&#x2F;
        function LegendFactory(width, height, left, top, parent){
            
            &#x2F;** __init__(legend, width, height)
                [Private method, not visible from consumers]
                
                @method __init__
                @private
                
                @param {Object} legend  [Mandatory]
                                The legend object to be initialized;
                @param {Number} width   [Mandatory]
                                The width of the legend object;
                @param {Number} height  [Mandatory]
                                The height of the legend object;
                @return {undefined}
                @throws 
                            -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                                (through setWidth or setHeight)
              *&#x2F;
            function __init__(legend, width, height){
                legend.setWidth(width);
                legend.setHeight(height);
                legend.setPosition(left, top);
                legend.__svgElement__.append(&quot;rect&quot;)
                      .attr(&quot;stroke&quot;, &quot;black&quot;)
                      .attr(&quot;width&quot;, width)
                      .attr(&quot;fill&quot;, &quot;none&quot;)
                      .attr(&quot;height&quot;, height);            
            }
            
            var legend = Object.create(legendPrototype);
            
            &#x2F;** __redrawLegend__()
                [Protected method, not visible outside this library]
                
                Update the drawings of this legend object;
                
                @method __redrawLegend__
                @protected
                @return {undefined}
                @throws 
                            -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                                (through setWidth or setHeight)
              *&#x2F;                                            
            Object.defineProperty(legend, &quot;__redrawLegend__&quot;, {
                    value:	function(){
                    
                                this.__svgElement__.selectAll(&quot;rect&quot;).data(this.__items__)
                                               .attr(&quot;stroke&quot;, &quot;black&quot;)
                                               .attr(&quot;fill&quot;, function(item){return item.fillColor;})
                                               .attr(&quot;width&quot;, LEGEND_ITEM_WIDTH)
                                               .attr(&quot;height&quot;, LEGEND_ITEM_HEIGHT)
                                               .attr(&quot;x&quot;, LEGEND_ITEM_LEFT)
                                               .attr(&quot;y&quot;, function(item, i){return LEGEND_MARGIN + i * (LEGEND_ITEM_HEIGHT + LEGEND_MARGIN);});
                                this.__svgElement__.selectAll(&quot;text&quot;).data(this.__items__)
                                               .text(function(item){return item.labelText;})
                                               .attr(&quot;fill&quot;, function(item){return item.labelColor;})
                                               .attr(&quot;x&quot;, LEGEND_ITEM_LEFT + LEGEND_ITEM_WIDTH + LEGEND_MARGIN)         &#x2F;&#x2F;Aligns to the bottom of the rect
                                               .attr(&quot;y&quot;, function(item, i){return i * (LEGEND_ITEM_HEIGHT + LEGEND_MARGIN) + LEGEND_ITEM_HEIGHT;})
                                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                                .attr(&quot;font-size&quot;, LEGEND_ITEM_FONT_SIZE)
                                                .attr(&quot;text-anchor&quot;, &quot;left&quot;);  
                                
                                return;
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false                 
            }); 


            if (width === undefined  || height === undefined){
                throw &quot;Wrong number of arguments: width and height are mandatory&quot;;
            }
            if (parent === undefined){	&#x2F;&#x2F;By default, added to the 
                parent = d3.select(&quot;body&quot;);
            }
            
            var div = parent.append(&quot;div&quot;);
            var svg = div.append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;chart_legend&quot;);
            
                                                    &#x2F;** 
                                                        The div element that will be a container to the legend&#x27;s svg element
                                                        @property __divElement__
                                                        @type {Object}
                                                        @readOnly
                                                        @protected
                                                      *&#x2F;            
            Object.defineProperty(legend, &quot;__divElement__&quot;, {
                    value:	div,
                    writable: false,
                    enumerable: false,
                    configurable:false                                   
            });  
                                            &#x2F;**
                                                The svg element for this Legend
                                                @property __svgElement__
                                                @type {Object}
                                                @readOnly
                                                @protected
                                                
                                              *&#x2F;             
            Object.defineProperty(legend, &quot;__svgElement__&quot;, {
                    value:	svg,
                    writable: false,
                    enumerable: false,
                    configurable:false                                   
            });
                                          &#x2F;** 
                                                Array of the items contained in the legend
                                                @property __items__
                                                @type {Array}
                                                @readOnly
                                                @protected                                                
                                            *&#x2F;
            Object.defineProperty(legend, &quot;__items__&quot;, {
                    value:	[],
                    writable: false,
                    enumerable: false,
                    configurable:false
            });
            
            __init__(legend, width, height);
            
            Object.seal(legend);
            return legend;
        }

        
        &#x2F;&#x2F;      -----       DYNAMIC CHARTS       --------
        
        &#x2F;** 
            @class BasicBarChart
          *&#x2F;    
          &#x2F;&#x2F;uses Legend

		var next_id = 0;
		var basicBarChartSharedPrototype = {
                            &#x2F;** setPosition(left, top)
                                Sets the position of the chart in the page. Position is assumed to be absolute.
                                
                                @method setPosition
                                @chainable
                                @param {Number} left    [Mandatory]
                                                        The horizontal position of the chart bounding box;
                                @param {Number} top     [Mandatory]
                                                        The vertical position of the chart bounding box;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws     Never: if either argument is not valid, simply ignores the action.
                            *&#x2F;
			setPosition:	function(left, top){
								left = parseInt(left, 10);
								top = parseInt(top, 10);
								if (this.__divElement__ &amp;&amp; !isNaN(left) &amp;&amp; !isNaN(top)){
									this.__divElement__.attr(&quot;style&quot;, &quot;position:absolute; left:&quot; + left + &quot;; top:&quot;+top +&quot;;&quot; );
								}	
                                return this;	&#x2F;&#x2F;Method chaining support
							},	
                            
                        &#x2F;** setWidth(width)
                            Sets the width of the chart bounding box.
                            
                            @method setWidth
                            @chainable
                            @param {Number} width   [Mandatory]
                                                    The new width of the chart;&lt;br&gt;
                                                    Only positive integers and values that can be converted
                                                    to positive Integers are accepted.
                            @return {Object}    This chart object, to allow for method chaining.
                            @throws {Illegal Argument Exception} if the argument is not valid (see above). 
                        *&#x2F;                          
			setWidth: 	function(width){
							width = parseInt(width, 10);
							if (this.__svgElement__ &amp;&amp; !isNaN(width) &amp;&amp; width &gt;= 0){
								this.__svgElement__.attr(&quot;width&quot;, width);
                                this.__divElement__.attr(&quot;width&quot;, width);
							}else{
                                throw &quot;Illegal Argument: width&quot;;
                            }
							return this;	&#x2F;&#x2F;Method chaining support
						},	
                        
                        &#x2F;** setHeight(height)
                            Sets the height of the chart bounding box.
                            
                            @method setHeight
                            @chainable
                            @param {Number} height  [Mandatory]
                                                    The new height of the chart; &lt;br&gt;
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.
                            @return {Object}    This chart object, to allow for method chaining.
                            @throws &lt;ul&gt;
                                        &lt;li&gt; Illegal Argument Exception, if the argument is not valid (see above). &lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;    
                        *&#x2F;                             
			setHeight: function(height){
							height = parseInt(height, 10);
							if (this.__svgElement__ &amp;&amp; !isNaN(height) &amp;&amp; height &gt;= 0){
								this.__svgElement__.attr(&quot;height&quot;, height);
							}else{
                                throw &quot;Illegal Argument: height&quot;;
                            }
							return this;	&#x2F;&#x2F;Method chaining support
						},	

                        &#x2F;** setTitle(title [, size, color, left, top])
                            Sets the title for the chart, including all its attributes.
                            
                            @method setTitle
                            @chainable
                            @param {String} title  [Mandatory]
                                                    The new title for the chart;
                            @param {Number} [size=DEFAULT TITLE SIZE]  [Optional]
                                                    The size of the new title;&lt;br&gt;
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.                                                    
                            @param {String} [color=black]  [Optional]
                                                    The color of the new title;&lt;br&gt;
                            @param {Number} [left=centered]  [Optional]
                                                    The horizontal position of the title, relative to the chart; 
                                                    the text will be centered around this point&lt;br&gt;
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.  
                            @param {Number} [top=0]  [Optional]
                                                    The vertical position of the title, relative to the chart;&lt;br&gt;
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.                                                   
                            @return {Object}    This legend object, to allow for method chaining.
                            @throws &lt;ul&gt;
                                        &lt;li&gt; Illegal Argument Exception, if the argument is not valid (see above). &lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;    
                        *&#x2F;                          
            setTitle:   function(title, size, color, left, top){    
                            var titleElement = this.__svgElement__.selectAll(&quot;text[type=title_element]&quot;);
                            
                            size = parseInt(size, 10);
                            if (!Object.isNumber(size)){
                                size = DEFAULT_TITLE_SIZE;
                            }
                            
                            left = parseInt(left, 10);
                            if (!Object.isNumber(left)){
                                left = this.__svgElement__.attr(&quot;width&quot;) &#x2F; 2;
                            } 
                            
                            top = parseInt(top, 10);
                            if (!Object.isNumber(top)){
                                top = size;
                            }                             
                            
                            if (titleElement.empty()){
                                titleElement = this.__svgElement__.append(&quot;text&quot;)
                                                                  .attr(&quot;type&quot;, &quot;title_element&quot;)
                                                                  .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                                                  .attr(&quot;font-family&quot;, &quot;sans-serif&quot;);
                                                                  
                                                                  
                            }
                            titleElement.text(title)
                                        .attr(&quot;font-size&quot;, size)
                                        .attr(&quot;x&quot;, left)
                                        .attr(&quot;y&quot;, top)
                                        .attr(&quot;fill&quot;, color);
                            return this;	&#x2F;&#x2F;Method chaining support            
                        },
                        
						&#x2F;** addLegend:  function(labels, width, height [, left, top, parent])
                            
                            Insert new data into the chart, at runtime;
                            @method addLegend
                            @chainable
                            @param {Array} labels [Mandatory]
                                            An array containing exactly one label for each component of the data space.&lt;br&gt;
                                            A new legend object will be created and attached to the chart, and then
                                            for every subcomponent [label] a new item will be added to the legend.       
                            @return {Object} This chart object, to support method chaining;  
                            @throws 
                                    -   Illegal Argument Exception: if labels isn&#x27;t an Array object.
                                    -   Invalid array size Exception:   if the number of elements in the array is different
                                                                        from the number of subcomponents of the data space
                                                                        (i.e. from the __dataDim__ attribute)
						  *&#x2F;  
            addLegend:  function(labels, width, height, left, top, parent){
                            if (this.hasOwnProperty(&quot;__legend__&quot;)){
                                if (!Object.isArray(labels)){
                                    throw &quot;Illegal Argument: labels&quot;;
                                }
                                else if (labels.length !== this.__dataDim__){
                                    throw &quot;Invalid array size: &quot; + this.__dataDim__ + &quot; labels needed&quot;;
                                }
                                if (this.__legend__ &amp;&amp; this.__legend__.destroy){
                                    this.__legend__.destroy();
                                }
                                
                                if (parent === undefined){
                                    parent = this.__parent__;   &#x2F;&#x2F;By default, they&#x27;ll have the same parent;
                                }
                                
                                this.__legend__ = LegendFactory(width, height, left, top, parent);
                                
                                for (var i=0; i&lt;labels.length; i++){
                                    this.__legend__.addItem(labels[i], this.getLabelColor(i), this.getFillColor(i));
                                }                                
                            }else{
                                &#x2F;&#x2F;Looks for object&#x27;s prototype
                                var proto = this.prototype ? this.prototype : this.__proto__;
                                if (proto &amp;&amp; proto.addLegend){
                                    proto.addLegend(labels, width, height, left, top, parent);
                                }                                    
                            }             

                            return this;    &#x2F;&#x2F;Method chaining supported
                        },  
 
						&#x2F;** appendData(newDataArray)
                            Insert new data into the chart, at runtime;
                            
                            @method appendData
                            @chainable
                            @param {Array} newDataArray [Mandatory]
                                                    An array containing the next values that needs to be drawn in the chart;&lt;br&gt;
                                                    Each array element, in order to be added to the chart, must be compliant
                                                    with the data format defined by the function __formatData__ (which 
                                                    can itself be set at runtime, and by default accepts arrays of 
                                                    __dataDim__ integers, neglecting to render the negative ones).
                                                    
                            @return {Object} This chart object, to support method chaining;  
                            @throws 
                                    -   Illegal Argument Exception: if newDataArray isn&#x27;t an Array object.
						  *&#x2F;                         
			appendData: function(newDataArray){
							&#x2F;*for (var key in newData){
								this.data[key] = newData[key];
							}*&#x2F;
                            
                            &#x2F;&#x2F;Save the number to use it during drawing (for scaling)
                            var oldDataLength = Math.max(this.__dataDim__, this.__getDatasetLength__() * this.__dataDim__);
                    
                            &#x2F;&#x2F;Checks how much data can be appended, and if any action is needed to do so
                            newDataArray = this.__canAppendData__(newDataArray);
                            
							var i, j, val;
							if (Object.isArray(newDataArray)){
								var n = newDataArray.length;
								for (i=0; i &lt; n; i++){
									val = this.__formatValue__(newDataArray[i]);
									if (val !== null){
                                        for (j=0; j &lt; this.__dataDim__; j++){
                                            this.__data__[j].push(val[j]);
                                            if (val[j] &gt; this.__maxVals__[j]){
                                                this.__maxVals__[j] = val[j];
                                            }
                                        }
									}
								}	
							}else{
                                throw &quot;Illegal Argument: newDataArray must be an Array&quot;;
                            }
	&#x2F;&#x2F;						console.log(this.__data__);
                            
                            
                            var newDataLength = this.__getDatasetLength__() * this.__dataDim__;
                            
                            &#x2F;&#x2F;The max is recomputed every time to retain the ability to switch on the fly between scaling locally and globally
                            var max_val;
                            
                            if (this.__scaleGlobally__){
                                max_val = ChartUtils.fillArray(this.__maxVals__.max(), this.__dataDim__);
                            }else{
                                max_val = this.__maxVals__;    &#x2F;&#x2F;Values aren&#x27;t going to be modified, so we can just copy the reference
                            }
                            
                            for (j = 0; j &lt; this.__dataDim__; j++){  
                                &#x2F;&#x2F;Set the old X scale until the new data is added
                                this.__xScale__.domain([0, oldDataLength]);
                                var dataSet = this.__selectData__(this.__data__, j);
                                
                                var labelsSet = this.__selectLabels__(this.__data__, j);
                                
                                this.__drawNewData__(dataSet, labelsSet, j, this.__xScale__, this.__yScale__[j]);
                                &#x2F;&#x2F;Computes the new X and Y scale
                                this.__xScale__.domain([0, newDataLength]);
                                
                                this.__yScale__[j].domain([0, 	max_val[j]]);
                                this.__updateDrawing__(dataSet, labelsSet, j, this.__xScale__, this.__yScale__[j]);
                            }
							
							return this;	&#x2F;&#x2F;Method chaining oriented
						},
                        
                        &#x2F;** setFormatValueFunction(formaValueFunction)
                            
                            Change the data formatting function, allowing to pass a custom handler
                            to cope with JSON or other data formats.
                            
                            @method setFormatValueFunction
                            @chainable
                            @param {Function} formaValueFunction [Mandatory] 
                                                                 The new data formatting&#x2F;parsing function;
                            @return {Object}    This object, to allow for method chaining;
                            @throws     
                                        - Illegal Argument Exception, if the argument passed isn&#x27;t a valid function.
                          *&#x2F;                        
            setFormatValueFunction: function(formaValueFunction){
                                        if (formaValueFunction === undefined ||
                                            !Object.isFunction(formaValueFunction)){
                                                throw &quot;Illegal Argument: formaValueFunction&quot;;
                                            }
                                        Object.defineProperty(this, &quot;__formatValue__&quot;, {
                                            value: formaValueFunction,
                                            writable: true,
                                            enumerable: false,
                                            configurable:false
                                        });
                                        return this;    &#x2F;&#x2F;Method chaining support
                                    },
                        &#x2F;** clearData(n)
                        
                            Remove all the data, or part of it, from the chart;
                            
                            @method clearData
                            @chainable
                            @param {Number} [n] [Optional, For internal use only] 
                                        The number of elements to remove from the beginning of the data array,
                                        i.e. how many of the oldest values should be removed from the chart;
                            @return {Object}    This object, to allow for method chaining;
                            @throws     Illegal Argument Exception, if n is passed but it isn&#x27;t valid, i.e. it isn&#x27;t convertible to a positive int.
                          *&#x2F;
			clearData:	function(n){
                                var i, dataSet, labelsSet;
                                if (n !== undefined){
                                    &#x2F;&#x2F;Only part of the chart should be cleared
                                    n = parseInt(n, 10);
                                    if (isNaN(n) || n &lt;= 0 || n &gt; this.__getDatasetLength__()){
                                        throw &quot;Illegal Argument: n&quot;;
                                    }
                                }else{
                                    &#x2F;&#x2F;The whole chart must be cleared
                                    n = this.__getDatasetLength__();
                                }    
                                    
                                for (i=0; i &lt; this.__dataDim__; i++){

                                    dataSet = this.__selectData__(this.__data__, i, n);
                                    labelsSet = this.__selectLabels__(this.__data__, i, n);  
                                    this.__clearDrawing__(dataSet, labelsSet);
                                    this.__data__[i].splice(0, n);  &#x2F;&#x2F;Removes the first n elements
                                    &#x2F;&#x2F;Recomputes the max values
                                    this.__maxVals__[i] = this.__data__[i].max();
                                } 

                                this.__onClearData__(n);
	
								return this;	&#x2F;&#x2F;Method chaining oriented
							},
							
                            &#x2F;** toggleLabels([index, visible])
                                Toggles the visibility of labels in the chart
                            
                                @method toggleLabels
                                @chainable
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be affected;
								@param {Boolean} [visible] [Optional]
                                                If specified overwrites toggle behaviour and set
												the visibility to visible.
                                @return {Object}    This chart object, to allow for method chaining
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;
			toggleLabels:	function(index, visible){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}	
								if (this.__labelsVisible__.length &gt; index){
                                    if (visible !== undefined){
                                        this.__labelsVisible__[index] = visible ? true : false;
                                    }else{
                                        this.__labelsVisible__[index] = ! this.__labelsVisible__;
                                    }                                
								}else{
									throw &quot;Invalid Index&quot;;
								}

								return this;	&#x2F;&#x2F;Method chaining oriented
							},
                                    &#x2F;** areLabelsVisible([index])
                                        
                                        Checks if labels for the index-th dimension are visible
                                    
                                        @method areLabelsVisible
                                        @param {Number} [index=0]   [Optional]
                                                        For multi-dimensional data spaces, specifies
                                                        which component is going to be affected;
                                        @return {Boolean}    The visibility of the label 
                                        @throws 
                                                    Invalid Index Exception:   if the index specified isn&#x27;t valid.
                                      *&#x2F;                            
			areLabelsVisible:	function(index){
                                    if (!index){	&#x2F;&#x2F;index === undefined || index === null
                                        index = 0;
                                    }	
                                    if (this.__labelsVisible__.length &gt; index){
                                        return this.__labelsVisible__[index];                               
                                    }else{
                                        throw &quot;Invalid Index&quot;;
                                    }
                                },
                                &#x2F;** setGlobalScaling()
                                
                                    Sets scaling to global&lt;br&gt;
                                    &lt;br&gt;
                                    When data space has a dimension greater than 1 (i.e. when each data value has more than 1 component)
                                    these charts support either global scaling (relative to the whole dataset)
                                    or local scaling (relative to value of the same component) of each subcomponent.
                                    
                                    @method setGlobalScaling
                                    @chainable
                                    @return {Object}    This chart object, to allow for method chaining.
                                  *&#x2F;
            setGlobalScaling:   function(){
                                    if (this.hasOwnProperty(&quot;__scaleGlobally__&quot;)){
                                        this.__scaleGlobally__ = true;
                                    }else{
                                        &#x2F;&#x2F;Looks for object&#x27;s prototype
                                        var proto = this.prototype ? this.prototype : this.__proto__;
                                        if (proto &amp;&amp; proto.setGlobalScaling){
                                            proto.setGlobalScaling();
                                        }                                    
                                    }  
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                },
                                &#x2F;** setLocalScaling()
                                
                                    Sets scaling to local&lt;br&gt;
                                    &lt;br&gt;
                                    When data space has a dimension greater than 1 (i.e. when each data value has more than 1 component)
                                    these charts support either global scaling (relative to the whole dataset)
                                    or local scaling (relative to value of the same component) of each subcomponent.
                                    @method setLocalScaling
                                    @chainable                                    
                                    @return {Object}    This chart object, to allow for method chaining.
                                  *&#x2F;                                
            setLocalScaling:    function(){
                                    if (this.hasOwnProperty(&quot;__scaleGlobally__&quot;)){
                                        this.__scaleGlobally__ = false;
                                    }else{
                                        &#x2F;&#x2F;Looks for object&#x27;s prototype
                                        var proto = this.prototype ? this.prototype : this.__proto__;
                                        if (proto &amp;&amp; proto.setLocalScaling){
                                            proto.setLocalScaling();
                                        }
                                    }    
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                },   

                            &#x2F;** getFillColor([index])
                                
                                Gets the fill color used to draw the index-th component of the data space.
                                
                                @method getFillColor
                                @chainable
                                @param {Number} [index=0]   [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {String|Object}    The selected fill color.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;                                
			getFillColor:	function(index){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}								
								if (this.__fillColors__.length &gt; index){
									return this.__fillColors__[index];
								}else{
									throw &quot;Invalid Index&quot;;
								}
							},		
                            &#x2F;** getStrokeColor([index])
                                
                                Gets the stroke color used to draw the index-th component of the data space.
                                
                                @method getStrokeColor
                                @param {Number} [index=0]   [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {String}    The selected stroke color.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;                                   
			getStrokeColor:	function(index){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}								
								if (this.__strokeColors__.length &gt; index){
									return this.__strokeColors__[index];
								}else{
									throw &quot;Invalid Index&quot;;
								}
							},	
                            &#x2F;** getLabelColor([index])
                                
                                Gets the fill color used for the labels attached to the index-th component of the data space.
                                @method getLabelColor
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {String}    The selected label color.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;                                
			getLabelColor:	function(index){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}								
								if (this.__labelColors__.length &gt; index){
									return this.__labelColors__[index];
								}else{
									throw &quot;Invalid Index&quot;;
								}
							},
                            &#x2F;** getLabelsSize([index])
                                
                                Gets the size used for the labels attached to the index-th component of the data space.
                                
                                @method getLabelsSize
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Number}    The selected size.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;                               
			getLabelsSize:	function(index){
                                    if (!index){	&#x2F;&#x2F;index === undefined || index === null
                                        index = 0;
                                    }	
                                    if (this.__labelsSize__.length &gt; index){
                                        return this.__labelsSize__[index];                               
                                    }else{
                                        throw &quot;Invalid  Index&quot;;
                                    }
                                },   
                            &#x2F;** setFillColor(color, [index])
                                
                                Sets the fill color used to draw the index-th component of the data space.
                                
                                @method setFillColor
                                @chainable
                                @param {String|Object] color   [Mandatory]
                                                The new fill color for the selected component&#x27;s;
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid;
							  *&#x2F;                                 
            setFillColor:	function(color, index){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}								
								if (this.__fillColors__.length &gt; index){
									this.__fillColors__[index] = color;
								}else{
									throw &quot;Invalid Index&quot;;
								}
								
                                if (this.__legend__){   &#x2F;&#x2F;&amp;&amp; this.__legend__.updateItem 
                                                        &#x2F;&#x2F;INVARIANT: __legend__ is either null or a valid legend [Since it&#x27;s an inner class, we avoid defensive programming]
                                    this.__legend__.updateItem(index, undefined, undefined, color);
                                }
								return this;
							},
                            &#x2F;** setStrokeColor(color, [index])
                                
                                Sets the stroke color used to draw the index-th component of the data space.
                            
                                @method setStrokeColor
                                @chainable
                                @param {String} color   [Mandatory]
                                                The new stroke color for the selected component&#x27;s;
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid;
							  *&#x2F;                             
			setStrokeColor:	function(color, index){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}								
								if (this.__strokeColors__.length &gt; index){
									this.__strokeColors__[index] = color;
								}else{
									throw &quot;Invalid Index&quot;;
								}
								
								return this;
							},  
                            &#x2F;** setLabelColor(color, [index])
                                
                                Sets the fill color used for the labels attached to the index-th component of the data space.
                            
                                @method setLabelColor
                                @chainable
                                @param {String} color   [Mandatory]
                                                The new color for the selected component&#x27;s labels;
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid;
							  *&#x2F;                               
			setLabelColor:	function(color, index){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}								
								if (this.__labelColors__.length &gt; index){
									this.__labelColors__[index] = color;
								}else{
									throw &quot;Invalid Index&quot;;
								}
                                
                                if (this.__legend__){   &#x2F;&#x2F;&amp;&amp; this.__legend__.updateItem 
                                                        &#x2F;&#x2F;INVARIANT: __legend__ is either null or a valid legend [Since it&#x27;s an inner class, we avoid defensive programming]
                                    this.__legend__.updateItem(index, undefined, color, undefined);
                                }                                
								
								return this;
							},
                            &#x2F;** setLabelSize(size, [index])
                                
                                Sets the size used for the labels attached to the index-th component of the data space.
                            
                                @method setLabelSize
                                @chainable
                                @param {Number} size    [Mandatory]
                                                The new size for the selected component&#x27;s labels;
                                                Must be a positive integer, or a value that can be converted
                                                to a positive integer;
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid;
                                            - Illegal Argument Exception:   if size isn&#x27;t valid (see above). 
							  *&#x2F;                            
			setLabelSize:	function(size, index){
                                size = parseInt(size, 10);
                                if (isNaN(size) || size &lt;= 0){
                                    throw &quot;Illegal Argument: size&quot;;
                                }
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}								
								if (this.__labelsSize__.length &gt; index){
									this.__labelsSize__[index] = size;
								}else{
									throw &quot;Invalid Index&quot;;
								}
								
								return this;
							} ,
                            &#x2F;** setBarWidth()
                            
                                Sets the bars width property;
                                For this chart, bar width is computed at runtime according to the number of bars plotted,
                                so this property can&#x27;t be set.&lt;br&gt;
                                &lt;b&gt;Unless overridden, any call to this method will cause an exception to be thrown&lt;&#x2F;b&gt;&lt;br&gt;
                                This method is declared to improve the consistency of the interface.
                                     
                                @method setBarWidth
                                @throws Read only property Exception
                              *&#x2F;
            setBarWidth: 	function(&#x2F;*barWidth*&#x2F;){
                                throw &quot;Read only property: barWidth&quot;;
                            },
                            &#x2F;** getBarWidth([xScale])
                                
                                Gets the current bar width for this chart;
                                For this chart, bar width is computed at runtime according to the number of bars plotted;
                            
                                @method getBarWidth
                                @param {Object} [xScale=this.__xScale__]  [Optional]
                                                It is possible to pass a d3 scale object to get the bar width
                                                computed with respect to a different scale metric;&lt;br&gt;
                                                On default, the value is computed with respect to this chart&#x27;s
                                                current metric.
                                @return {Number}    The value computed for the bar width under current object state.
                                @throws 
                                            - Illegal Argument Exception:   if an invalid xScale object is passed.
							  *&#x2F;                              
            getBarWidth: 	function(xScale){
                                
                                if (xScale === undefined){
                                    xScale = this.__xScale__;
                                }
                                
                                if (!xScale){
                                    throw &quot;Illegal Argument: xScale&quot;;
                                }
                                return xScale(1) - xScale(0) - 1;
                            },
                            
                        &#x2F;** destroy()
                            
                            Object&#x27;s destructor: helps garbage collector freeing memory, and removes chart DOM elements.&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;: calling destroy on an object will force any further reference 
                                            to its attributes &#x2F; methods to throw exceptions.&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;NOTE&lt;&#x2F;b&gt;:   This function should be override by any class inheriting from this chart.&lt;br&gt;
                                           In order to properly work, any overriding destroyer should:
                                            &lt;ol&gt;
                                                &lt;li&gt; Free any array specific to the object on which is called;&lt;&#x2F;li&gt;
                                                &lt;li&gt; Remove any event listener on chart objects;&lt;&#x2F;li&gt;
                                                &lt;li&gt; Call super object&#x27;s destroy method.&lt;&#x2F;li&gt;
                                            &lt;&#x2F;ol&gt;
                            @method destroy
                            @return {null} to state that the object has been destroyed.
                          *&#x2F;                        
            destroy: 	function(){
                                &#x2F;&#x2F;Removes all the data from the chart;
                                this.clearData();
                                
                                &#x2F;&#x2F;Deletes all the elements from object&#x27;s arrays
                                this.__data__.length = 0;
                                this.__maxVals__.length = 0;
                                this.__yScale__.length = 0;
                                this.__strokeColors__.length = 0;
                                this.__fillColors__.length = 0;
                                this.__labelColors__.length = 0;
                                this.__labelsSize__.length = 0;
                                this.__labelsVisible__.length = 0;
                                
                                &#x2F;&#x2F;Removes DOM objects
                                this.__svgElement__.remove();
                                this.__divElement__.remove();
                                
                                &#x2F;&#x2F;Removes legend, if any
                                if (this.__legend__ &amp;&amp; this.__legend__.destroy){
                                    this.__legend__.destroy();
                                }
                                return null;
                            }
                              
                        
		};
        
        &#x2F;&#x2F;  ---------------------  PROTECTED METHODS    ---------------------------------------
          
         Object.defineProperty(basicBarChartSharedPrototype, &quot;__getDatasetLength__&quot;, {
                                &#x2F;** __getDatasetLength__()  
                                    
                                    Utility function to take account of the number of points currently added to the chart
                                    
                                    @method __getDatasetLength__
                                    @protected
                                    @return {Number}    How many points are stored in the dataset right now.
                                *&#x2F;
                        value: 	function(){
                            &#x2F;&#x2F;INVARIANT: there will always be at least 1 element in __data__ array [assumed to avoid defensive programming]
                            return this.__data__[0].length;
						},
						writable: false,
						enumerable: false,
						configurable:false
					});	
                    
        Object.defineProperty(basicBarChartSharedPrototype, &quot;__canAppendData__&quot;, {
                                &#x2F;** __canAppendData__(newDataArray)  
                                 
                                    Checks that new data can be added to the chart (if the chart can represent only a limited number of points);&lt;br&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;: This function SHOULD be overriden in any class inheriting from the base class
                                    in order to handle differents needs
                                    
                                    @method __canAppendData__
                                    @protected

                                    @param {Array} newDataArray    [Mandatory]
                                                            The array of values that should be added;
                                    @return {Array}    The array of values that can still be added to the chart;&lt;br&gt;
                                                       If no other value can be added, return the empty list.                                              
                                *&#x2F;
                        value: 	function(newDataArray){
                            if (!Object.isArray(newDataArray)){
                                return [];
                            }
                            &#x2F;&#x2F;else, if the bar width still has a valid value, returns the input value, otherwise the empty list
                            return this.__getDatasetLength__() === 0 || this.getBarWidth(this.__xScale__) &gt; 0 ? newDataArray : [];
						},
						writable: false,
						enumerable: false,
						configurable:false
					});	   
                    
        Object.defineProperty(basicBarChartSharedPrototype, &quot;__formatValue__&quot;, {
                                &#x2F;** __formatValue__(value)
                                    
                                    Checks that the value passed corresponds to the data format allowed for the current chart;
                                    This function can be overriden in any class inheriting from the base class
                                    in order to handle differents data formats (i.e. Objects or JSON).
                                    
                                    @method __formatValue__
                                    @protected
                                    @param {Array|Object} value   [Mandatory]
                                                                    The value to be tested;
                                    @return {Array} &lt;ul&gt;
                                                        &lt;li&gt;An array with properly formatted values, each of whom 
                                                            converted to float &lt;=&gt; value is correctly validated&lt;&#x2F;li&gt;
                                                        &lt;li&gt;null &lt;-&gt; Otherwise&lt;&#x2F;li&gt;
                                                    &lt;&#x2F;ul&gt;
                                *&#x2F;
                        value: 	function(value){
                            if (Object.isArray(value)){
                                if (value.length !== this.__dataDim__){
                                    &#x2F;&#x2F;Invalid data;
                                    return null;
                                }
                                for (var i=0; i &lt; this.__dataDim__; i++){
                                    if (!Object.isNumber(value[i])){
                                        return null;
                                    }
                                }
                                &#x2F;&#x2F;At this point we can assume the value is valid
                                return value.map(parseFloat);
                            }else if (Object.isNumber(value) &amp;&amp; this.__dataDim__ === 1){
                                return [parseFloat(value)];
                            }else{
                                &#x2F;&#x2F;Invalid value
                                return null;
                            }
						},
						writable: false,
						enumerable: false,
						configurable:false
					});	
               
		Object.defineProperty(basicBarChartSharedPrototype, &quot;__selectData__&quot;, {
                                &#x2F;** __selectData__(data, index [, n])
                                
                                    Returns the list of the svg elements used to represent data subcomponents
                                    with the required index.&lt;br&gt;
                                    I.e.:   if data space is 3-dimensional (i.e. every point has 3 components)
                                            __selectData__(data, 2) would select the svg elements representing
                                            the 2nd component of every point in data
                                            
                                    @method __selectData__
                                    @protected
                                    
                                    @param {Array} data [Mandatory]
                                                        The dataset on which selection should be applied
                                    @param {Number} index   [Mandatory]
                                                    The index of the required component&lt;br&gt;
                                                    &lt;b&gt;INVARIANT&lt;&#x2F;b&gt;:  to avoid defensive programming,
                                                                        it is assumed 0 &lt;= index &lt; this.__dataDim__
                                    @param {Number} [n] [Optional]
                                                    The maximum number of elements to return;
                                    @return {Object} The proper set of d3 elements.                    
                                  *&#x2F;
						value: 	function(data, index, n){
                                    if (n === undefined){
                                        return this.__svgElement__.selectAll(&quot;rect[index=data_&quot;+index+&quot;]&quot;).data(data[index]);
                                    }else{
                                        return this.__svgElement__.selectAll(&quot;rect[index=data_&quot;+index+&quot;]&quot;).data(data[index].slice(0, n));
                                    }
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});
                    
		Object.defineProperty(basicBarChartSharedPrototype, &quot;__selectLabels__&quot;, {
                                &#x2F;** __selectLabels__(data, index [, n])
                                  
                                    Returns the list of the svg elements used to draw the labels of
                                    subcomponents of data with the required index.&lt;br&gt;
                                    I.e.:   if data space is 3-dimensional (i.e. every point has 3 components)
                                            __selectLabels__(data, 3) would select the svg elements representing
                                            the labels of the 3nd component of every point in data  
                                    
                                    @method __selectLabels__
                                    @protected
                                    

                                    @param {Array} data [Mandatory]
                                                    The dataset on which selection should be applied;
                                    @param {Number} index   [Mandatory]
                                                    The index of the required component;&lt;br&gt;
                                                    &lt;b&gt;INVARIANT&lt;&#x2F;b&gt;:  to avoid defensive programming,
                                                                        it is assumed 0 &lt;= index &lt; this.__dataDim__
                                    @param {Number} [n] [Optional]
                                                    The maximum number of elements to return;
                                    @return {Object}    The proper set of d3 elements.                    
                                  *&#x2F;      
						value: 	function(data, index, n){
                                    if (n === undefined){
                                        return this.__svgElement__.selectAll(&quot;text[index=data_&quot;+index+&quot;]&quot;).data(data[index]);
                                    }else{
                                        return this.__svgElement__.selectAll(&quot;text[index=data_&quot;+index+&quot;]&quot;).data(data[index].slice(0, n));
                                    }
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});

                    
		Object.defineProperty(basicBarChartSharedPrototype, &quot;__drawNewData__&quot;, {
                                &#x2F;** __drawNewData__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                    
                                    Called by appendData() to draw the newly added points in dataSet, once for
                                    every data subcomponent.&lt;br&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                this method and __updateDrawing__ in order to obtain a custom chart.

                                                
                                    
                                    @method __drawNewData__
                                    @protected
                                    @param {Object} dataSet [Mandatory]
                                                    The set of svg elements created so far to represent the data;&lt;br&gt;
                                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;: this parameter should be generated by an appropriate
                                                                    call to __selectData__;
                                    @param {Object} labelsSet [Mandatory]
                                                        The set of svg elements created so far to represent the labels of the data;&lt;br&gt;
                                                        &lt;b&gt;WARNING&lt;&#x2F;b&gt;: this parameter should be generated by an appropriate
                                                                        call to __selectLabels__; 
                                    @param {Number} dataIndex   [Mandatory]
                                                                The index of the component of the data which is to be drawn;
                                    @param {Object} xScale  [Mandatory]
                                                    D3 scale object for X axis;
                                    @param {Object} yScale  [Mandatory]
                                                    D3 scale object for Y axis (specific to current component);
                                    @return {undefined}
                                  *&#x2F;
						value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
									var that = this;
									var height = parseInt(this.__svgElement__.attr(&quot;height&quot;), 10);
									var barWidth =  this.getBarWidth(xScale);
                                    
									dataSet.enter().append(&quot;rect&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
										.attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex);})
										.attr(&quot;y&quot;, height)	
										.attr(&quot;width&quot;, barWidth)
										.attr(&quot;height&quot;, 0)	
										.attr(&quot;fill&quot;, that.getFillColor(dataIndex))
                                        .attr(&quot;stroke&quot;, that.getStrokeColor(dataIndex))
										.attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});
										
									
									if (that.areLabelsVisible(dataIndex)){
										labelsSet.enter().append(&quot;text&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
											.text(function(d) {return d;})
											.attr(&quot;text-anchor&quot;, &quot;middle&quot;)
											.attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex) + barWidth &#x2F; 2;})
											.attr(&quot;y&quot;, height)
											.attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
											.attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
											.attr(&quot;fill&quot;, that.getLabelColor(dataIndex))
                                            .attr(&quot;opacity&quot;, function(){  &#x2F;&#x2F;Show the label only if it fits the bar
                                                                if (this.getComputedTextLength() &lt;= barWidth){
                                                                    return 1;
                                                                }else{
                                                                    return 0;
                                                                }
                                                            });
									}else{
										labelsSet.remove();
									}
										
									return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
								},
						writable: false,
						enumerable: false,
						configurable:false
					});
                    
		Object.defineProperty(basicBarChartSharedPrototype, &quot;__updateDrawing__&quot;, {
                                &#x2F;** __updateDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                    
                                    Called by appendData() to update drawing of the points in dataSet, once for
                                    every data subcomponent.&lt;br&gt;
                                    After new data is inserted by __drawNewData__, appendData performs adjustments
                                    to accomodate for scale change or shift in the drawing due to time, and this
                                    function takes care of updating and fixing the chart representation.&lt;br&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                        this method and __drawNewData__ in order to obtain a custom chart.                                    
                                    @method __updateDrawing__
                                    @protected
                                    @param {Object} dataSet [Mandatory]
                                                    The set of svg elements created so far to represent the data;&lt;br&gt;
                                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;: this parameter should be generated by an appropriate
                                                                    call to __selectData__;
                                    @param {Object} labelsSet   [Mandatory]
                                                        The set of svg elements created so far to represent the labels of the data;&lt;br&gt;
                                                        &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    this parameter should be generated by an appropriate
                                                                            call to __selectLabels__;    
                                    @param {Number} dataIndex   [Mandatory]
                                                        The index of the component of the data which is to be drawn;
                                    @param {Object} xScale  [Mandatory]
                                                            D3 scale object for X axis;
                                    @param {Object} yScale  [Mandatory]
                                                            D3 scale object for Y axis (specific to current component).
                                    @return {undefined}
                                  *&#x2F;					
                        value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                    var that = this;
                                    var height = parseInt(this.__svgElement__.attr(&quot;height&quot;), 10);
                                    var barWidth = this.getBarWidth(xScale);							
                                    dataSet.transition()&#x2F;&#x2F;.delay(250)
                                            .attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex);})
                                            .attr(&quot;y&quot;, function(d){return height - yScale(d);})
                                            .attr(&quot;width&quot;, barWidth)
                                            .attr(&quot;height&quot;, function(d){return yScale(d);})
                                            .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});									
                                    if (that.areLabelsVisible(dataIndex)){
                                        labelsSet.transition()&#x2F;&#x2F;.delay(250)
                                                .text(function(d) {return d;})
                                                .attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex) + barWidth &#x2F; 2;})
                                                .attr(&quot;y&quot;, function(d){return height - yScale(d) + 15 ;})
                                                .attr(&quot;opacity&quot;, function(){ &#x2F;&#x2F;Show the label only if it fits the bar
                                                                    if (this.getComputedTextLength() &lt;= barWidth){
                                                                        return 1;
                                                                    }else{
                                                                        return 0;
                                                                    }
                                                                });                                                
                                                
                                    }else{
                                        labelsSet.remove();
                                    }						
                                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});				
                    
			Object.defineProperty(basicBarChartSharedPrototype, &quot;__onClearData__&quot;, {
            
                                &#x2F;** __onClearData__(n)
                                    
                                    Takes care of the remaining details related to the removal of part of the values from the chart,
                                    based on to the particular chart needs.&lt;br&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    Inherited objects MIGHT NEED to override this function.
                                    
                                    @method __onClearData__
                                    @protected
                                    @param {Number} [n]   [Mandatory]
                                                          Must be a positive Integer, or a value that
                                                          can be converted to a positive Integer;
                                                          Number of elements removed from the chart
                                    @return {undefined}
                                  *&#x2F;
                        value:	function(n){
                                    &#x2F;&#x2F;Do nothing: for this object no special action required (but it&#x27;s required to be in the class interface)
                                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});		
                    
			Object.defineProperty(basicBarChartSharedPrototype, &quot;__clearDrawing__&quot;, {            
                                &#x2F;** __clearDrawing__(dataSet, labelsSet)
                                    
                                    Removes the svg objects related to the data cleared by the caller (clearData).
                                    
                                    @method __clearDrawing__
                                    @protected

                                    
                                    @param {Object} dataSet [Mandatory]
                                                            List of drawing objects (default: rects) representing data
                                    @param {Object} labelsSet   [Mandatory]
                                                                List of labels related to data removed
                                    @return {undefined}
                                  *&#x2F;
                        value:	function(dataSet, labelsSet){
                                    dataSet.remove();
                                    labelsSet.remove();	
                                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});	   

                    
			Object.defineProperty(basicBarChartSharedPrototype, &quot;__getBarOpacity__&quot;, {
                            &#x2F;** __getBarOpacity__(val)
                                
                                 Computes and return the suggested value for the opacity of the bar
                                drawn to represent a certain value.
                                      
                                @method __getBarOpacity__
                                @protected
                                @param {Number} val [Mandatory]
                                            The value to be represented;&lt;br&gt;
                                            Accepts only normalized values (scaled between 0 and 1).&lt;br&gt;
                                            &lt;b&gt;INVARIANT&lt;&#x2F;b&gt;:  to avoid defensive programming,
                                                                it is assumed 0 &lt;= val &lt;=1                               
                                @return {Number}    The opacity to apply to the value representation in the chart.
                              *&#x2F;            
					value:	function(val){
								return 0.25 + val * 0.75;
							},
						writable: false,
						enumerable: false,
						configurable:false
					});	
                    
		Object.freeze(basicBarChartSharedPrototype);

        &#x2F;** BasicBarChart(width, height [, dataDim, parent])
            
            Basic bar histogram chart.
            Values are represented using vertical bars;
            Each point or value can have up to 10 subcomponents, where each component can be 
            any non-nregative real number (i.e., each point can be in R_+^i, for 1 &lt;= i &lt;= 10).
              
            @method BasicBarChart
            @chainable
            
            @param {Number} width [Mandatory]
                            The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} height [Mandatory]
                            The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} [dataDim=1] [Optional]
                            The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                            Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
            @param {Object} [parent=body] [Optional]
                            The DOM element to which the diagram should be appended as a child
            @return {Object}    A new BasicBarChart object
            @throws
                                -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                                    (through setWidth or setHeight)
                                -   Illegal Argument exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                -   Exception, if dataDim exceeds the maximum data dimension
                                -   Exception, if parent is passed but it is not a valid DOM element
          *&#x2F;
        function BasicBarChart(width, height, dataDim, parent){
                   

            &#x2F;** __initChart__(width, height)
                @private
                [Private method]
                
                Inits the chart DIV and SVG container, setting width and height, if they are passed as arguments;
                @param chart:   [Mandatory]
                                The chart object that needs initialization;
                @param width:   [Optional]
                                The desired width for the chart;
                                If passed, MUST be a positive integer, or a value that
                                can be converted to a positive integer
                @param height:   [Optional]
                                The desired height for the chart;
                                If passed, MUST be a positive integer, or a value that
                                can be converted to a positive intege
                @return:    Nothing;
                @throws     
                            - Inconsitent Chart State Exception, if the internale state of the object is compromised;
                            - Illegal Argument Exception, through setWidth or setHeight, if one of the arguments is
                                not valid.
            *&#x2F;
            function __initChart__(chart, width, height){
                if (!chart.__svgElement__ || !chart.__divElement__){
                    throw &quot;Inconsitent Chart State: null&quot;;
                }
                &#x2F;&#x2F;else
                if (width !== undefined){
                    chart.setWidth(width);
                }
                if (height !== undefined){
                    chart.setHeight(height);
                }										
                return;     &#x2F;&#x2F;(Pseudo)private method, no need to retun anything
            }  
            
            &#x2F;** __initData__(basicCharObj [, dataDim])
                
                Performs all the settings related to the data handling area of the chart;
                
                @method __initData__
                @private
                @param {Object} basicCharObj [Mandatory]
                                             The chart object to init;
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues
                                for each data entry;&lt;br&gt;
                                Can take any value that is or can be converted to an integer 
                                between 1 and MAX_SPACE_DIMENSION.
                @return {undefined}   
                @throws
                                    -   Illegal Argument exception, if dataDim is passed but it&#x27;s 
                                        not valid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension                             
               *&#x2F;
            function __initData__(basicCharObj, dataDim){
                if (dataDim === undefined){
                    dataDim = 1;   &#x2F;&#x2F;1 by default
                }else{
                    dataDim = parseInt(dataDim, 10);
                    if (isNaN(dataDim) || dataDim &lt;= 0){
                        throw &quot;Illegal Argument: dataDim&quot;;
                    }else if (dataDim &gt; MAX_SPACE_DIMENSION){
                        throw &quot;Max number of subvalues for each point (&quot; + MAX_SPACE_DIMENSION + &quot;) exceeded&quot;;
                    }
                }            
                  
                                                     &#x2F;** 
                                                         Dimension of the data space, 
                                                         i.e. number of subcomponents of each data &quot;point&quot;
                                                         @property __dataDim__
                                                         @type {Number}
                                                         @readOnly
                                                         @protected                                                         
                                                       *&#x2F;
                Object.defineProperty(basicBarChart, &quot;__dataDim__&quot;, {
                                        value: dataDim,
                                        writable: false,
                                        enumerable: false,
                                        configurable: false
                                    });   
                                            
                                                    &#x2F;** 
                                                        The array that will hold data, separately for each component
                                                        Initially every component&#x27;s array is set to []
                                                         @property __data__
                                                         @type {Array}
                                                         @readOnly
                                                         @protected                                                          
                                                      *&#x2F;
                Object.defineProperty(basicBarChart, &quot;__data__&quot;, {
                                        value: ChartUtils.fillArray(function(){return [];}, basicBarChart.__dataDim__),
                                        writable: false,
                                        enumerable: false,
                                        configurable: false
                                    });
                                                     &#x2F;** 
                                                         Array of maximum values for each component
                                                         (used to compute the vertical scale)&lt;br&gt;
                                                         @property __maxVals__
                                                         @type {Number}
                                                         @readOnly
                                                         @protected                                                           
                                                         @default [0]*
                                                       *&#x2F;
                Object.defineProperty(basicBarChart, &quot;__maxVals__&quot;, {
                                        value: ChartUtils.fillArray(0, basicBarChart.__dataDim__),
                                        writable: false,
                                        enumerable: false,
                                        configurable: false
                                    });      
                
                return;     &#x2F;&#x2F;Private method, no need to return anything
            }
        

            if (width === undefined  || height === undefined){
                throw &quot;Wrong number of arguments: width and height are mandatory&quot;;
            }
            if (parent === undefined){	&#x2F;&#x2F;By default, added to page&#x27;s body
                parent = d3.select(&quot;body&quot;);
            }
            
            
            
            var div = parent.append(&quot;div&quot;);
            var svg = div.append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;dynamic_chart_&quot; + next_id); &#x2F;&#x2F;NOTE: ++next_id needed after this
            next_id += 1;
            
            var basicBarChart = Object.create(basicBarChartSharedPrototype);
            
            __initData__(basicBarChart, dataDim);
            
            var __xScale__ = d3.scale.linear().range([0, width]);
            var __yScaleGenerator__ = function(){return d3.scale.linear().range([0, height]);};    

                                                &#x2F;** 
                                                    The parent object to whom the chart is added
                                                    @property __parent__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected
                                                  *&#x2F;
            Object.defineProperty(basicBarChart, &quot;__parent__&quot;, {
                                    value: parent,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
            
                                                &#x2F;**
                                                    The div element that will be a container to the chart&#x27;s svg element
                                                    @property __divElement__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                    
                                                  *&#x2F;
            Object.defineProperty(basicBarChart, &quot;__divElement__&quot;, {
                                    value: div,
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });
                                
                                                &#x2F;**
                                                    The chart&#x27;s svg element
                                                    @property __svgElement__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__svgElement__&quot;, {
                                    value: svg,
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });

                                                &#x2F;**
                                                    Scale object for the horizontal axis of the chart 
                                                    (common to all data subcomponents)
                                                    @property __xScale__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__xScale__&quot;, {
                                    value: __xScale__,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	

                                                &#x2F;**
                                                    Scale objects for the vertical axis of the chart 
                                                    (array with one obj for each data subcomponents,
                                                     so that each component can be scaled independently)
                                                    @property __yScale__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                  *&#x2F;                                       
            Object.defineProperty(basicBarChart, &quot;__yScale__&quot;, {
                                    value: ChartUtils.fillArray(__yScaleGenerator__, basicBarChart.__dataDim__),
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                                                 &#x2F;**
                                                    For data space with dimension gt 1, states
                                                    if the different components should scale locally or globally
                                                    @property __scaleGlobally__
                                                    @type {Boolean}
                                                    @readOnly
                                                    @protected
                                                    @default true
                                                   *&#x2F;
            Object.defineProperty(basicBarChart, &quot;__scaleGlobally__&quot;, {
                                    value: true,  &#x2F;&#x2F;By default, scales globally
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                }); 

                                                 &#x2F;**
                                                    For each data subcomponent, stores the size to be used
                                                    for its label
                                                    @property __labelsSize__
                                                    @type {Number}
                                                    @readOnly
                                                    @protected
                                                    @default DEFAULT_LABEL_SIZE
                                                  *&#x2F;   
            Object.defineProperty(basicBarChart, &quot;__labelsSize__&quot;, {
                                    value: ChartUtils.fillArray(DEFAULT_LABEL_SIZE, basicBarChart.__dataDim__),
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });		
                                                 &#x2F;**
                                                    For each data subcomponent, states whether or not
                                                    its label is visible
                                                    @property __labelsVisible__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                    @default [true]*
                                                  *&#x2F;                                      
            Object.defineProperty(basicBarChart, &quot;__labelsVisible__&quot;, {
                                    value: ChartUtils.fillArray(true, basicBarChart.__dataDim__),    &#x2F;&#x2F;All labels visible by default
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	
                                
                                                 &#x2F;**
                                                    For each data subcomponent, stores the color to be used
                                                    to fill its drawing component
                                                    @property __labelsVisible__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                  *&#x2F;                                      
            Object.defineProperty(basicBarChart, &quot;__fillColors__&quot;, {
                                    value: FILL_COLORS.shallowCopy(basicBarChart.__dataDim__),  &#x2F;&#x2F;Default values
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });

                                                 &#x2F;**
                                                    For each data subcomponent, stores the color to be used
                                                    for the stroke of its drawing component
                                                    @property __strokeColors__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                    @default [&quot;black&quot;]*
                                                  *&#x2F;                                       
            Object.defineProperty(basicBarChart, &quot;__strokeColors__&quot;, {
                                    value: ChartUtils.fillArray(&quot;black&quot;, basicBarChart.__dataDim__),  &#x2F;&#x2F;Default values: black
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	
                                                 &#x2F;**
                                                    For each data subcomponent, stores the color to be used
                                                    to draw its labels
                                                    @property __labelColors__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                    @default [&quot;black&quot;]*                                                    
                                                  *&#x2F;                                       
            Object.defineProperty(basicBarChart, &quot;__labelColors__&quot;, {
                                    value: ChartUtils.fillArray(&quot;black&quot;, basicBarChart.__dataDim__),  &#x2F;&#x2F;Default values: black
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	  

                                                 &#x2F;**
                                                    Placeholder for a possible legend object, if the consumer
                                                    decides to add a legend to the chart;
                                                    @property __legend__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected
                                                    @default null
                                                  *&#x2F;                                       
            Object.defineProperty(basicBarChart, &quot;__legend__&quot;, {
                                    value: null,  &#x2F;&#x2F;Default value: none
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });	  

            
            __initChart__(basicBarChart, width, height);
            Object.seal(basicBarChart);

            return basicBarChart;
        }
        
        &#x2F;** 
            @class FixedWidthBarChart
            @extends BasicBarChart
          *&#x2F;
        &#x2F;** FixedWidthBarChart(ticks, startingPoint, width, height [, dataDim, parent])
            
            Advanced Chart: FixedWidthBarChart
            Inherits from BasicBarChart redefining the drawing methods.
            As for its super class values are represented using vertical bars, and each point 
            can have up to 10 subcomponents, where each component can be any non-negative 
            real number (i.e., each point can be in R_+^i, for 1 &lt;= i &lt;= 10).
            
            For this chart the bar width is fixed (although can be set at run time)
            It is possible to choose between having only a fixed number of values accepted,
            or if a certain number of the oldest values should be removed when the
            chart is full.
            
            @method FixedWidthBarChart
            @param {Number} ticks [Mandatory]
                            The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} startingPoint [Mandatory, but not used at the moment: inserted for future back-compatibility]&lt;br&gt;
                            The reference for the label of the first point.&lt;br&gt;
                            Should be an incrementable value;
            @param {Number} width [Mandatory]
                            The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} height [Mandatory]
                            The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} [dataDim=1] [Optional]
                            The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                            Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
            @param {Object} [parent=body] [Optional]
                            The DOM element to which the diagram should be appended as a child
            @return:    A new FixedWidthBarChart object
            @throws
                                -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                    (through setWidth or setHeight)
                                -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                -   Exception, if dataDim exceeds the maximum data dimension
                                -   Exception, if the ratio between chart&#x27;s width and number of ticks is such
                                    that the computed bar height is smaller than 1 pixel
                                -   Exception, if parent is passed but it is not a valid DOM element
          *&#x2F;                
        function FixedWidthBarChart(ticks, startingPoint, width, height, dataDim, parent){
   
            ticks = parseInt(ticks, 10);
            if (isNaN(ticks) || ticks &lt;= 0){
                throw &quot;Illegal Argument: ticks&quot;;
            }
            
            var proto = BasicBarChart(width, height, dataDim, parent);
            var fixedWidthBarChart = Object.create(proto);   
              

                                                  &#x2F;** Number of different values that can be 
                                                      drawn at the same time in this chart
                                                    *&#x2F;
            Object.defineProperty(fixedWidthBarChart, &quot;__ticks__&quot;, {
                                    value: ticks,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                                                    &#x2F;** Tick length, in minutes
                                                        [Defaults to 1]
                                                      *&#x2F;
            Object.defineProperty(fixedWidthBarChart, &quot;__tickLength__&quot;, {
                                    value: 1,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	
                                                
                                                    &#x2F;** When __ticks__ data points have already been plotted,
                                                        new plots would override previous ones.
                                                        Two solutions are made available:
                                                        1)  By default, new data is rejected, generating a full stack exception;
                                                        2)  A certain number of the oldest data points can be purged off the chart,
                                                            counter-clockwise rotating the data
                                                      *&#x2F;
            Object.defineProperty(fixedWidthBarChart, &quot;__ticksToRemoveOnFullQueue__&quot;, {
                                    value: 0,           &#x2F;&#x2F;By default, no previous data is cleared: new data is simply rejected
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });	   
                                

            Object.defineProperty(fixedWidthBarChart, &quot;setFixedDataLengthMode&quot;, {
                                            &#x2F;** setFixedDataLengthMode()
                                            
                                                Sets fixed data length mode.
                                                
                                                When __ticks__ data points have already been plotted,
                                                new plots would override previous ones.
                                                Two solutions are made available:
                                                1)  By default, new data is rejected, generating a full stack exception;
                                                2)  A certain number of the oldest data points can be purged off the chart,
                                                    counter-clockwise rotating the data
                                                    
                                                This function sets the first option.
                                                
                                                @chainable
                                                @return:    This chart object, to allow for methd chaining.
                                              *&#x2F;                
                                    value:  function(){                                        
                                                if (this.hasOwnProperty(&quot;__ticksToRemoveOnFullQueue__&quot;)){
                                                    this.__ticksToRemoveOnFullQueue__ = 0;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setFixedDataLengthMode){
                                                        proto.setFixedDataLengthMode();
                                                    }
                                                }                                         
                                                return this;	&#x2F;&#x2F;Method chaining oriented
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	                                      
                                

            Object.defineProperty(fixedWidthBarChart, &quot;setShifitingDataMode&quot;, {
                                            &#x2F;** setShifitingDataMode(ticksToRemove)
                                            
                                                Sets data shift mode.
                                                
                                                When __ticks__ data points have already been plotted,
                                                new plots would override previous ones.
                                                Two solutions are made available:
                                                1)  By default, new data is rejected, generating a full stack exception;
                                                2)  A certain number of the oldest data points can be purged off the chart,
                                                    shifting back (left) the remaining data.
                                                    
                                                This function sets the second option.
                                                @chainable
                                                @param ticksToRemove: [Mandatory]
                                                                      How much data to remove on full chart;
                                                @return:    This object, to allow for method chaining;
                                                @throws     Illegal Argument Exception, if the argument isn&#x27;t valid (see above).
                                              *&#x2F;
                                    value:  function(ticksToRemove){
                                                ticksToRemove = parseInt(ticksToRemove, 10);
                                                if (isNaN(ticksToRemove) || ticksToRemove &lt;= 0){
                                                    throw &quot;Illegal Arguments: ticksToRemove&quot;;
                                                }
                                                if (this.hasOwnProperty(&quot;__ticksToRemoveOnFullQueue__&quot;)){
                                                    this.__ticksToRemoveOnFullQueue__ = ticksToRemove;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setShifitingDataMode){
                                                        proto.setShifitingDataMode(ticksToRemove);
                                                    }
                                                }                                                      
                                                return this;	&#x2F;&#x2F;Method chaining oriented
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });                                    

                                    
            Object.defineProperty(fixedWidthBarChart, &quot;getBarWidth&quot;, {
                                            &#x2F;** getBarWidth()
                                                
                                                Returns current bars&#x27; width.
                                                The overridden version takes a parameter, but this method
                                                doesn&#x27;t need it because barWidth is fixed for this chart.
                                                @return: the value set for __barWidth__;
                                                @override:  basicBarChartSharedPrototype.getBarWidth
                                              *&#x2F;
                                    value: 	function(){
                                                return this.__barWidth__;   &#x2F;&#x2F;Stroke tickness is 1 point per side
                                            },   
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });	                              

            Object.defineProperty(fixedWidthBarChart, &quot;__canAppendData__&quot;, {
                                        &#x2F;** __canAppendData__(newDataArray)
                                            @protected
                                            [Protected method, not supposed to be used by consumers]
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;: This function SHOULD be overriden in any class inheriting from the base class
                                                     in order to handle differents needs
                                                     
                                            @override:  basicBarChartSharedPrototype.__canAppendData__
                                        *&#x2F;
                                value: 	function(newDataArray){
                                    if (!Object.isArray(newDataArray)){
                                        return [];
                                    }
                                    &#x2F;&#x2F;else, checks if there is room for the new data
                                    var m = this.__getDatasetLength__(), 
                                        n = this.__ticks__ - m;
                                    
                                    if (newDataArray.length &lt;= n){
                                        return newDataArray;
                                    }else if (this.__ticksToRemoveOnFullQueue__ === 0){
                                        if (n &lt;= 0){
                                            &#x2F;&#x2F;Can&#x27;t add any more data
                                            return [];
                                        }else{
                                            &#x2F;&#x2F;Can add at most n elements
                                            return newDataArray.splice(0, n);
                                        }
                                    }else{
                                        &#x2F;&#x2F;Must delete __ticksToRemoveOnFullQueue__ elements from the data, and then can add the new ones 
                                        m =  Math.min(this.__ticksToRemoveOnFullQueue__, m);                                            
                                        this.clearData(m);
                                        
                                        &#x2F;&#x2F;Will update as soon as it returns control to the caller (appendData)
                                        
                                        return this.__canAppendData__(newDataArray);  &#x2F;&#x2F;reiterate the request
                                    }
                                    
                                },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });	      		

                    Object.defineProperty(fixedWidthBarChart, &quot;__drawNewData__&quot;, {
                                        &#x2F;** __drawNewData__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                            @protected
                                            [Protected method, not supposed to be used by consumers]
                                                                                           
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                        this method and __updateDrawing__ in order to obtain a custom chart.

                                            @override:   basicBarChartSharedPrototype.__drawNewData__
                                          *&#x2F;
                                value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                            var that = this;
                                            var height = parseInt(this.__svgElement__.attr(&quot;height&quot;), 10);
                                            var barWidth =  this.getBarWidth(xScale);
                                            
                                            dataSet.enter().append(&quot;rect&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                                .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex)*barWidth;})
                                                .attr(&quot;y&quot;, height)	
                                                .attr(&quot;width&quot;, barWidth)
                                                .attr(&quot;height&quot;, 0)	
                                                .attr(&quot;fill&quot;, that.getFillColor(dataIndex))
                                                .attr(&quot;stroke&quot;, that.getStrokeColor(dataIndex))
                                                .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});
                                                
                                            
                                            if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                                                labelsSet.enter().append(&quot;text&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                                    .text(function(d) {return d;})
                                                    .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                                    .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex + 0.5) * barWidth;})
                                                    .attr(&quot;y&quot;, height)
                                                    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                                    .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                                                    .attr(&quot;fill&quot;, that.getLabelColor(dataIndex));	
                                            }else{
                                                labelsSet.remove();
                                            }
                                                
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });
                
                Object.defineProperty(fixedWidthBarChart, &quot;__updateDrawing__&quot;, {
                                        &#x2F;** __updateDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                            @protected
                                            [Protected method, not supposed to be used by consumers]
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                        this method and __drawNewData__ in order to obtain a custom chart.
                                                        
                                            @override:  basicBarChartSharedPrototype.__updateDrawing__
                                          *&#x2F;					
                                value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                            var that = this;
                                            var height = parseInt(this.__svgElement__.attr(&quot;height&quot;), 10);
                                            var barWidth = this.getBarWidth(xScale);							
                                            dataSet.transition()&#x2F;&#x2F;.delay(250)
                                                    .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex)*barWidth;})
                                                    .attr(&quot;y&quot;, function(d){return height - yScale(d);})
                                                    .attr(&quot;width&quot;, barWidth)
                                                    .attr(&quot;height&quot;, function(d){return yScale(d);})
                                                    .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});									
                                            if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                                                labelsSet.transition()&#x2F;&#x2F;.delay(250)
                                                        .text(function(d) {return d;})
                                                        .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex + 0.5) * barWidth;})
                                                        .attr(&quot;y&quot;, function(d){return height - yScale(d) + that.getLabelsSize(dataIndex) ;});
                                                        
                                            }else{
                                                labelsSet.remove();
                                            }						
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });	      
                                
            &#x2F;** __init__()
                @private
                [Private method, not visible to consumers]
                
                Inits the chart by computing the allowed barWidth;
                
                @param chart:   [Mandatory]
                                The chart object that needs initialization;                   
                @param width:   [Mandatory]
                                Chart&#x27;s width;
                @param height:  [Mandatory]
                                Chart&#x27;s height;                                                            
                
                @return: Nothing
              *&#x2F;                                    
            function __init__(chart, width, height){
                var barWidth = width &#x2F; (chart.__dataDim__ * chart.__ticks__);
                if (barWidth &lt;= 0){
                    throw &quot;Illegal Arguments combination: width too small to draw &#x27;ticks&#x27; values&quot;;
                }
                                            &#x2F;** The width of each bar
                                              *&#x2F;                                        
                Object.defineProperty(chart, &quot;__barWidth__&quot;, {
                                            value: barWidth,
                                            writable: false,
                                            enumerable: false,
                                            configurable: false
                                        });	
                return ;
            }

            __init__(fixedWidthBarChart, width, height);
            Object.seal(fixedWidthBarChart);
            
            return fixedWidthBarChart;
        }

        &#x2F;** SlidingBarChart(ticks, width, height [, dataDim, parent])
            @extends {FixedWidthBarChart}
            
            Advanced Chart: SlidingBarChart
            Inherits from FixedWidthBarChart redefining the drawing methods.
            As for its super class values are represented using vertical bars, and each point 
            can have up to 10 subcomponents, where each component can be any non-negative 
            real number (i.e., each point can be in R_+^i, for 1 &lt;= i &lt;= 10).
            
            For this chart the bar width is fixed (although can be set at run time)
            It is possible to choose between having only a fixed number of values accepted,
            or if a certain number of the oldest values should be removed when the
            chart is full.
            
            Every __ticksBetweenHighlights__ values inserted (where __ticksBetweenHighlights__ can 
            be set at runtime, although it defaults to 10) the background of those values is highlighted, 
            to stress out time progression.
            
            @param {Number} ticks [Mandatory]
                            The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} width [Mandatory]
                            The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} height [Mandatory]
                            The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} [dataDim=1] [Optional]
                            The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                            Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
            @param {Object} [parent=body] [Optional]
                            The DOM element to which the diagram should be appended as a child
            @return {Object}    A new SlidingBarChart object
            @throws
                                -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                    (through setWidth or setHeight)
                                -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                -   Exception, if dataDim exceeds the maximum data dimension
                                -   Exception, if the ratio between chart&#x27;s width and number of ticks is such
                                    that the computed bar height is smaller than 1 pixel
                                -   Exception, if parent is passed but it is not a valid DOM element
          *&#x2F;                
        function SlidingBarChart (ticks, width, height, dataDim, parent){
   
            ticks = parseInt(ticks, 10);
            if (isNaN(ticks) || ticks &lt;= 0){
                throw &quot;Illegal Argument: ticks&quot;;
            }
            
            var DEFAULT_BACKGROUND = &quot;lightgrey&quot;;
            var DEFAULT_BACKGROUND_HIGHLIGHT = &quot;lightpink&quot;;
            var AXES_LABEL_SIZE = 14;
            var AXES_LABEL_WIDTH = 50;
            var AXES_LABEL_MARGIN = 5;
            
            var proto = FixedWidthBarChart(ticks, 0, width, height, dataDim, parent);	
            var slidingBarChart = Object.create(proto);   
                                             
                                                    &#x2F;** Takes track of how much data has been actually inserted into
                                                        the chart from its creation (to synch the highlighted ticks)
                                                      *&#x2F;
            Object.defineProperty(slidingBarChart, &quot;__dataCounter__&quot;, {
                                value: 	0,
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });
                            
                                                    &#x2F;** 
                                                        Every __ticksBetweenHighlights__ ticks, the data is &quot;higlighted&quot;
                                                        by applying the selected highlight style to the background
                                                        [Defaults to 10]
                                                      *&#x2F;
            Object.defineProperty(slidingBarChart, &quot;__ticksBetweenHighlights__&quot;, {
                                value: 	10,
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });  
            Object.defineProperty(slidingBarChart, &quot;getTicksBetweenHighlights&quot;, {
                                            &#x2F;** getTicksBetweenHighlights()
                                            
                                                Returns the number of ticks between two consecutive highlights (one extreme inclusive)
                                                @return:    The number of ticks between two consecutive highlights;
                                              *&#x2F;
                                    value:  function(){
                                                return this.__ticksBetweenHighlights__;                                                    
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });  
                                
            Object.defineProperty(slidingBarChart, &quot;setTicksBetweenHighlights&quot;, {
                                            &#x2F;** setTicksBetweenHighlights(ticks)
                                                
                                                Sets the number of ticks between two consecutive highlights (one extreme inclusive)
                                                
                                                @chainable
                                                @param ticks:   [Mandatory]
                                                                The number of ticks between two consecutive highlights;
                                                @return:    This object, to allow for method chaining;
                                              *&#x2F;
                                    value:  function(ticks){
                                                
                                                if (this.hasOwnProperty(&quot;__ticksBetweenHighlights__&quot;)){
                                                    this.__ticksBetweenHighlights__ = ticks;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setTicksBetweenHighlights){
                                                        proto.setTicksBetweenHighlights(ticks);
                                                    }
                                                }                                                      
                                                return this;	&#x2F;&#x2F;Method chaining oriented
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });                                    

                                                    &#x2F;** Color of the background bars
                                                        Defaults to DEFAULT_BACKGROUND (&quot;lightgrey&quot;)
                                                      *&#x2F;
            Object.defineProperty(slidingBarChart, &quot;__backgroundColor__&quot;, {
                                value: 	DEFAULT_BACKGROUND,
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });

                            
                                                    &#x2F;** Color of the background bars when highlighted
                                                        Defaults to DEFAULT_BACKGROUND_HIGHLIGHT (&quot;lightpink&quot;)
                                                      *&#x2F;
            Object.defineProperty(slidingBarChart, &quot;__backgroundHighlightColor__&quot;, {
                                value: 	DEFAULT_BACKGROUND_HIGHLIGHT,
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });

            Object.defineProperty(slidingBarChart, &quot;setBackgroundColor&quot;, {
                                            &#x2F;** setBackgroundColor(bgColor)
                                            
                                                Changes the background color (not highlighted points)
                                                
                                                @chainable
                                                @param bgColor: [Mandatory]
                                                                The new color for background bars;
                                                @return:    This object, to allow for method chaining;
                                              *&#x2F;
                                    value:  function(bgColor){
                                                
                                                if (this.hasOwnProperty(&quot;__backgroundColor__&quot;)){
                                                    this.__backgroundColor__ = bgColor;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setBackgroundColor){
                                                        proto.setBackgroundColor(bgColor);
                                                    }
                                                }                                                      
                                                return this;	&#x2F;&#x2F;Method chaining oriented
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });                                    

                                    
            Object.defineProperty(slidingBarChart, &quot;getBackgroundColor&quot;, {
                                            &#x2F;** getBackgroundColor()
                                            
                                                Returns current background bars&#x27; color
                                                
                                                @return: the value set for __backgroundColor__;
                                              *&#x2F;
                                    value: 	function(){
                                                return this.__backgroundColor__;
                                            },   
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });	    

            Object.defineProperty(slidingBarChart, &quot;setBackgroundHighlightColor&quot;, {
                                            &#x2F;** Changes the background color for highlighted points
                                                
                                                @chainable
                                                @param bgHColor: [Mandatory]
                                                                The new color for highlighted background bars;
                                                @return:    This object, to allow for method chaining;
                                              *&#x2F;
                                    value:  function(bgHColor){
                                                
                                                if (this.hasOwnProperty(&quot;__backgroundHighlightColor__&quot;)){
                                                    this.__backgroundHighlightColor__ = bgHColor;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setBackgroundHighlightColor){
                                                        proto.setBackgroundHighlightColor(bgHColor);
                                                    }
                                                }                                                      
                                                return this;	&#x2F;&#x2F;Method chaining oriented
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });                                    

                                    
            Object.defineProperty(slidingBarChart, &quot;getBackgroundHighlightColor&quot;, {
                                            &#x2F;** Returns current color for background highlighted bars 
                                                @return: the value set for __backgroundHighlightColor__;
                                              *&#x2F;
                                    value: 	function(){
                                                return this.__backgroundHighlightColor__;
                                            },   
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });	                                    

                                
            Object.defineProperty(slidingBarChart, &quot;__canAppendData__&quot;, {
                                        &#x2F;** __canAppendData__(newDataArray)
                                            @protected
                                            [Protected method, not supposed to be used by consumers]
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;: This function SHOULD be overriden in any class inheriting from the base class
                                                     in order to handle differents needs
                                                     
                                            @override:  fixedWidthBarChart.__canAppendData__
                                        *&#x2F;
                                value: 	function(newDataArray){
                                    if (!Object.isArray(newDataArray)){
                                        return [];
                                    }
                                    &#x2F;&#x2F;else, checks if there is room for the new data
                                    var m = this.__getDatasetLength__(), 
                                        n = this.__ticks__ - m,
                                        k = newDataArray.length;

                                    &#x2F;&#x2F;Checks that it isn&#x27;t trying to add more data than it is allowed to...
                                    if (k &gt; this.__ticks__){
                                        &#x2F;&#x2F;... if it is so, discards the oldest surplus among the new data
                                        newDataArray.splice(0, k - this.__ticks__);
                                        k = this.__ticks__;
                                    }
                                    
                                    this.__dataCounter__ += k;
                                    
                                    if (k &lt;= n){
                                        
                                        return newDataArray;
                                    }else{
                                        &#x2F;&#x2F;Must delete the exceding elements from the data, and then can add the new ones 
                                        m =  Math.min(k, m);                                            
                                        this.clearData(m);
                                        
                                        &#x2F;&#x2F;Will update as soon as it returns control to the caller (appendData)                                          
                                        return newDataArray;  &#x2F;&#x2F;reiterate the request
                                    }
                                    
                                },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });	 
                            
                    Object.defineProperty(slidingBarChart, &quot;__selectBackgroundBars__&quot;, {
                                            &#x2F;** __selectBackgroundBars__([filter])
                                                @protected
                                                [Protected method, not supposed to be used by consumers]
                                                
                                                Returns the list of the svg elements used to draw background; 
                                                Elements can be filtered using a custom filter passad as an optional
                                                parameter;

                                                @param filter:  [Optional]
                                                                A filter to be applied to the selection;
                                                @return:    The proper set of d3 elements.                    
                                              *&#x2F;
                                    value: 	function(filter){
                                                if (filter === undefined){
                                                    return this.__svgElement__.selectAll(&quot;rect[type=back]&quot;);
                                                }else{
                                                    return this.__svgElement__.selectAll(&quot;rect[type=back]&quot;).filter(filter);
                                                }
                                            },
                                    writable: false,
                                    enumerable: false,
                                    configurable:false
                                });
                                
                    Object.defineProperty(slidingBarChart, &quot;__updateBackground__&quot;, {
                                        &#x2F;** __updateBackground__()
                                            @protected
                                            [Protected method, not supposed to be used by consumers]
                                            
                                            Called by __drawNewData__() to redraw the background properly
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                        this method as well as __drawNewData__ and __updateDrawing__ 
                                                        in order to obtain a custom chart.
                                            
                                            @return:    Nothing.
                                          *&#x2F;
                                value: 	function(){
                                            var counter = this.__dataCounter__,
                                                ticks = this.getTicksBetweenHighlights();
                                            var bgColor = this.getBackgroundColor(),
                                                bgHColor = this.getBackgroundHighlightColor();
                                            &#x2F;&#x2F;Redraws all background bars with normal style 
                                            this.__selectBackgroundBars__()
                                                .attr(&quot;fill&quot;, bgColor);
                                             
                                            &#x2F;&#x2F;Redraws only the highlighted ones with highlighted style 
                                            this.__selectBackgroundBars__(  function(){
                                                                                return counter &gt; this.d_index &amp;&amp; 
                                                                                       (counter - this.d_index) % ticks === 0; 
                                                                            })
                                                                        .attr(&quot;fill&quot;, bgHColor);
                                                                                                  
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });
                            
                    Object.defineProperty(slidingBarChart, &quot;__updateAxes__&quot;, {
                                        &#x2F;** __updateAxes__(yScale)
                                            @protected
                                            @chainable
                                            
                                            [Protected method, not supposed to be used by consumers]
                                            
                                            Called by __updateDrawing__() to update the labels of the vertical axe
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                        this method as well as __drawNewData__ and __updateDrawing__ 
                                                        in order to obtain a custom chart.
                                                        
                                            @param yScale:  [Mandatory]
                                                            D3 scale object for Y axis;
                                            @return:    The current chart object, to allow for method chaining.
                                          *&#x2F;
                                value: 	function(yScale){
                                            var axeLabels, m;
                                            if (this.__scaleGlobally__ || this.__dataDim__ === 1){
                                                &#x2F;&#x2F;If data is drawn with a global scaling, or there is only one subcomponent,
                                                &#x2F;&#x2F;then Vertical axe CAN BE DRAWN
                                                m = this.__maxVals__.max();
                                                axeLabels = [m, m&#x2F;2, 0];
                                            }else{
                                                &#x2F;&#x2F;If data is drawn with local scaling for each component
                                                &#x2F;&#x2F;then Vertical axe WOULD HAVE NO MEANING
                                                axeLabels = [];
                                            }
                                            
                                            var labels = this.__axeArea__.selectAll(&quot;text&quot;).data(axeLabels);
                                            var height = parseInt(this.__svgElement__.attr(&quot;height&quot;), 10);
                                            
                                            labels.exit().remove();
                                            labels.enter().append(&quot;text&quot;)                                                        
                                                    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                                    .attr(&quot;font-size&quot;, AXES_LABEL_SIZE)
                                                    .attr(&quot;fill&quot;, &quot;black&quot;);
                                            
                                            labels.text(function(d){return d;})
                                                  .attr(&quot;x&quot;, AXES_LABEL_MARGIN)
                                                  .attr(&quot;y&quot;, function(d){return Math.max(AXES_LABEL_SIZE, height - yScale(d));});
                                            
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });
                            
                    Object.defineProperty(slidingBarChart, &quot;__drawNewData__&quot;, {
                                        &#x2F;** __drawNewData__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                            @protected
                                            [Protected method, not supposed to be used by consumers]
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                        this method and __updateDrawing__ in order to obtain a custom chart.
                                                        
                                            @override:   fixedWidthBarChart.__drawNewData__
                                          *&#x2F;
                                value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                            var that = this;
                                            var height = parseInt(this.__svgElement__.attr(&quot;height&quot;), 10);
                                            var barWidth =  this.getBarWidth(xScale);
                                            var initial_x = (this.__ticks__ - this.__getDatasetLength__()) * that.__dataDim__ * barWidth;

                                            if (dataIndex === 0){
                                                 &#x2F;&#x2F;Executed only once, before drawing the first data component
                                                this.__updateBackground__(); 
                                            }
                                             
                                            &#x2F;&#x2F;Adds value bars 
                                            dataSet.enter().append(&quot;rect&quot;)
                                                .attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                                .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex) * barWidth + 1;})
                                                .attr(&quot;y&quot;, height)	
                                                .attr(&quot;width&quot;, barWidth - 3)
                                                .attr(&quot;height&quot;, 0)	
                                                .attr(&quot;fill&quot;, that.getFillColor(dataIndex))
                                                .attr(&quot;stroke&quot;, that.getStrokeColor(dataIndex))
                                                .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});
                                                
                                            
                                            if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                                                labelsSet.enter().append(&quot;text&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                                    .text(function(d) {return d;})
                                                    .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                                    .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex + 0.5) * barWidth + 1;})
                                                    .attr(&quot;y&quot;, height)
                                                    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                                    .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                                                    .attr(&quot;fill&quot;, that.getLabelColor(dataIndex));	
                                            }else{
                                                labelsSet.remove();
                                            }
                                                
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });
                
                Object.defineProperty(slidingBarChart, &quot;__updateDrawing__&quot;, {
                                        &#x2F;** __updateDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                            @protected
                                            [Protected method, not supposed to be used by consumers]
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                        this method and __drawNewData__ in order to obtain a custom chart.
                                                        
                                            @override:  fixedWidthBarChart.__updateDrawing__
                                          *&#x2F;					
                                value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                            var that = this;
                                            var height = parseInt(this.__svgElement__.attr(&quot;height&quot;), 10);
                                            var barWidth = this.getBarWidth(xScale);
                                            var initial_x = (this.__ticks__ - this.__getDatasetLength__()) * that.__dataDim__ * barWidth;
                                          
                                            if (dataIndex === 0){
                                                 &#x2F;&#x2F;Executed only once, before drawing the first data component
                                                this.__updateBackground__(); 
                                                this.__updateAxes__(yScale);
                                            }
                                                
                                            dataSet.transition().duration(100)&#x2F;&#x2F;.delay(250)
                                                    .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex) * barWidth + 1;})
                                                    .attr(&quot;y&quot;, function(d){return height - yScale(d);})
                                                    .attr(&quot;width&quot;, barWidth - 3)
                                                    .attr(&quot;height&quot;, function(d){return yScale(d);})
                                                    .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});									
                                            if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                                                labelsSet.transition()&#x2F;&#x2F;.delay(250)
                                                        .text(function(d) {return d;})
                                                        .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex + 0.5) * barWidth + 1;})
                                                        .attr(&quot;y&quot;, function(d){return height - yScale(d) + that.getLabelsSize(dataIndex) ;});
                                                        
                                            }else{
                                                labelsSet.remove();
                                            }						
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });	      
                                
            
            &#x2F;** __init__()
                @private
                [Private method, not visible to consumers]
                
                Inits the chart;
                
                @param chart:   [Mandatory]
                                The chart object that needs initialization;
                @param width:   [Mandatory]
                                Chart&#x27;s width;
                @param height:  [Mandatory]
                                Chart&#x27;s height;

                @return: This chart object (see how it&#x27;s called)
                @override:  fixedWidthBarChart.__init__
              *&#x2F;                
            function __init__(chart, width, height){

                &#x2F;&#x2F;Hides all labels by default
                for (var i=0; i&lt;chart.__dataDim__; i++){
                    chart.toggleLabels(i, false);
                }
                  
                var barWidth = (width - AXES_LABEL_WIDTH) &#x2F; (chart.__dataDim__ * chart.__ticks__);
                        &#x2F;&#x2F;var barWidth = slidingBarChart.getBarWidth() ;
                        
                if (barWidth &lt;= 0){
                    throw &quot;Illegal Arguments combination: width too small to draw &#x27;ticks&#x27; values&quot;;
                }
                                        &#x2F;** Width of each bar
                                            @override:  fixedWidthBarChart.__barWidth__
                                          *&#x2F;
                Object.defineProperty(chart, &quot;__barWidth__&quot;, {
                                            value: barWidth,
                                            writable: false,
                                            enumerable: false,
                                            configurable: false
                                        });	  
                Object.defineProperty(chart, &quot;__axeLeft__&quot;, {
                                            value: width - AXES_LABEL_WIDTH,
                                            writable: false,
                                            enumerable: false,
                                            configurable: false
                                        });	                                                                              
                
                &#x2F;&#x2F;Adds the vertical axe box
                var axeArea =   chart.__svgElement__.append(&quot;svg&quot;)
                                     .attr(&quot;type&quot;, &quot;axeArea&quot;)
                                     .attr(&quot;x&quot;, chart.__axeLeft__)
                                     .attr(&quot;y&quot;, 0)
                                     .attr(&quot;width&quot;, AXES_LABEL_WIDTH)
                                     .attr(&quot;height&quot;, height);
                
                axeArea.append(&quot;svg:line&quot;)
                        .attr(&quot;x1&quot;, 0)
                        .attr(&quot;y1&quot;, 0)
                        .attr(&quot;x2&quot;, 0)
                        .attr(&quot;y2&quot;, height)
                        .style(&quot;stroke&quot;, &quot;black&quot;);  
                        
                Object.defineProperty(chart, &quot;__axeArea__&quot;, {
                                            value: axeArea,
                                            writable: false,
                                            enumerable: false,
                                            configurable: false
                                        });	    

                                        
                var totalBarsNumber = chart.__ticks__ * chart.__dataDim__;
                    
                &#x2F;&#x2F;Adds background bars
                chart.__selectBackgroundBars__()
                    .data(new Array(totalBarsNumber))
                    .enter().append(&quot;rect&quot;)
                    .attr(&quot;type&quot;, &quot;back&quot;)
                                                                &#x2F;&#x2F;Data enter form right
                    .property(&quot;d_index&quot;, function(d,i){return Math.floor((totalBarsNumber - i - 1) &#x2F; chart.__dataDim__);}) 
                    .attr(&quot;x&quot;, function(d, i){return i * barWidth;})
                    .attr(&quot;y&quot;, 0)	
                    .attr(&quot;width&quot;, barWidth - 1)
                    .attr(&quot;height&quot;, height)	
                    .attr(&quot;fill&quot;, chart.__backgroundColor__);
                
                return; &#x2F;&#x2F;Private method, no need to return anything
            }


            __init__(slidingBarChart, width, height);
            Object.seal(slidingBarChart);
            
            return slidingBarChart;
        }
        
        &#x2F;** TimeWheelChart(ticks, startTime, wheelRadius, width, height [, dataDim, parent])
            @extends FixedWidthBarChart
            
            Advanced Chart: TimeWheelChart
            Inherits from BasicBarChart redefining the drawing methods.
            
            Data is represented as bars drawn around a time wheel.
            
            It is possible to choose between having only a fixed number of values accepted,
            or if a certain number of the oldest values should be removed when the
            chart is full.
            
            @param {Number} ticks [Mandatory]
                            The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {String} startTime [Mandatory]
                            The reference for the label of the first point.&lt;br&gt;
                            Should be an incrementable value.                                
            @param {Number} width  [Mandatory]
                            The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} height
                            [Mandatory]
                            The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} [dataDim=1] [Optional]
                            The dimension of the data space, i.e. the number of subvalues for each data entry;&lt;br&gt;
                            Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
            @param {Object} [parent=body]
                            [Optional]
                            The DOM element to which the diagram should be appended as a child
            @return {Object}    A new TimeWheelChart object
            @throws
                                -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                    (through setWidth or setHeight)
                                -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                -   Exception, if dataDim exceeds the maximum data dimension
                                -   Exception, if parent is passed but it is not a valid DOM element
          *&#x2F;
        function TimeWheelChart (ticks, startTime, wheelRadius, width, height, dataDim, parent){
           
            var TICK_LINES_LENGTH = 5;
            var BAR_TEXT_MARGIN = 5;
            
            var proto = FixedWidthBarChart(ticks, 0, width, height, dataDim, parent);
            &#x2F;&#x2F;proto_properties = 
            var timeWheelChart = Object.create(proto);
            
                                                            
            if (ChartUtils.validateTimeString(startTime)){
                                                      &#x2F;** Label stating the time corresponding to the first tick
                                                        *&#x2F;
                Object.defineProperty(timeWheelChart, &quot;__startTime__&quot;, {
                                        value: 	startTime,
                                        writable: true,
                                        enumerable: false,
                                        configurable: false
                                    });
            }
                                                  &#x2F;** Size in points of the static labels showing time references on the wheel
                                                    *&#x2F;
            Object.defineProperty(timeWheelChart, &quot;__timeWheelLabelsSize__&quot;, {
                                    value: 	timeWheelChart.getLabelsSize(0),  &#x2F;&#x2F;Use the default value for value labels
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });
                                
            Object.defineProperty(timeWheelChart, &quot;setTimeWheelLabelsSize&quot;, {
                                            &#x2F;** setTimeWheelLabelsSize(size)
                                            
                                                Sets the size of the labels used for the wheel
                                                
                                                @chainable
                                                @param size:    [Mandatory]
                                                                The new size for the labels (must be an integer gt zero);
                                                @return:    This chart object, to allow for method chaining;
                                                @throws    
                                                            - Illegal Argument Exception, if the argument is not valid (see above).
                                              *&#x2F;
                                    value: 	function(size){
                                                size = parseInt(size, 10);
                                                if (isNaN(size) || size &lt;= 0){
                                                    throw &quot;Illegal Argument: size&quot;;
                                                }
                                                if (this.hasOwnProperty(&quot;__timeWheelLabelsSize__&quot;)){
                                                    this.__timeWheelLabelsSize__ = size;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setTimeWheelLabelsSize){
                                                        proto.setTimeWheelLabelsSize(size);
                                                    }
                                                } 
                                                &#x2F;&#x2F;Now must update the static part of the wheel chart
                                                this.__updateWheelDrawing__();                                                    
                                                return this;    &#x2F;&#x2F;Method chaining support;
                                            },
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });                                     
                                                    &#x2F;** Color used for the static part of the wheel
                                                      *&#x2F;
            Object.defineProperty(timeWheelChart, &quot;__timeWheelForeColor__&quot;, {
                                    value: 	&quot;lightgrey&quot;,  &#x2F;&#x2F;Defaults to lightgrey
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });                  

            Object.defineProperty(timeWheelChart, &quot;setTimeWheelForeColor&quot;, {
                                            &#x2F;** setTimeWheelForeColor(color)
                                            
                                                Sets the color used for the static part of the wheel&#x27;s drawing, 
                                                i.e. for labels and lines representing time ticks 
                                                of the time wheel
                                                
                                                @chainable
                                                @param color:   [Mandatory]
                                                                The new forecolor for the wheel;
                                                @return:    This chart object, to allow for method chaining;
                                                @throws    
                                                            - Illegal Argument Exception, if color isn&#x27;t passed or is null.
                                              *&#x2F;
                                    value: 	function(color){
                                                if (color === undefined  || color === null){
                                                    throw &quot;Illegal Argument: color&quot;;
                                                }
                                                if (this.hasOwnProperty(&quot;__timeWheelForeColor__&quot;)){
                                                    this.__timeWheelForeColor__ = color;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setTimeWheelForeColor){
                                                        proto.setTimeWheelForeColor(color);
                                                    }
                                                }  
                                                &#x2F;&#x2F;Now must update the static part of the wheel chart
                                                this.__updateWheelDrawing__();
                                                return this;    &#x2F;&#x2F;Method chaining support;                                                    
                                            },
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });    
                                
            Object.defineProperty(timeWheelChart, &quot;__timeLabelsVisible__&quot;, {
                                            &#x2F;** __timeLabelsVisible__()
                                                @protected
                                                [Protected method, not supposed to be used by consumers]
                                                Checks whether or not the labels showing time references on the wheel
                                                should be drawn
                                                
                                              *&#x2F;
                                    value: 	function(){
                                                return (this.__startTime__ !== undefined);
                                            },
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                           
            Object.defineProperty(timeWheelChart, &quot;setBarWidth&quot;, {
                                            &#x2F;** setBarWidth(barWidth)
                                            
                                                Sets the width of this chart&#x27;s bars
                                                
                                                @chainable
                                                @param barWidth: [Mandatory]
                                                                 The new bar width to be set;
                                                                 Can be a positive number or its base 10 string representation.
                                                @return:    This object, to allow for method chaining;
                                                @throws     Illegal Argument Exception, if the argument isn&#x27;t valid (see above).
                                                @override:  basicBarChartSharedPrototype.setBarWidth
                                              *&#x2F;
                                    value: 	function(barWidth){
                                                barWidth = parseInt(barWidth, 10);
                                                if (isNaN(barWidth) || barWidth &lt;= 0){
                                                    throw &quot;Illegal Argument: barWidth&quot;;
                                                }
                                                this.__barWidth__ = barWidth;
                                                return this;		&#x2F;&#x2F;Method chaining oriented
                                            },
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	   
                                
            Object.defineProperty(timeWheelChart, &quot;setWheelCenter&quot;, {
                            &#x2F;** setWheelCenter(cx, cy)
                            
                                Sets the position of the center of the wheel.
                                If it is valid and it is different from the current position,
                                the drawing is moved to the new position
                                
                                @chainable
                                @param cx, cy:  [Mandatory]
                                                x and y coordinates of the new center;
                                @return:    This chart object, to allow for method chaining;
                                @throws     
                                            - Illegal Argument Exception, if cx or cy aren&#x27;t valid. 
                             *&#x2F;
                    value: 	function(cx, cy){
                                cx = parseInt(cx, 10);
                                cy = parseInt(cy, 10);
                                if (!isNaN(cx) &amp;&amp; !isNaN(cy)){
                                    this.__moveWheelCenter__(cx, cy);
                                }else{
                                    throw &quot;Illegal Arguments: cx, cy&quot;;
                                }                                    
                                    
                                return this;	&#x2F;&#x2F;Method chaining oriented
                            },
                    writable: false,
                    enumerable: true,
                    configurable:false
                });

            Object.defineProperty(timeWheelChart, &quot;__moveWheelCenter__&quot;, {
                            &#x2F;** __moveWheelCenter__(cx, cy)
                                @protected
                                [Protected method, not supposed to be used by consumers]
                                
                                When the center of the time wheel is moved,
                                then takes care of all the updates needed for the chart
                                
                                @param cx, cy:  [Mandatory]
                                                The new center coordinates;
                                @return:    Nothing.
                              *&#x2F;                                
                    value: 	function(cx, cy){
                                if (!Object.isNumber(cx) || !Object.isNumber(cy) ||    &#x2F;&#x2F;Extra precaution, since it&#x27;s not really a &quot;private&quot; method
                                    (this.__cx__ === cx &amp;&amp; this.__cy__ === cy)){ &#x2F;&#x2F;If values doesn&#x27;t change, no reason to hassle
                                      
                                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                }
                                &#x2F;&#x2F;else

                                this.__wheel__.transition()&#x2F;&#x2F;.delay(250)
                                               .attr(&quot;x&quot;, cx - this.__r__).attr(&quot;y&quot;, cy - this.__r__);
                                this.__cx__ = cx;
                                this.__cy__ = cy;
                                
                                &#x2F;&#x2F;Now updates all the bars
                                
                                var newDataLength = this.__getDatasetLength__() * this.__dataDim__;
                                
                                &#x2F;&#x2F;The max is recomputed every time to retain the ability to switch on the fly between scaling locally and globally
                                var max_val;
                                
                                if (this.__scaleGlobally__){
                                    max_val = ChartUtils.fillArray(this.__maxVals__.max(), this.__dataDim__);
                                }else{
                                    max_val = this.__maxVals__;    &#x2F;&#x2F;Values aren&#x27;t going to be modified, so we can just copy the reference
                                }
                                
                                for (var j = 0; j &lt; this.__dataDim__; j++){  

                                    var dataSet = this.__selectData__(this.__data__, j);           
                                    var labelsSet = this.__selectLabels__(this.__data__, j);

                                    &#x2F;&#x2F;Computes the new X and Y scale
                                    this.__xScale__.domain([0, newDataLength]);        
                                    this.__yScale__[j].domain([0, 	max_val[j]]);
                                    this.__updateDrawing__(dataSet, labelsSet, j, this.__xScale__, this.__yScale__[j]);
                                }
                                
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this	
                            },  
                    writable: false,
                    enumerable: false,
                    configurable:false
                });   

            Object.defineProperty(timeWheelChart, &quot;__drawNewData__&quot;, {
                            &#x2F;** __drawNewData__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                @protected
                                [Protected method, not supposed to be used by consumers]
                                                                               
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                            this method and __updateDrawing__ in order to obtain a custom chart.
                                            
                                @override:   fixedWidthBarChart.__drawNewData__
                              *&#x2F;                
                    value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                
                                var that = this;
                                &#x2F;&#x2F;var height = parseInt(this.__svgElement__.attr(&quot;height&quot;), 10);
                                var initial_x = that.__cx__ + dataIndex * (that.__barWidth__ + 1), 
                                    initial_y = that.__cy__ - that.__r__ ;
                                
                                dataSet.enter().append(&quot;rect&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                    .attr(&quot;x&quot;, initial_x)
                                    .attr(&quot;y&quot;, initial_y)
                                    .attr(&quot;width&quot;, that.__barWidth__)
                                    .attr(&quot;height&quot;, 0)
                                    .attr(&quot;transform&quot;, function(d, i){ return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + 
                                                                              &quot; &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot;;})                                        
                                    .attr(&quot;fill&quot;, that.getFillColor(dataIndex))
                                    .attr(&quot;stroke&quot;, that.getStrokeColor(dataIndex))
                                    .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; that.__barHeight__);});
                                    
                                
                                if (that.areLabelsVisible(dataIndex) ){
                                    
                                    
                                    initial_x += that.getBarWidth();
                                    initial_y -= BAR_TEXT_MARGIN;
                                    labelsSet.enter()
                                        .append(&quot;text&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                                &#x2F;&#x2F;The text direction makes the string printed right to left, 
                                                &#x2F;&#x2F;so it must reverse the string to represent
                                        .text(function(d) {return d;})      &#x2F;&#x2F;(&quot;&quot; + d).split(&quot;&quot;).reverse().join(&quot;&quot;) ;}) 
                                        .attr(&quot;text-anchor&quot;, &quot;left&quot;)
                                        .attr(&quot;x&quot;, initial_x)
                                        .attr(&quot;y&quot;, function(){return initial_y;})  
                                        .attr(&quot;transform&quot;,  function(d, i){  
                                                                return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + 
                                                                        &quot; &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot; +
                                                                        &quot;rotate(-90 &quot; + initial_x + &quot;, &quot; + initial_y +&quot;)&quot;;
                                                            })
                                        .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                        .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                                        .attr(&quot;fill&quot;, that.getLabelColor(dataIndex));
                                        &#x2F;&#x2F;.attr(&quot;class&quot;, &quot;wheelText&quot;)
                                }else{
                                    labelsSet.remove();
                                }
                                    
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false
                });
                    
            Object.defineProperty(timeWheelChart, &quot;__updateDrawing__&quot;, {
                            &#x2F;** __updateDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                @protected
                                [Protected method, not supposed to be used by consumers]
                                
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                            this method and __drawNewData__ in order to obtain a custom chart.
                                            
                                @override:  fixedWidthBarChart.__updateDrawing__
                              *&#x2F;					
                    value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){           
                    
                                var that = this; 
                                var initial_x = that.__cx__ + dataIndex * (that.__barWidth__ + 1);                              
                                
                                dataSet.transition()	
                                        .attr(&quot;x&quot;, initial_x)
                                        .attr(&quot;y&quot;, function(d){return that.__cy__ - that.__r__ - yScale(d);})
                                        .attr(&quot;height&quot;, function(d){return yScale(d);})
                                        .attr(&quot;transform&quot;, function(d, i){ return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + &quot;, &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot;;})                                       
                                        .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; that.__barHeight__);});									

                                if (that.areLabelsVisible(dataIndex)){
                                    initial_x += that.getBarWidth();
                                    
                                    labelsSet.transition()
                                            .attr(&quot;y&quot;, function(d){return   that.__cy__ - that.__r__ - yScale(d) - BAR_TEXT_MARGIN; })
                                            .attr(&quot;x&quot;, initial_x)
                                            .attr(&quot;transform&quot;,  function(d, i){  
                                                                    return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + 
                                                                            &quot; &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot; +
                                                                            &quot;rotate(-90 &quot; + initial_x + &quot;, &quot; + (that.__cy__ - that.__r__ - yScale(d) - BAR_TEXT_MARGIN) +&quot;)&quot;;
                                                                });                                                
                                }else{
                                    labelsSet.remove();
                                }					
                                
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false
                });		
                
        Object.defineProperty(timeWheelChart, &quot;__onClearData__&quot;, {            
                            &#x2F;** __onClearData__(n)
                                @protected
                                [Protected method, not supposed to be used by consumers]
                                
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    Inherited objects MIGHT NEED to override this function
                                
                                @override: basicBarChartSharedPrototype.__onClearData__
                              *&#x2F;
                    value:	function(n){
                                this.__timeLabels__.map(function(label){label.text(ChartUtils.addIntToTimeString(label.text(), n));});
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false
                });	
                
        Object.defineProperty(timeWheelChart, &quot;__updateWheelDrawing__&quot;, {            
                            &#x2F;** __updateWheelDrawing__()
                                @protected
                                [Protected method, not supposed to be used by consumers]
                                
                                Updates the drawing of the static elements of the wheel
                                
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    Inherited objects MIGHT NEED to override this function

                                @return:    Nothing.
                              *&#x2F;
                    value:	function(){
                                var that = this;
                                var tmpLabel;
                                &#x2F;&#x2F;Update labels text
                                this.__timeLabels__.map(function(label){
                                                            label.attr(&quot;fill&quot;, that.__timeWheelForeColor__)
                                                                 .attr(&quot;font-size&quot;, that.__timeWheelLabelsSize__);
                                                        });
                                &#x2F;&#x2F;Now updates their position
                                for (var i=0; i &lt; this.__timeLabels__.length; i++){
                                    tmpLabel = this.__timeLabels__[i];
                                    switch(tmpLabel.property(&quot;clock_time&quot;)){
                                        case &quot;12&quot;:
                                            tmpLabel
                                                   .attr(&quot;x&quot;, this.__r__)
                                                   .attr(&quot;y&quot;, TICK_LINES_LENGTH + this.__timeWheelLabelsSize__);
                                            break;
                                        case &quot;3&quot;:
                                            tmpLabel
                                                .attr(&quot;x&quot;, 2 * this.__r__ - TICK_LINES_LENGTH - this.__timeLabels__[i].node().getComputedTextLength() )
                                                .attr(&quot;y&quot;, this.__r__ + this.__timeWheelLabelsSize__ &#x2F; 2);                                             
                                            break;
                                        case &quot;6&quot;:
                                            tmpLabel
                                                .attr(&quot;x&quot;, this.__r__)
                                                .attr(&quot;y&quot;, 2 * this.__r__ - TICK_LINES_LENGTH);
                                            break;
                                        case &quot;9&quot;:
                                            tmpLabel
                                                .attr(&quot;x&quot;, TICK_LINES_LENGTH )
                                                .attr(&quot;y&quot;, this.__r__ + this.__timeWheelLabelsSize__ &#x2F; 2);                                         
                                            break;                                                
                                    }
                                }                                 

                                
                                &#x2F;&#x2F;Updates wheel tick lines                        
                                this.__wheel__.selectAll(&quot;line&quot;)
                                                    .attr(&quot;stroke&quot;, this.__timeWheelForeColor__);
                                &#x2F;&#x2F;Updates wheel tick lines                        
                                this.__wheel__.selectAll(&quot;circle&quot;)
                                                    .attr(&quot;stroke&quot;, this.__timeWheelForeColor__);                                                        
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false
                });                    
            Object.defineProperty(timeWheelChart, &quot;destroy&quot;, {
                            &#x2F;** destroy()
                                
                                Object&#x27;s destructor: helps garbage collector freeing memory, and removes chart DOM elements.
                                
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;: calling destroy on an object will force any further reference 
                                         to its attributes &#x2F; methods to throw exceptions.
                                
                                NOTE:   This function should be override by any class inheriting from this chart.
                                        In order to properly work, any overriding destroyer should:
                                        - Free any array specific to the object on which is called;
                                        - Remove any event listener on chart objects;
                                        - Call super object&#x27;s destroy method.
                                @return:    null, to state that the object has been destroyed.
                              *&#x2F;                        
                    value: 	function(){
                                        &#x2F;&#x2F;Deletes all the elements from object&#x27;s arrays
                                        if (this.__timeLabels__){
                                            this.__timeLabels__.length = 0;
                                        }
                                        
                                        &#x2F;&#x2F;Removes DOM objects
                                        this.__wheel__.remove();
                                        &#x2F;&#x2F;Looks for object&#x27;s prototype destructor
                                        var proto = this.prototype ? this.prototype : this.__proto__;
                                        if (proto &amp;&amp; proto.destroy){
                                            proto.destroy();
                                        }
                                        return null;
                                    },
                    writable: false,
                    enumerable: false,
                    configurable: false
                });		
            
            
            &#x2F;** __init__()
                @private
                [Private method, not visible to consumers]
                
                Inits the chart;
                
                @param chart:   [Mandatory]
                                The chart that need initialization;
                @param width:   [Mandatory]
                                Chart&#x27;s width;
                @param height:  [Mandatory]
                                Chart&#x27;s height;
                @param wheelRadius:  [Mandatory]   
                                     Wheel inner radius;
                @return: This chart object (see how it&#x27;s called)
                @override:  fixedWidthBarChart.3
              *&#x2F;      
            function __init__(chart, width, height, wheelRadius){
                &#x2F;&#x2F;Computes drawing related object contants
                                            &#x2F;** Chart&#x27;s bars&#x27; width, in pixel
                                                Defaults to 8, can be changed at runtime

                                                @override:  fixedWidthBarChart.__barWidth__  
                                              *&#x2F;
                Object.defineProperty(chart, &quot;__barWidth__&quot;, {
                                            value: 8,
                                            writable: false,
                                            enumerable: false,
                                            configurable: false
                                        });	
                                            &#x2F;** X coordinate of the center of the wheel
                                                Defaults to the horizontal center of the chart
                                                Can be changed at runtime
                                              *&#x2F;
                Object.defineProperty(chart, &quot;__cx__&quot;, {
                                            value: width &#x2F; 2, &#x2F;&#x2F;Aligns left by default
                                            writable: true,                     &#x2F;&#x2F;to allow enough space for the legend
                                            enumerable: false,
                                            configurable:false
                                        });
                                        
                                            &#x2F;** Y coordinate of the center of the wheel
                                                Defaults to the vertical center of the chart
                                                Can be changed at runtime
                                              *&#x2F;
                Object.defineProperty(chart, &quot;__cy__&quot;, {
                                            value: height &#x2F; 2,
                                            writable: true,
                                            enumerable: false,
                                            configurable:false
                                        });                                                               
                wheelRadius = parseInt(wheelRadius, 10);
                
                if (!isNaN(wheelRadius) &amp;&amp; wheelRadius &gt; 0){
                    &#x2F;&#x2F;If a value for the wheel radius is set, then computes the height accordingly...
                                                &#x2F;** Radius of the wheel
                                                    CAN NOT be changed at runtime
                                                  *&#x2F;
                    Object.defineProperty(chart, &quot;__r__&quot;, {
                                                value: wheelRadius,
                                                writable: false,
                                                enumerable: false,
                                                configurable:false
                                            }); 
                                                &#x2F;** Maximum height for each bar
                                                    CAN NOT be changed at runtime
                                                  *&#x2F;                                                                    
                    Object.defineProperty(chart, &quot;__barHeight__&quot;, {
                                                value: ((Math.min(width, height) - 2 * wheelRadius) &#x2F; 2) * 0.75,
                                                writable: false,
                                                enumerable: false,
                                                configurable:false
                                            });                                                                     
                    
                }else{
                    &#x2F;&#x2F;...Otherwise makes the radius 3&#x2F;4 of the available height;
                                                &#x2F;** Maximum height for each bar
                                                    CAN NOT be changed at runtime
                                                  *&#x2F;                                            
                    Object.defineProperty(chart, &quot;__barHeight__&quot;, {
                                                value: Math.min(width, height) &#x2F; 4,
                                                writable: false,
                                                enumerable: false,
                                                configurable:false
                                            });     
                                                &#x2F;** Radius of the wheel
                                                    CAN NOT be changed at runtime
                                                  *&#x2F;                                                                    
                    Object.defineProperty(chart, &quot;__r__&quot;, {
                                                value: this.__barHeight__ * 0.75,
                                                writable: false,
                                                enumerable: false,
                                                configurable:false
                                            });  
                }
                
                &#x2F;&#x2F;Modify the range for each of the data components
                for (var i=0; i &lt; chart.__dataDim__; i++){
                    chart.__yScale__[i].range([0, chart.__barHeight__]);
                }
                
                &#x2F;&#x2F;Computes the angle between two consecutive ticks
                Object.defineProperty(chart, &quot;__tickStep__&quot;, {
                                            value: Math.PI &#x2F; (chart.__ticks__), &#x2F;&#x2F; == 2 * Math.PI &#x2F; (chart.__ticks__ * 2)
                                            writable: false,
                                            enumerable: false,
                                            configurable:false
                                        });   
                
                var     initial_x = chart.__cx__ - chart.__r__, 
                        initial_y = chart.__cy__ - chart.__r__;
                                            &#x2F;** The actual wheel graphic object
                                              *&#x2F;
                Object.defineProperty(chart, &quot;__wheel__&quot;, {
                                            value: chart.__svgElement__.append(&quot;svg&quot;)
                                                                  .attr(&quot;id&quot;, &quot;timeWheel&quot;)
                                                                  .attr(&quot;x&quot;, initial_x)
                                                                  .attr(&quot;y&quot;, initial_y),
                                            writable: false,
                                            enumerable: false,
                                            configurable:false
                                        });  
                                        
                &#x2F;&#x2F;Appends an inner circle to represent the wheel
                chart.__wheel__.append(&quot;circle&quot;)
                               .attr(&quot;id&quot;, &quot;timeWheel&quot;)
                               .attr(&quot;cx&quot;, chart.__r__)
                               .attr(&quot;cy&quot;, chart.__r__)
                               .attr(&quot;stroke&quot;, chart.__timeWheelForeColor__)
                               .attr(&quot;stroke-dasharray&quot;, &quot;2, 4&quot;)
                               .attr(&quot;fill&quot;, &quot;none&quot;)
                               .attr(&quot;r&quot;, chart.__r__)
                               .attr(&quot;stroke-width&quot;, 1);
                               
                
                chart.__wheel__.selectAll(&quot;line&quot;).data(d3.range(chart.__ticks__))
                                .enter()
                                .append(&quot;svg:line&quot;)
                                .attr(&quot;x1&quot;, chart.__r__)
                                .attr(&quot;y1&quot;, 0)
                                .attr(&quot;x2&quot;, chart.__r__)
                                .attr(&quot;y2&quot;, TICK_LINES_LENGTH)
                                .attr(&quot;stroke&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;transform&quot;,      function(d, i){
                                                            return  &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * chart.__tickStep__)) +
                                                                    &quot; &quot; + chart.__r__ + &quot;, &quot; + chart.__r__ +&quot;)&quot;;
                                                        });
                                                        
                if (chart.__timeLabelsVisible__()){
                    var timeLabels = [];
                    timeLabels.push(
                            chart.__wheel__
                                .append(&quot;text&quot;)
                                .property(&quot;clock_time&quot;, &quot;12&quot;)
                                .text(chart.__startTime__)
                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                .attr(&quot;font-size&quot;, chart.__timeWheelLabelsSize__)   
                                .attr(&quot;fill&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                .attr(&quot;x&quot;, chart.__r__)
                                .attr(&quot;y&quot;, TICK_LINES_LENGTH + chart.__timeWheelLabelsSize__)
                            );
                            
                    &#x2F;&#x2F;For the &quot;3 o&#x27;clock&quot; label we must take particular care because it needs to be aligned &quot;right&quot;
                    &#x2F;&#x2F;So we need to move it after creation, once we know its size
                    var tmpLabel = chart.__wheel__
                                .append(&quot;text&quot;)
                                .property(&quot;clock_time&quot;, &quot;3&quot;)
                                .text(ChartUtils.addIntToTimeString(chart.__startTime__, Math.floor(chart.__ticks__&#x2F;4)))
                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                .attr(&quot;font-size&quot;, chart.__timeWheelLabelsSize__)   
                                .attr(&quot;fill&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;text-anchor&quot;, &quot;left&quot;);
                    timeLabels.push(tmpLabel);
                            
                            tmpLabel.attr(&quot;x&quot;, 2 * chart.__r__ - TICK_LINES_LENGTH - tmpLabel.node().getComputedTextLength() )
                                    .attr(&quot;y&quot;, chart.__r__ + chart.__timeWheelLabelsSize__ &#x2F; 2);                                                       

                    timeLabels.push(
                            chart.__wheel__
                                .append(&quot;text&quot;)
                                .property(&quot;clock_time&quot;, &quot;6&quot;)
                                .text(ChartUtils.addIntToTimeString(chart.__startTime__, chart.__ticks__&#x2F;2))
                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                .attr(&quot;font-size&quot;, chart.__timeWheelLabelsSize__)   
                                .attr(&quot;fill&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                .attr(&quot;x&quot;, chart.__r__)
                                .attr(&quot;y&quot;, 2 * chart.__r__ - TICK_LINES_LENGTH)                                                       
                            );  
                    timeLabels.push(
                            chart.__wheel__
                                .append(&quot;text&quot;)
                                .property(&quot;clock_time&quot;, &quot;9&quot;)
                                .text(ChartUtils.addIntToTimeString(chart.__startTime__, Math.floor(3 * chart.__ticks__ &#x2F; 4)))
                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                .attr(&quot;font-size&quot;, chart.__timeWheelLabelsSize__)   
                                .attr(&quot;fill&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;text-anchor&quot;, &quot;left&quot;)
                                .attr(&quot;x&quot;, TICK_LINES_LENGTH )
                                .attr(&quot;y&quot;, chart.__r__ + chart.__timeWheelLabelsSize__ &#x2F; 2)                                                       
                            ); 

                                                &#x2F;** Set of labels for wheel&#x27;s time references
                                                  *&#x2F;
                    Object.defineProperty(chart, &quot;__timeLabels__&quot;, {
                                            value: timeLabels,
                                            writable: false,
                                            enumerable: false,
                                            configurable:false
                                        });  
                }
                return ;
            }

            
            __init__(timeWheelChart, width, height, wheelRadius);
            Object.seal(timeWheelChart);

            return timeWheelChart;
        }		
		
		var modulePrototype = {
            &#x2F;** 
                @method BasicBarChart
                @for DynamicChart
                @chainable

                @param {Number} width [Mandatory]
                                The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} height [Mandatory]
                                The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                                Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
                @param {Object} [parent=body] [Optional]
                                The DOM element to which the diagram should be appended as a child                                                              
                @return {Object} A (wrapped-in-a-proxy version of a) BasicBarChart object
                @throws
                                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                    -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                                        (through setWidth or setHeight)
                                    -   Illegal Argument exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension
                                    -   Exception, if parent is passed but it is not a valid DOM element                             
              *&#x2F;
            BasicBarChart: function(){
                               return BasicBarChart.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy(true);
                           },
            &#x2F;** 
                @method FixedWidthBarChart
                @for DynamicChart
                @chainable
                
                @param {Number} ticks [Mandatory]
                                The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} startingPoint [Mandatory, but not used at the moment: inserted for future back-compatibility]&lt;br&gt;
                                The reference for the label of the first point.&lt;br&gt;
                                Should be an incrementable value;
                @param {Number} width [Mandatory]
                                The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} height [Mandatory]
                                The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                                Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
                @param {Object} [parent=body] [Optional]
                                The DOM element to which the diagram should be appended as a child
                @return {Object} A properly initialized (wrapped-in-a-proxy version of a) FixedWidthBarChart object
                @throws
                                    -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                    -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                        (through setWidth or setHeight)
                                    -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension
                                    -   Exception, if parent is passed but it is not a valid DOM element                
              *&#x2F;                           
            FixedWidthBarChart: function(){
                               return FixedWidthBarChart.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy(true);
                           },
            &#x2F;** 
                @method SlidingBarChart
                @for DynamicChart
                @chainable
                
                @param {Number} ticks [Mandatory]
                                The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} width [Mandatory]
                                The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} height [Mandatory]
                                The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues for each data entry &lt;br&gt;
                                Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
                @param {Object} [parent=body] The DOM element to which the diagram should be appended as a child
                @return {Object} A properly initialized (wrapped-in-a-proxy version of a) SlidingBarChart object
                @throws
                                    -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                    -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                        (through setWidth or setHeight)
                                    -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension
                                    -   Exception, if the ratio between chart&#x27;s width and number of ticks is such
                                        that the computed bar height is smaller than 1 pixel
                                    -   Exception, if parent is passed but it is not a valid DOM element                
              *&#x2F;                              
            SlidingBarChart: function(){
                               return SlidingBarChart.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy(true);
                           },
            &#x2F;** 
                @method TimeWheelChart
                @for DynamicChart
                @chainable
                
                @param {Number} ticks [Mandatory]
                                The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)
                                Can be any value that is or can be converted to a positive integer.
                @param {String} startTime [Mandatory]
                                The reference for the label of the first point.&lt;br&gt;
                                Should be an incrementable value.                                
                @param {Number} width [Mandatory]
                                The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} height [Mandatory]
                                The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                                Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
                @param {Object} [parent=body] [Optional]
                                The DOM element to which the diagram should be appended as a child&lt;br&gt;
                @return {Object} A properly initialized (wrapped-in-a-proxy version of a) TimeWheelChart object
                @throws
                                    -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                    -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                        (through setWidth or setHeight)
                                    -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension
                                    -   Exception, if parent is passed but it is not a valid DOM element                
              *&#x2F;                            
            TimeWheelChart: function(){
                               return TimeWheelChart.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy(true);
                           },                           
        };
		
		Object.freeze(modulePrototype);
		
		return Object.create(modulePrototype);
	})();

	Object.freeze(DynamicChart);
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
