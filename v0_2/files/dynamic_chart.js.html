<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>dynamic_chart.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Array.html">Array</a></li>
            
                <li><a href="..&#x2F;classes/BasicBarChart.html">BasicBarChart</a></li>
            
                <li><a href="..&#x2F;classes/ChartUtils.html">ChartUtils</a></li>
            
                <li><a href="..&#x2F;classes/DynamicChart.html">DynamicChart</a></li>
            
                <li><a href="..&#x2F;classes/FixedWidthBarChart.html">FixedWidthBarChart</a></li>
            
                <li><a href="..&#x2F;classes/Legend.html">Legend</a></li>
            
                <li><a href="..&#x2F;classes/Object.html">Object</a></li>
            
                <li><a href="..&#x2F;classes/SlidingBarChart.html">SlidingBarChart</a></li>
            
                <li><a href="..&#x2F;classes/TimeWheelChart.html">TimeWheelChart</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/ChartUtils.html">ChartUtils</a></li>
            
                <li><a href="..&#x2F;modules/DynamicChart.html">DynamicChart</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: dynamic_chart.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F;require d3.v2.js
&#x2F;&#x2F;require chart_utils.js

if (!window.DynamicChart){
	&#x2F;**
		Module DynamicChart
        @version 0.2
This module requires:
&lt;ol&gt;
    &lt;li&gt;{{#crossLinkModule &quot;chart_utils.js&quot;}}{{&#x2F;crossLinkModule}}&lt;&#x2F;li&gt;
    &lt;li&gt;{{#crossLink &quot;http:&#x2F;&#x2F;d3js.org&#x2F;d3.v2.js&quot;}}{{&#x2F;crossLink}}&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;br&gt;
Exposes methods for creating different types of dynamic charts:
&lt;ul&gt;
    &lt;li&gt;BasicBarChart&lt;&#x2F;li&gt;
    &lt;li&gt;FixedWidthBarChart&lt;&#x2F;li&gt;
    &lt;li&gt;SlidingBarChart&lt;&#x2F;li&gt;
    &lt;li&gt;TimeWheelChart&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;        
        @module DynamicChart
	*&#x2F;
	var DynamicChart = (function (){
		&quot;use strict&quot;;
		
        
        &#x2F;&#x2F;      -----       CONSTANTS       --------        
        &#x2F;** 
            Maximum dimension of the input space, i.e. max number of subvalues for each single point
            @property MAX_SPACE_DIMENSION
            @for DynamicChart
            @type {Number}
            @final
            @private     
          *&#x2F;             
        var MAX_SPACE_DIMENSION = 10;
      
          
        &#x2F;** 
            Default fill colors bor graphic elements;
            @property FILL_COLORS
            @for DynamicChart
            @type {Array}
            @final
            @private     
          *&#x2F;    
        var FILL_COLORS = [&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;orange&quot;, &quot;purple&quot;, &quot;cyan&quot;, &quot;magenta&quot;, &quot;yellow&quot;, &quot;limegreen&quot;, &quot;brown&quot;];
        &#x2F;** 
            Default size for chart&#x27;s labels (in points);
            @property DEFAULT_LABEL_SIZE
            @for DynamicChart
            @type {Number}
            @final
            @private     
          *&#x2F;
        var DEFAULT_LABEL_SIZE = 12;
        &#x2F;** 
            Default size for chart&#x27;s title text (in points);
            @property DEFAULT_TITLE_SIZE
            @for DynamicChart
            @type {Number}
            @final
            @private     
          *&#x2F;        
        var DEFAULT_TITLE_SIZE = 22;
        &#x2F;** 
            Default axes margin (in pixels);
            @property DEFAULT_AXE_MARGIN
            @for DynamicChart
            @type {Number}
            @final
            @private     
          *&#x2F;        
        var DEFAULT_AXE_MARGIN = 25; 

            &#x2F;** 
                Default background color for the main chart area.
                @property DEFAULT_INNER_BACKGROUND
                @for DynamicChart
                @type {String|Object}
                @default = &quot;white&quot;
                @final
                @private     
              *&#x2F;   
        var DEFAULT_INNER_BACKGROUND = &quot;white&quot;;
            &#x2F;** 
                Default background color for the outer chart area.
                @property DEFAULT_OUTER_BACKGROUND
                @for DynamicChart
                @type {String|Object}
                @default = &quot;white&quot;
                @final
                @private     
              *&#x2F;   
        var DEFAULT_OUTER_BACKGROUND = &quot;white&quot;;  
           
           &#x2F;** 
                Default border for the main chart area.
                @property DEFAULT_INNER_BORDER
                @for DynamicChart
                @type {Object}
                @default = none
                @final
                @private     
              *&#x2F;   
        var DEFAULT_INNER_BORDER = {fill: &quot;none&quot;, width:0, dash: null};
            &#x2F;** 
                Default border for the outer chart area.
                @property DEFAULT_OUTER_BORDER
                @for DynamicChart
                @type {Object}
                @default = none
                @final
                @private     
              *&#x2F;   
        var DEFAULT_OUTER_BORDER = {fill: &quot;none&quot;, width:0, dash: null};        
            
            &#x2F;** 
                Default size of axes&#x27; labels lext
                @property DEFAULT_AXES_LABEL_SIZE
                @for DynamicChart
                @type {Number}
                @default = 14
                @final
                @private     
              *&#x2F;             
        var DEFAULT_AXES_LABEL_SIZE = 12;            
           
        &#x2F;** 
            Length of notch lines, in pixels;
            @property NOTCH_LINE_LENGTH
            @for DynamicChart
            @type {Number}
            @default = 5
            @final
            @private     
          *&#x2F;      
        var NOTCH_LINE_LENGTH = 5;
     
        &#x2F;** 
            Default line width for axes and notches;
            @property DEFAULT_AXES_LINE_WIDTH
            @for DynamicChart
            @type {Number}
            @default = 1
            @final
            @private     
          *&#x2F;      
        var DEFAULT_AXES_LINE_WIDTH = 1;
        
        &#x2F;** 
            Default line width for axes and notches;
            @property DEFAULT_AXES_COLOR
            @for DynamicChart
            @type {Number}
            @default = &quot;black&quot;
            @final
            @private     
          *&#x2F;      
        var DEFAULT_AXES_COLOR = &quot;black&quot;;        
        
        &#x2F;** 
            Default width for legend&#x27;s item boxes (in pixel);
            @property LEGEND_ITEM_WIDTH
            @for DynamicChart
            @type {Number}
            @final
            @private     
          *&#x2F;               
        var LEGEND_ITEM_WIDTH = 25,
            &#x2F;** 
                Default height for legend&#x27;s item boxes (in pixel);
                @property LEGEND_ITEM_HEIGHT
                @for DynamicChart
                @type {Number}
                @final
                @private     
              *&#x2F;          
            LEGEND_ITEM_HEIGHT = 15,
            &#x2F;** 
                Default margin for legends (in pixel);
                @property LEGEND_MARGIN
                @for DynamicChart
                @type {Number}
                @final
                @private     
              *&#x2F;              
            LEGEND_MARGIN = 5,
            &#x2F;** 
                Default left margin for legend&#x27;s items (in pixel);
                @property LEGEND_ITEM_LEFT
                @for DynamicChart
                @type {Number}
                @final
                @private     
              *&#x2F;               
            LEGEND_ITEM_LEFT = LEGEND_MARGIN,
            &#x2F;** 
                Default font size for labels attached to legend&#x27;s items (in pixel);
                @property LEGEND_ITEM_FONT_SIZE
                @for DynamicChart
                @type {Number}
                @final
                @private     
              *&#x2F;              
            LEGEND_ITEM_FONT_SIZE = 11;      
        &#x2F;&#x2F;      -----       &#x2F;CONSTANTS       --------
        
        
        &#x2F;&#x2F;      -----       LEGEND       --------
        
        var legendPrototype = {
                            &#x2F;** setPosition(left, top)
                                Sets the position of the legend in the page. Position is assumed to be absolute.
                                
                                @method setPosition
                                @for Legend
                                @chainable
                                @param {Number} left [Mandatory]
                                                      The horizontal position of the legend bounding box;
                                                      Only Integers and values that can be converted to integers are accepted.
                                @param {Number} top [Mandatory]
                                                    The vertical position of the legend bounding box;
                                                    Only Integers and values that can be converted to integers are accepted.
                                @return {Object}    This legend object, to allow for method chaining.
                                @throws     Never: if either argument is not valid, simply ignores the action.
                            *&#x2F;
			setPosition:	function(left, top){
								left = parseInt(left, 10);
								top = parseInt(top, 10);

								if (this.__divElement__ &amp;&amp; !isNaN(left) &amp;&amp; !isNaN(top)){
									this.__divElement__.attr(&quot;style&quot;, &quot;position:absolute; left:&quot; + left + &quot;px; top:&quot;+top +&quot;px;&quot; );
								}	
                                return this;	&#x2F;&#x2F;Method chaining support
							},	
                            
                        &#x2F;** setWidth(width)
                            Sets the width of the legend bounding box.
                            
                            @method setWidth
                            @for Legend
                            @chainable
                            @param {Number} width   [Mandatory]
                                                    The new width of the legend;
                                                    Only positive integers and values that can be converted
                                                    to positive Integers are accepted.
                            @return {Object}    This legend object, to allow for method chaining.
                            @throws {Illegal Argument Exception} if the argument is not valid (see above). 
                        *&#x2F;                            
			setWidth: 	function(width){
							width = parseInt(width, 10);
							if (this.__svgElement__ &amp;&amp; !isNaN(width) &amp;&amp; width &gt;= 0){
								this.__svgElement__.attr(&quot;width&quot;, width);
                                this.__divElement__.attr(&quot;width&quot;, width);
							}else{
                                throw &quot;Illegal Argument: width&quot;;
                            }
							return this;	&#x2F;&#x2F;Method chaining support
						},	
                        
                        &#x2F;** setHeight(height)
                            Sets the height of the legend bounding box.
                            
                            @method setHeight
                            @for Legend
                            @chainable
                            @param {Number} height  [Mandatory]
                                                    The new height of the legend; 
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.
                            @return {Object}    This legend object, to allow for method chaining.
                            @throws &lt;ul&gt;
                                        &lt;li&gt; Illegal Argument Exception, if the argument is not valid (see above). &lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;    
                        *&#x2F;                             
			setHeight: function(height){
							height = parseInt(height, 10);
							if (this.__svgElement__ &amp;&amp; !isNaN(height) &amp;&amp; height &gt;= 0){
								this.__svgElement__.attr(&quot;height&quot;, height);
							}else{
                                throw &quot;Illegal Argument: height&quot;;
                            }
							return this;	&#x2F;&#x2F;Method chaining support
						},	
                           
                        &#x2F;** addItem(label, color)
                            Adds an item to the legend and then redraws it;
                            
                            @method addItem
                            @for Legend
                            @chainable
                            @param {String} labelText   [Mandatory]
                                                        The text of the label for this new item;
                            @param {String} labelColor  [Mandatory]
                                                        The color to be used to draw new item&#x27;s label;
                            @param {String} fillColor   [Mandatory]
                                                        The color associated with this new item;                                            
                            @return {Object}    This legend object, to allow for method chaining;
                            @throws &lt;ul&gt;
                                        &lt;li&gt; Wrong Number of arguments Exception, if either argument is missing. &lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;
                          *&#x2F;                        
            addItem:    function(labelText, labelColor, fillColor){
                            if (Object.isUndefined(labelText) || Object.isUndefined(labelColor) || Object.isUndefined(fillColor)){
                                throw &quot;Wrong number of arguments: label and color are both mandatory&quot;;
                            }
                            this.__items__.push({labelText: labelText, labelColor: labelColor, fillColor: fillColor});
                            var n = this.__items__.length - 1;
                            this.__svgElement__.append(&quot;rect&quot;)
                                           .attr(&quot;stroke&quot;, &quot;black&quot;)
                                           .attr(&quot;fill&quot;, fillColor)
                                           .attr(&quot;width&quot;, LEGEND_ITEM_WIDTH)
                                           .attr(&quot;height&quot;, LEGEND_ITEM_HEIGHT)
                                           .attr(&quot;x&quot;, LEGEND_ITEM_LEFT)
                                           .attr(&quot;y&quot;, LEGEND_MARGIN + n * (LEGEND_ITEM_HEIGHT + LEGEND_MARGIN));
                            this.__svgElement__.append(&quot;text&quot;)
                                           .text(labelText)
                                           .attr(&quot;fill&quot;, labelColor)
                                           .attr(&quot;x&quot;, LEGEND_ITEM_LEFT + LEGEND_ITEM_WIDTH + LEGEND_MARGIN)         &#x2F;&#x2F;Aligns to the bottom of the rect
                                           .attr(&quot;y&quot;, n * (LEGEND_ITEM_HEIGHT + LEGEND_MARGIN) + LEGEND_ITEM_HEIGHT)
											.attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
											.attr(&quot;font-size&quot;, LEGEND_ITEM_FONT_SIZE)
                                            .attr(&quot;text-anchor&quot;, &quot;left&quot;);                                         
                        }, 
                        &#x2F;** removeItem(index)
                            @method removeItem
                            @for Legend
                            @chainable
                            @param {Number} index   [Mandatory] 
                                                    The index of the item to update; 
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.
                            @return {Object}   This legend object, to allow for method chaining;                                
                            @throws &lt;ul&gt;
                                        &lt;li&gt;Illegal Argument Exception, if index is not in its valid range.&lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;
                         *&#x2F;
            removeItem: function(index){
                            index = parseInt(index, 10);
                            if (isNaN(index) || index &lt; 0 || index &gt;= this.__items__.length){
                                throw &quot;Illegal Argument: index&quot;;
                            }  
                            this.__items__.splice(index,1);
                            this.__svgElement__.selectAll(&quot;rect&quot;).data(this.__items__).exit().remove();
                            this.__svgElement__.selectAll(&quot;text&quot;).data(this.__items__).exit().remove();
                            this.__redrawLegend__();
                            return this;    &#x2F;&#x2F;Method chaining support
                        },
                        
                        &#x2F;** updateItem(index [, newLabelText, newLabelColor, newFillColor])
                            
                            Updates the attributes of an item of the legend and then redraws it;
                            
                            @method updateItem
                            @for Legend
                            @chainable
                            @param {Number} index   [Mandatory]
                                            The index of the item to update;
                            @param {String} [labelText]   [Optional]
                                                The new text for the label of the index-th item;
                                                If omitted or undefined won&#x27;t be changed;
                            @param {String} [labelColor]  [Optional]
                                                The new color to be used to draw the index-th item&#x27;s label;
                                                If omitted or undefined won&#x27;t be changed;
                            @param {String} [fillColor]   [Optional]
                                                The new color associated with the index-th item;
                                                If omitted or undefined won&#x27;t be changed;
                            @return {Object}    This legend object, to allow for method chaining;                                
                            @throws 
                                    - Illegal Argument Exception, if index is not in its valid range.
                         *&#x2F;
            updateItem: function(index, newLabelText, newLabelColor, newFillColor){
                            index = parseInt(index, 10);
                            if (isNaN(index) || index &lt; 0 || index &gt;= this.__items__.length){
                                throw &quot;Illegal Argument: index&quot;;
                            }
                            var oldItem = this.__items__[index];
                            if (!Object.isUndefined(newLabelText)){
                                oldItem.labelText = newLabelText;
                            }
                            if (!Object.isUndefined(newLabelColor)){
                                oldItem.labelColor = newLabelColor;
                            }    
                            if (!Object.isUndefined(newFillColor)){
                                oldItem.fillColor = newFillColor;
                            }                            
                            this.__redrawLegend__();
                            
                            return this;    &#x2F;&#x2F;Method chaining support
                        },
                        
                        &#x2F;** destroy()
                            
                            Object&#x27;s destructor: helps garbage collector freeing memory, and removes legend&#x27;s DOM elements.
                            
                            Object&#x27;s destructor: helps garbage collector freeing memory, and removes chart DOM elements.&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;: calling destroy on an object will force any further reference 
                                            to its attributes &#x2F; methods to throw exceptions.&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;NOTE&lt;&#x2F;b&gt;:   This function should be override by any class inheriting from this object.&lt;br&gt;
                                           In order to properly work, any overriding destroyer should:
                                            &lt;ol&gt;
                                                &lt;li&gt; Free any array specific to the object on which is called;&lt;&#x2F;li&gt;
                                                &lt;li&gt; Remove any event listener on chart objects;&lt;&#x2F;li&gt;
                                                &lt;li&gt; Call super object&#x27;s destroy method.&lt;&#x2F;li&gt;
                                            &lt;&#x2F;ol&gt;
                            @method destroy
                            @for Legend
                            @return {null} to state that the object has been destroyed.
                          *&#x2F;                        
            destroy: 	function(){
                                
                                &#x2F;&#x2F;Deletes all the elements from object&#x27;s arrays
                                this.__items__.length = 0;
                                
                                &#x2F;&#x2F;Removes DOM objects
                                this.__svgElement__.remove();
                                this.__divElement__.remove();

                                return null;
                            }
        };
        
        &#x2F;**
            Legend for a chart;&lt;br&gt;
            Adds a div and an SVG element to the page to represent a chart&#x27;s legend.
            @class Legend
            @private
          *&#x2F;
          &#x2F;&#x2F;@for BasicBarChart 
        
        &#x2F;** LegendFactory(width, height [, left, top, parent])
            
            Creates, upon request, a new Legend object and returns it;

            @method LegendFactory
            @for Legend
            @param {Number} [width]    [Mandatory]
                                    The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)
                                    Can be any value that is or can be converted to a positive integer.
            @param {Number} [height]  [Mandatory]
                                    The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)
                                    Can be any value that is or can be converted to a positive integer.
            @param {Number} [left]    [Optional]
                                    The horizontal position of the legend bounding box;
            @param {Number} [top]     [Optional]
                                    The vertical position of the legend bounding box;
            @param {Object} [parent= page&#x27;s body element]   [Optional]
                                    The DOM element to which the diagram should be appended as a child
            @return {Object}    A new Legend object;
            @throws
                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                    -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                        (through setWidth or setHeight)
                    -   Illegal Argument exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                    -   Exception, if dataDim exceeds the maximum data dimension
                    -   Exception, if parent is passed but it is not a valid DOM element
        *&#x2F;
        function LegendFactory(width, height, left, top, parent){
            
            &#x2F;** __init__(legend, width, height)
                [Private method, not visible from consumers]
                
                @method __init__
                @private
                
                @param {Object} legend  [Mandatory]
                                The legend object to be initialized;
                @param {Number} width   [Mandatory]
                                The width of the legend object;
                @param {Number} height  [Mandatory]
                                The height of the legend object;
                @param {Number} left   [Mandatory]
                                Horizontal absolute position of the legend;
                @param {Number} top  [Mandatory]
                                Vertical absolute position of the legend;                                
                @return {undefined}
                @throws 
                            -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                                (through setWidth or setHeight)
              *&#x2F;
            function __init__(legend, width, height, left, top){
                legend.setWidth(width);
                legend.setHeight(height);
                if (Object.isUndefined(left)){
                    left = 0;
                }
                if (Object.isUndefined(top)){
                    top = 0;
                }                
                legend.setPosition(left, top);
               
                legend.__svgElement__.append(&quot;rect&quot;)
                      .attr(&quot;stroke&quot;, &quot;black&quot;)
                      .attr(&quot;width&quot;, width)
                      .attr(&quot;fill&quot;, &quot;white&quot;)
                      .attr(&quot;height&quot;, height - 2)
                      .attr(&quot;x&quot;, 0)
                      .attr(&quot;y&quot;, 1);            
            }
            
            var legend = Object.create(legendPrototype);
            
            &#x2F;** __redrawLegend__()
                [Protected method, not visible outside this library]
                
                Update the drawings of this legend object;
                
                @method __redrawLegend__
                @protected
                @return {undefined}
                @throws 
                            -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                                (through setWidth or setHeight)
              *&#x2F;                                            
            Object.defineProperty(legend, &quot;__redrawLegend__&quot;, {
                    value:	function(){
                    
                                this.__svgElement__.selectAll(&quot;rect&quot;).data(this.__items__)
                                               .attr(&quot;stroke&quot;, &quot;black&quot;)
                                               .attr(&quot;fill&quot;, function(item){return item.fillColor;})
                                               .attr(&quot;width&quot;, LEGEND_ITEM_WIDTH)
                                               .attr(&quot;height&quot;, LEGEND_ITEM_HEIGHT)
                                               .attr(&quot;x&quot;, LEGEND_ITEM_LEFT)
                                               .attr(&quot;y&quot;, function(item, i){return LEGEND_MARGIN + i * (LEGEND_ITEM_HEIGHT + LEGEND_MARGIN);});
                                this.__svgElement__.selectAll(&quot;text&quot;).data(this.__items__)
                                               .text(function(item){return item.labelText;})
                                               .attr(&quot;fill&quot;, function(item){return item.labelColor;})
                                               .attr(&quot;x&quot;, LEGEND_ITEM_LEFT + LEGEND_ITEM_WIDTH + LEGEND_MARGIN)         &#x2F;&#x2F;Aligns to the bottom of the rect
                                               .attr(&quot;y&quot;, function(item, i){return i * (LEGEND_ITEM_HEIGHT + LEGEND_MARGIN) + LEGEND_ITEM_HEIGHT;})
                                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                                .attr(&quot;font-size&quot;, LEGEND_ITEM_FONT_SIZE)
                                                .attr(&quot;text-anchor&quot;, &quot;left&quot;);  
                                
                                return;
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false                 
            }); 


            if (Object.isUndefined(width)  || Object.isUndefined(height)){
                throw &quot;Wrong number of arguments: width and height are mandatory&quot;;
            }
            if (Object.isUndefined(parent )){	&#x2F;&#x2F;By default, added to the 
                parent = d3.select(&quot;body&quot;);
            }
            
            var div = parent.append(&quot;div&quot;);
            var svg = div.append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;chart_legend&quot;);
            
                                                    &#x2F;** 
                                                        The div element that will be a container to the legend&#x27;s svg element
                                                        @property __divElement__
                                                        @type {Object}
                                                        @readOnly
                                                        @protected
                                                      *&#x2F;            
            Object.defineProperty(legend, &quot;__divElement__&quot;, {
                    value:	div,
                    writable: false,
                    enumerable: false,
                    configurable:false                                   
            });  
                                            &#x2F;**
                                                The svg element for this Legend
                                                @property __svgElement__
                                                @type {Object}
                                                @readOnly
                                                @protected
                                                
                                              *&#x2F;             
            Object.defineProperty(legend, &quot;__svgElement__&quot;, {
                    value:	svg,
                    writable: false,
                    enumerable: false,
                    configurable:false                                   
            });
                                          &#x2F;** 
                                                Array of the items contained in the legend
                                                @property __items__
                                                @type {Array}
                                                @readOnly
                                                @protected                                                
                                            *&#x2F;
            Object.defineProperty(legend, &quot;__items__&quot;, {
                    value:	[],
                    writable: false,
                    enumerable: false,
                    configurable:false
            });
            
            __init__(legend, width, height, left, top);
            
            Object.seal(legend);
            return legend;
        }

        
        &#x2F;&#x2F;      -----       DYNAMIC CHARTS       --------
        
        &#x2F;** 
            Base Chart Class: &lt;b&gt;BasicBarChart&lt;&#x2F;b&gt;&lt;br&gt;
            Basic bar histogram chart.&lt;br&gt;
            Values are represented using vertical bars;&lt;br&gt;
            Each point or value can have up to 10 subcomponents, where each component can be 
            any non-nregative real number (i.e., each point can be in R_+^i, for 1 &lt;= i &lt;= 10).
            
            @class BasicBarChart
            @private
            @beta
          *&#x2F;    
          &#x2F;&#x2F;uses Legend

		var next_id = 0;
		var basicBarChartSharedPrototype = {
                            &#x2F;** setPosition(left, top)
                                Sets the position of the chart in the page. Position is assumed to be absolute.
                                
                                @method setPosition
                                @chainable
                                @param {Number} left    [Mandatory]
                                                        The horizontal position of the chart bounding box;
                                @param {Number} top     [Mandatory]
                                                        The vertical position of the chart bounding box;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws     Never: if either argument is not valid, simply ignores the action.
                            *&#x2F;
			setPosition:	function(left, top){
								left = parseInt(left, 10);
								top = parseInt(top, 10);
								if (this.__divElement__ &amp;&amp; !isNaN(left) &amp;&amp; !isNaN(top)){
									this.__divElement__.attr(&quot;style&quot;, &quot;position:absolute; left:&quot; + left + &quot;px; top:&quot;+top +&quot;px;&quot; );
								}	
                                return this;	&#x2F;&#x2F;Method chaining support
							},	
                            
                        &#x2F;** setWidth(width)
                            Sets the width of the chart bounding box.
                            
                            @method setWidth
                            @chainable
                            @param {Number} width   [Mandatory]
                                                    The new width of the chart;&lt;br&gt;
                                                    Only positive integers and values that can be converted
                                                    to positive Integers are accepted.
                            @return {Object}    This chart object, to allow for method chaining.
                            @throws {Illegal Argument Exception} if the argument is not valid (see above). 
                        *&#x2F;                          
			setWidth: 	function(width){
							width = parseInt(width, 10);
							if (this.__svgElement__ &amp;&amp; !isNaN(width) &amp;&amp; width &gt;= 0){
								this.__svgElement__.attr(&quot;width&quot;, width);
                                this.__divElement__.attr(&quot;width&quot;, width);                                
							}else{
                                throw &quot;Illegal Argument: width&quot;;
                            }
							return this;	&#x2F;&#x2F;Method chaining support
						},	
                        
                        &#x2F;** setHeight(height)
                            Sets the height of the chart bounding box.
                            
                            @method setHeight
                            @chainable
                            @param {Number} height  [Mandatory]
                                                    The new height of the chart; &lt;br&gt;
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.
                            @return {Object}    This chart object, to allow for method chaining.
                            @throws &lt;ul&gt;
                                        &lt;li&gt; Illegal Argument Exception, if the argument is not valid (see above). &lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;    
                        *&#x2F;                             
			setHeight: function(height){
							height = parseInt(height, 10);
							if (this.__svgElement__ &amp;&amp; !isNaN(height) &amp;&amp; height &gt;= 0){
								this.__svgElement__.attr(&quot;height&quot;, height);
                                this.__divElement__.attr(&quot;height&quot;, height);                                
							}else{
                                throw &quot;Illegal Argument: height&quot;;
                            }
							return this;	&#x2F;&#x2F;Method chaining support
						},	
                        &#x2F;** getAxesWidth()
                            
                            Returns the width of each of the four axe areas surrounding the chart.
                            
                            @method getAxesWidth                                              
                            @return {Array} An array with the width of the four axes in the following order:&lt;br&gt;
                                            [top, right, bottom, left]. 
                        *&#x2F;              
            getAxesWidth:   function(){
                                return [this.__svgElement__.select(&quot;#axe_top&quot;).attr(&quot;width&quot;),
                                        this.__svgElement__.select(&quot;#axe_right&quot;).attr(&quot;width&quot;),
                                        this.__svgElement__.select(&quot;#axe_bottom&quot;).attr(&quot;width&quot;),
                                        this.__svgElement__.select(&quot;#axe_left&quot;).attr(&quot;width&quot;)];
                            },
                        &#x2F;** getAxesHeight()
                            
                            Returns the height of each of the four axe areas surrounding the chart.
                            
                            @method getAxesHeight                                              
                            @return {Array} An array with the height of the four axes in the following order:&lt;br&gt;
                                            [top, right, bottom, left]. 
                        *&#x2F;                              
            getAxesHeight:   function(){
                                return [this.__svgElement__.select(&quot;#axe_top&quot;).attr(&quot;height&quot;),
                                        this.__svgElement__.select(&quot;#axe_right&quot;).attr(&quot;height&quot;),
                                        this.__svgElement__.select(&quot;#axe_bottom&quot;).attr(&quot;height&quot;),
                                        this.__svgElement__.select(&quot;#axe_left&quot;).attr(&quot;height&quot;)];
                            },                            
                        &#x2F;** setTitle(title [, size, color, left, top])
                            Sets the title for the chart, including all its attributes.
                            
                            @method setTitle
                            @chainable
                            @param {String} title  [Mandatory]
                                                    The new title for the chart;
                            @param {Number} [size=DEFAULT TITLE SIZE]  [Optional]
                                                    The size of the new title;&lt;br&gt;
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.                                                    
                            @param {String} [color=black]  [Optional]
                                                    The color of the new title;&lt;br&gt;
                            @param {Number} [left=centered]  [Optional]
                                                    The horizontal position of the title, relative to the chart; 
                                                    the text will be centered around this point&lt;br&gt;
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.  
                            @param {Number} [top=0]  [Optional]
                                                    The vertical position of the title, relative to the chart;&lt;br&gt;
                                                    Only positive Integers and values that can be converted
                                                    to positive integers are accepted.                                                   
                            @return {Object}    This legend object, to allow for method chaining.
                            @throws &lt;ul&gt;
                                        &lt;li&gt; Illegal Argument Exception, if the argument is not valid (see above). &lt;&#x2F;li&gt;
                                    &lt;&#x2F;ul&gt;    
                        *&#x2F;                          
            setTitle:   function(title, size, color, left, top){    
                            var titleElement = this.__axeTop__.selectAll(&quot;text[type=title_element]&quot;);
                            
                            size = parseInt(size, 10);
                            if (!Object.isNumber(size)){
                                size = DEFAULT_TITLE_SIZE;
                            }
                            
                            left = parseInt(left, 10);
                            if (!Object.isNumber(left)){
                                left = this.__axeTop__.attr(&quot;width&quot;) &#x2F; 2;
                            } 
                            
                            top = parseInt(top, 10);
                            if (!Object.isNumber(top)){
                                top = size;
                            }

                            if (Object.isUndefined(color)){
                                color = &quot;black&quot;;
                            }                               
                            
                            if (titleElement.empty()){
                                titleElement = this.__axeTop__.append(&quot;text&quot;)
                                                                  .attr(&quot;type&quot;, &quot;title_element&quot;)
                                                                  .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                                                  .attr(&quot;font-family&quot;, &quot;sans-serif&quot;);
                                                                  
                                                                  
                            }
                            titleElement.text(title)
                                        .attr(&quot;font-size&quot;, size)
                                        .attr(&quot;x&quot;, left)
                                        .attr(&quot;y&quot;, top)
                                        .attr(&quot;fill&quot;, color);
                            return this;	&#x2F;&#x2F;Method chaining support            
                        },
                        
						&#x2F;** addLegend:  function(labels, width, height [, left, top, parent])
                            
                            Insert new data into the chart, at runtime;
                            @method addLegend
                            @chainable
                            @param {Array} labels [Mandatory]
                                            An array containing exactly one label for each component of the data space.&lt;br&gt;
                                            A new legend object will be created and attached to the chart, and then
                                            for every subcomponent [label] a new item will be added to the legend.       
                            @return {Object} This chart object, to support method chaining;  
                            @throws 
                                    -   Illegal Argument Exception: if labels isn&#x27;t an Array object.
                                    -   Invalid array size Exception:   if the number of elements in the array is different
                                                                        from the number of subcomponents of the data space
                                                                        (i.e. from the __dataDim__ attribute)
						  *&#x2F;  
            addLegend:  function(labels, width, height, left, top, parent){
                            if (this.hasOwnProperty(&quot;__legend__&quot;)){
                                if (!Object.isArray(labels)){
                                    throw &quot;Illegal Argument: labels&quot;;
                                }
                                else if (labels.length !== this.__dataDim__){
                                    throw &quot;Invalid array size: &quot; + this.__dataDim__ + &quot; labels needed&quot;;
                                }
                                if (this.__legend__ &amp;&amp; this.__legend__.destroy){
                                    this.__legend__.destroy();
                                }
                                
                                if (Object.isUndefined(parent)){
                                    parent = this.__parent__;   &#x2F;&#x2F;By default, they&#x27;ll have the same parent;
                                }
                                
                                this.__legend__ = LegendFactory(width, height, left, top, parent);
                                
                                for (var i=0; i&lt;labels.length; i++){
                                    this.__legend__.addItem(labels[i], this.getLabelColor(i), this.getBarsFillColor(i));
                                }                                
                            }else{
                                &#x2F;&#x2F;Looks for object&#x27;s prototype
                                var proto = this.prototype ? this.prototype : this.__proto__;
                                if (proto &amp;&amp; proto.addLegend){
                                    proto.addLegend(labels, width, height, left, top, parent);
                                }                                    
                            }             

                            return this;    &#x2F;&#x2F;Method chaining supported
                        },  
 
						&#x2F;** appendData(newDataArray)
                            Insert new data into the chart, at runtime;
                            
                            @method appendData
                            @chainable
                            @param {Array} newDataArray [Mandatory]
                                                    An array containing the next values that needs to be drawn in the chart;&lt;br&gt;
                                                    Each array element, in order to be added to the chart, must be compliant
                                                    with the data format defined by the function __formatData__ (which 
                                                    can itself be set at runtime, and by default accepts arrays of 
                                                    __dataDim__ integers, neglecting to render the negative ones).
                                                    
                            @return {Object} This chart object, to support method chaining;  
                            @throws 
                                    -   Illegal Argument Exception: if newDataArray isn&#x27;t an Array object.
						  *&#x2F;                         
			appendData: function(newDataArray){
							&#x2F;*for (var key in newData){
								this.data[key] = newData[key];
							}*&#x2F;
                            
                            &#x2F;&#x2F;Save the number to use it during drawing (for scaling)
                            var oldDataLength = Math.max(this.__dataDim__, this.__getDatasetLength__() * this.__dataDim__);
                    
                            &#x2F;&#x2F;Checks how much data can be appended, and if any action is needed to do so
                            newDataArray = this.__canAppendData__(newDataArray);
                            
							var i, j, val;
							if (Object.isArray(newDataArray)){
								var n = newDataArray.length;
								for (i=0; i &lt; n; i++){
									val = this.__formatValue__(newDataArray[i]);
									if (val !== null){
                                        this.setProperty(&quot;__dataCounter__&quot;, this.__dataCounter__ + 1);
                                        for (j=0; j &lt; this.__dataDim__; j++){
                                            this.__data__[j].push(val[j]);
                                            if (val[j] &gt; this.__maxVals__[j]){
                                                this.__maxVals__[j] = val[j];
                                            }
                                        }
									}
								}	
							}else{
                                throw &quot;Illegal Argument: newDataArray must be an Array&quot;;
                            }
                            
                                                      
                            var newDataLength = this.__getDatasetLength__() * this.__dataDim__;
                            
                            &#x2F;&#x2F;The max is recomputed every time to retain the ability to switch on the fly between scaling locally and globally
                            var max_val;
                            
                            if (this.__scaleGlobally__){
                                max_val = ChartUtils.fillArray(this.__maxVals__.max(), this.__dataDim__);
                            }else{
                                max_val = this.__maxVals__;    &#x2F;&#x2F;Values aren&#x27;t going to be modified, so we can just copy the reference
                            }
                            
                            this.__updateBackground__();
                               
                            
                            for (j = 0; j &lt; this.__dataDim__; j++){  
                                &#x2F;&#x2F;Set the old X scale until the new data is added
                                this.__xScale__.domain([0, oldDataLength]);
                                var dataSet = this.__selectData__(this.__data__, j);
                                
                                var labelsSet = this.__selectLabels__(this.__data__, j);
                                
                                this.__drawNewData__(dataSet, labelsSet, j, this.__xScale__, this.__yScale__[j]);
                                
                                &#x2F;&#x2F;Computes the new X and Y scale
                                this.__xScale__.domain([0, newDataLength]);
                                this.__yScale__[j].domain([0, 	max_val[j]]);
                                this.__updateDrawing__(dataSet, labelsSet, j, this.__xScale__, this.__yScale__[j]);
                            }
                            
                            this.__updateAxes__(this.__yScale__[0]); 
							return this;	&#x2F;&#x2F;Method chaining oriented
						},
                        
                        &#x2F;** setFormatValueFunction(formaValueFunction)
                            
                            Change the data formatting function, allowing to pass a custom handler
                            to cope with JSON or other data formats.
                            
                            @method setFormatValueFunction
                            @chainable
                            @param {Function} formaValueFunction [Mandatory] 
                                                                 The new data formatting&#x2F;parsing function;
                            @return {Object}    This object, to allow for method chaining;
                            @throws     
                                        - Illegal Argument Exception, if the argument passed isn&#x27;t a valid function.
                          *&#x2F;                        
            setFormatValueFunction: function(formaValueFunction){
                                        if (Object.isUndefined(formaValueFunction) ||
                                            !Object.isFunction(formaValueFunction)){
                                                throw &quot;Illegal Argument: formaValueFunction&quot;;
                                            }
                                        Object.defineProperty(this, &quot;__formatValue__&quot;, {
                                            value: formaValueFunction,
                                            writable: true,
                                            enumerable: false,
                                            configurable:false
                                        });
                                        return this;    &#x2F;&#x2F;Method chaining support
                                    },
                        &#x2F;** clearData(n)
                        
                            Remove all the data, or part of it, from the chart;
                            
                            @method clearData
                            @chainable
                            @param {Number} [n] [Optional, For internal use only] 
                                        The number of elements to remove from the beginning of the data array,
                                        i.e. how many of the oldest values should be removed from the chart;
                            @return {Object}    This object, to allow for method chaining;
                            @throws     Illegal Argument Exception, if n is passed but it isn&#x27;t valid, i.e. it isn&#x27;t convertible to a positive int.
                          *&#x2F;
			clearData:	function(n){
                                var i, dataSet, labelsSet;
                                if (!Object.isUndefined(n)){
                                    &#x2F;&#x2F;Only part of the chart should be cleared
                                    n = parseInt(n, 10);
                                    if (isNaN(n) || n &lt;= 0 || n &gt; this.__getDatasetLength__()){
                                        throw &quot;Illegal Argument: n&quot;;
                                    }
                                }else{
                                    &#x2F;&#x2F;The whole chart must be cleared
                                    n = this.__getDatasetLength__();
                                }    
                                    
                                for (i=0; i &lt; this.__dataDim__; i++){

                                    dataSet = this.__selectData__(this.__data__, i, n);
                                    labelsSet = this.__selectLabels__(this.__data__, i, n);  
                                    this.__clearDrawing__(dataSet, labelsSet);
                                    this.__data__[i].splice(0, n);  &#x2F;&#x2F;Removes the first n elements
                                    &#x2F;&#x2F;Recomputes the max values
                                    this.__maxVals__[i] = this.__data__[i].max();
                                } 

                                this.__onClearData__(n);
	
								return this;	&#x2F;&#x2F;Method chaining oriented
							},
							
                            &#x2F;** toggleLabels([index, visible])
                                Toggles the visibility of labels in the chart
                            
                                @method toggleLabels
                                @chainable
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be affected;
								@param {Boolean} [visible] [Optional]
                                                If specified overwrites toggle behaviour and set
												the visibility to visible.
                                @return {Object}    This chart object, to allow for method chaining
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;
			toggleLabels:	function(index, visible){
                                if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}else{
                                    index = parseInt(index, 10);
                                }
                                
								if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__labelsVisible__.length &gt; index){
                                    if (!Object.isUndefined(visible)){
                                        this.__labelsVisible__[index] = visible ? true : false;
                                    }else{
                                        this.__labelsVisible__[index] = ! this.__labelsVisible__;
                                    }                                
								}else{
									throw &quot;Invalid Index&quot;;
								}

								return this;	&#x2F;&#x2F;Method chaining oriented
							},
                                    &#x2F;** areLabelsVisible([index])
                                        
                                        Checks if labels for the index-th dimension are visible
                                    
                                        @method areLabelsVisible
                                        @param {Number} [index=0]   [Optional]
                                                        For multi-dimensional data spaces, specifies
                                                        which component is going to be affected;
                                        @return {Boolean}    The visibility of the label 
                                        @throws 
                                                    Invalid Index Exception:   if the index specified isn&#x27;t valid.
                                      *&#x2F;                            
			areLabelsVisible:	function(index){
                                if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}else{
                                    index = parseInt(index, 10);
                                }
                                
								if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__labelsVisible__.length &gt; index){
                                        return this.__labelsVisible__[index];                               
                                    }else{
                                        throw &quot;Invalid Index&quot;;
                                    }
                                },
                                &#x2F;** setGlobalScaling()
                                
                                    Sets scaling to global&lt;br&gt;
                                    &lt;br&gt;
                                    When data space has a dimension greater than 1 (i.e. when each data value has more than 1 component)
                                    these charts support either global scaling (relative to the whole dataset)
                                    or local scaling (relative to value of the same component) of each subcomponent.
                                    
                                    @method setGlobalScaling
                                    @chainable
                                    @return {Object}    This chart object, to allow for method chaining.
                                  *&#x2F;
            setGlobalScaling:   function(){
                                    if (this.hasOwnProperty(&quot;__scaleGlobally__&quot;)){
                                        this.__scaleGlobally__ = true;
                                    }else{
                                        &#x2F;&#x2F;Looks for object&#x27;s prototype
                                        var proto = this.prototype ? this.prototype : this.__proto__;
                                        if (proto &amp;&amp; proto.setGlobalScaling){
                                            proto.setGlobalScaling();
                                        }                                    
                                    }  
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                },
                                &#x2F;** setLocalScaling()
                                
                                    Sets scaling to local&lt;br&gt;
                                    &lt;br&gt;
                                    When data space has a dimension greater than 1 (i.e. when each data value has more than 1 component)
                                    these charts support either global scaling (relative to the whole dataset)
                                    or local scaling (relative to value of the same component) of each subcomponent.
                                    @method setLocalScaling
                                    @chainable                                    
                                    @return {Object}    This chart object, to allow for method chaining.
                                  *&#x2F;                                
            setLocalScaling:    function(){
                                    if (this.hasOwnProperty(&quot;__scaleGlobally__&quot;)){
                                        this.__scaleGlobally__ = false;
                                    }else{
                                        &#x2F;&#x2F;Looks for object&#x27;s prototype
                                        var proto = this.prototype ? this.prototype : this.__proto__;
                                        if (proto &amp;&amp; proto.setLocalScaling){
                                            proto.setLocalScaling();
                                        }
                                    }    
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                },   
                            &#x2F;** 
                                Use getBarsFillColor instead.
                                
                                @method getFillColor
                                @deprecated
                              *&#x2F;
                            &#x2F;** getBarsFillColor([index])
                                
                                Gets the fill color used to draw the index-th component of the data space.
                                
                                @method getBarsFillColor
                                @chainable
                                @param {Number} [index=0]   [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {String|Object}    The selected fill color.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;                                
			getBarsFillColor:	function(index){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}else{
                                    index = parseInt(index, 10);
                                }
                                
								if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__barsFillColors__.length &gt; index){
									return this.__barsFillColors__[index];
								}else{
									throw &quot;Invalid Index&quot;;
								}
							},
                            &#x2F;** 
                                Use getBarsStrokeColor instead.
                                
                                @method getStrokeColor
                                @deprecated
                              *&#x2F;
                            &#x2F;** getBarsStrokeColor([index])
                                
                                Gets the stroke color used to draw the index-th component of the data space.
                                
                                @method getBarsStrokeColor
                                @param {Number} [index=0]   [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {String}    The selected stroke color.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;                                   
			getBarsStrokeColor:	function(index){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}else{
                                    index = parseInt(index, 10);
                                }
                                
								if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__barsStrokeColors__.length &gt; index){
									return this.__barsStrokeColors__[index];
								}else{
									throw &quot;Invalid Index&quot;;
								}
							},	
                            &#x2F;** getLabelColor([index])
                                
                                Gets the fill color used for the labels attached to the index-th component of the data space.
                                @method getLabelColor
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {String}    The selected label color.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;                                
			getLabelColor:	function(index){
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}else{
                                    index = parseInt(index, 10);
                                }
                                
								if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__labelColors__.length &gt; index){
									return this.__labelColors__[index];
								}else{
									throw &quot;Invalid Index&quot;;
								}
							},
                            &#x2F;** getLabelsSize([index])
                                
                                Gets the size used for the labels attached to the index-th component of the data space.
                                
                                @method getLabelsSize
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Number}    The selected size.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid.
							  *&#x2F;                               
			getLabelsSize:	function(index){
                                    if (!index){	&#x2F;&#x2F;index === undefined || index === null
                                        index = 0;
                                    }else{
                                        index = parseInt(index, 10);
                                    }
                                    
                                    if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__labelsSize__.length &gt; index){
                                        return this.__labelsSize__[index];                               
                                    }else{
                                        throw &quot;Invalid  Index&quot;;
                                    }
                                },   
                            &#x2F;** getBarWidth([xScale])
                                
                                Gets the current bar width for this chart;
                                For this chart, bar width is computed at runtime according to the number of bars plotted;
                            
                                @method getBarWidth
                                @param {Object} [xScale=this.__xScale__]  [Optional]
                                                It is possible to pass a d3 scale object to get the bar width
                                                computed with respect to a different scale metric;&lt;br&gt;
                                                On default, the value is computed with respect to this chart&#x27;s
                                                current metric.
                                @return {Number}    The value computed for the bar width under current object state.
                                @throws 
                                            - Illegal Argument Exception:   if an invalid xScale object is passed.
							  *&#x2F;                              
            getBarWidth: 	function(xScale){
                                
                                if (Object.isUndefined(xScale)){
                                    xScale = this.__xScale__;
                                }
                                
                                if (!xScale){
                                    throw &quot;Illegal Argument: xScale&quot;;
                                }
                                return xScale(1) - xScale(0) - 1;
                            },
                            
                    &#x2F;** getOuterBackgroundColor()
                    
                        Returns current color for background
                        
                        @method getOuterBackgroundColor
                        @return {String|Object} the value set for __innerBackgroundColor__
                      *&#x2F;
            getOuterBackgroundColor: function(){
                                    return this.__outerBackgroundColor__;
                                }, 
                                
                    &#x2F;** getOuterBackgroundColor()
                    
                        Returns current color for background
                        
                        @method getInnerBackgroundColor
                        @return {String|Object} the value set for __innerBackgroundColor__
                      *&#x2F;
            getInnerBackgroundColor: function(){
                                    return this.__innerBackgroundColor__;
                                }, 
                                
                    &#x2F;** getInnerBorder()
                    
                        Returns the current border settings for the main chart area.
                        
                        @method getInnerBorder
                        @return {Object} the value set for __innerBackgroundColor__
                      *&#x2F;
            getInnerBorder: function(){
                                    return this.__innerBorder__;
                                },  

                    &#x2F;** getOuterBorder()
                    
                        Returns the current border settings for the outer chart area.
                        
                        @method getOuterBorder
                        @return {Object} the value set for __innerBackgroundColor__
                      *&#x2F;
            getOuterBorder: function(){
                                    return this.__outerBorder__;
                                },                                  
                                
                            &#x2F;** 
                                Use setBarsFillColor instead.
                                
                                @method setFillColor
                                @deprecated
                              *&#x2F;	                                  
                            &#x2F;** setBarsFillColor(color, [index])
                                
                                Sets the fill color used to draw the index-th component of the data space.
                                
                                @method setBarsFillColor
                                @chainable
                                @param {String|Object] color   [Mandatory]
                                                The new fill color for the selected component&#x27;s;
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid;
							  *&#x2F;                                 
            setBarsFillColor:	function(color, index, superCall){
                                if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}else{
                                    index = parseInt(index, 10);
                                }
                                
								if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__barsFillColors__.length &gt; index){
									this.__barsFillColors__[index] = color;
								}else{
									throw &quot;Invalid Index&quot;;
								}
								
                                if (this.__legend__){   &#x2F;&#x2F;&amp;&amp; this.__legend__.updateItem 
                                                        &#x2F;&#x2F;INVARIANT: __legend__ is either null or a valid legend [Since it&#x27;s an inner class, we avoid defensive programming]
                                    this.__legend__.updateItem(index, undefined, undefined, color, true);
                                }
                                
                                if (!superCall){
                                    this.__redrawAll__();
                                }
								return this;
							},
                            &#x2F;** 
                                Use setBarsStrokeColor instead.
                                
                                @method setStrokeColor
                                @deprecated
                              *&#x2F;	                            
                            &#x2F;** setBarsStrokeColor(color, [index])
                                
                                Sets the stroke color used to draw the index-th component of the data space.
                            
                                @method setBarsStrokeColor
                                @chainable
                                @param {String} color   [Mandatory]
                                                The new stroke color for the selected component&#x27;s;
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid;
							  *&#x2F;                             
			setBarsStrokeColor:	function(color, index){
                                if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}else{
                                    index = parseInt(index, 10);
                                }
                                
								if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__barsStrokeColors__.length &gt; index){
									this.__barsStrokeColors__[index] = color;
								}else{
									throw &quot;Invalid Index&quot;;
								}
								
								return this;
							},  
                            &#x2F;** setLabelColor(color, [index])
                                
                                Sets the fill color used for the labels attached to the index-th component of the data space.
                            
                                @method setLabelColor
                                @chainable
                                @param {String} color   [Mandatory]
                                                The new color for the selected component&#x27;s labels;
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid;
							  *&#x2F;                               
			setLabelColor:	function(color, index){
                                if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}else{
                                    index = parseInt(index, 10);
                                }
                                
								if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__labelColors__.length &gt; index){
									this.__labelColors__[index] = color;
								}else{
									throw &quot;Invalid Index&quot;;
								}
                                
                                if (this.__legend__){   &#x2F;&#x2F;&amp;&amp; this.__legend__.updateItem 
                                                        &#x2F;&#x2F;INVARIANT: __legend__ is either null or a valid legend [Since it&#x27;s an inner class, we avoid defensive programming]
                                    this.__legend__.updateItem(index, undefined, color, undefined);
                                }                                
								
								return this;
							},
                            &#x2F;** setLabelSize(size, [index])
                                
                                Sets the size used for the labels attached to the index-th component of the data space.
                            
                                @method setLabelSize
                                @chainable
                                @param {Number} size    [Mandatory]
                                                The new size for the selected component&#x27;s labels;
                                                Must be a positive integer, or a value that can be converted
                                                to a positive integer;
                                @param {Number} [index=0] [Optional]
                                                For multi-dimensional data spaces, specifies
                                                which component is going to be selected;
                                @return {Object}    This chart object, to allow for method chaining.
                                @throws 
                                            - Invalid Index Exception:   if the index specified isn&#x27;t valid;
                                            - Illegal Argument Exception:   if size isn&#x27;t valid (see above). 
							  *&#x2F;                            
			setLabelSize:	function(size, index){
                                size = parseInt(size, 10);
                                if (isNaN(size) || size &lt;= 0){
                                    throw &quot;Illegal Argument: size&quot;;
                                }
                                
								if (!index){	&#x2F;&#x2F;index === undefined || index === null
									index = 0;
								}else{
                                    index = parseInt(index, 10);
                                }
                                
								if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__labelsSize__.length &gt; index){
									this.__labelsSize__[index] = size;
								}else{
									throw &quot;Invalid Index&quot;;
								}
								
								return this;
							} ,
                            &#x2F;** setBarWidth()
                            
                                Sets the bars width property;
                                For this chart, bar width is computed at runtime according to the number of bars plotted,
                                so this property can&#x27;t be set.&lt;br&gt;
                                &lt;b&gt;Unless overridden, any call to this method will cause an exception to be thrown&lt;&#x2F;b&gt;&lt;br&gt;
                                This method is declared to improve the consistency of the interface.
                                     
                                @method setBarWidth
                                @throws Read only property Exception
                              *&#x2F;
            setBarWidth: 	function(&#x2F;*barWidth*&#x2F;){
                                throw &quot;Read only property: barWidth&quot;;
                            },
    
                &#x2F;** setInnerBackgroundColor(bgColor)
                
                    Changes the background color
                    
                    @method setInnerBackgroundColor
                    @chainable
                    @param {String|Object} bgColor [Mandatory]
                                                   The new color for background;                                                          
                    @return {Object} This chart object, to allow for method chaining.
                  *&#x2F;
            setInnerBackgroundColor: function(bgColor, superCall){  
                                                       &#x2F;&#x2F; {Boolean} superCall is an internal parameter
                                                       &#x2F;&#x2F;           used to distinguish calls to a super method
                                    if (this.hasOwnProperty(&quot;__innerBackgroundColor__&quot;)){
                                        this.__innerBackgroundColor__ = bgColor;
                                    }else{
                                        &#x2F;&#x2F;Looks the same method in the super class
                                        this.superMethod(&quot;setInnerBackgroundColor&quot;, bgColor, true);  
                                    }
                                    
                                    if (!superCall){
                                        this.__redrawInnerBackground__();
                                    }                                     
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                },  
                                
                                
                &#x2F;** setOuterBackgroundColor(bgColor)
                
                    Changes the background color of the outer area of the chart.
                    
                    @method setOuterBackgroundColor
                    @since 0.2
                    @chainable
                    @param {String|Object} bgColor [Mandatory]
                                                   The new color for background of the outer area;
                    @return {Object} This chart object, to allow for method chaining.
                  *&#x2F;
            setOuterBackgroundColor: function(bgColor, superCall){
                                                       &#x2F;&#x2F;{Boolean} superCall is an internal parameter
                                                       &#x2F;&#x2F;          used to distinguish calls to a super method
                                    if (this.hasOwnProperty(&quot;__outerBackgroundColor__&quot;)){
                                        this.__outerBackgroundColor__ = bgColor;
                                    }else{
                                        &#x2F;&#x2F;Looks the same method in the super class
                                        this.superMethod(&quot;setOuterBackgroundColor&quot;, bgColor, true);
                                    }   
                                    
                                    if (!superCall){
                                        this.__redrawOuterBackground__();
                                    }   
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                }, 

                            &#x2F;** setInnerBorder(fill [, width, dash])
                            
                                Changes the border of the main chart area.
                                
                                @method setInnerBorder
                                @since 0.2
                                @chainable
                                @param {String|Object} fill [Mandatory]
                                                             The new color for the border, or &quot;none&quot;
                                                             if it has to be removed;
                                @param {Number} [width] [Mandatory] 
                                                The width of the border line, in pixels;&lt;br&gt;
                                                
                                @param {String} [dash] [Mandatory]
                                                       The dash pattern for the border;&lt;br&gt;
                                                       The format for the dash string parameter allows
                                                       to specify n couples of positive integers
                                                       &lt;i&gt;&quot;#line_1 #space_1 #line_2 #space_2 ... #line_n #space_n&quot;&lt;&#x2F;i&gt;
                                                       where each #line and #space represents the number
                                                       of pixels in the pattern for lines and spaces
                                                       segments respectively.
                                @return {Object}    This chart object, to allow for method chaining.
                              *&#x2F;
            setInnerBorder: function(fill, width, dash, superCall){
                                                       &#x2F;&#x2F; {Boolean} superCall is an internal parameter
                                                       &#x2F;&#x2F;           used to distinguish calls to a super method
                                    if (this.hasOwnProperty(&quot;__innerBorder__&quot;)){
                                        
                                        this.__innerBorder__.fill = fill;
                                        if (!Object.isUndefined(width)){
                                            this.__innerBorder__.width = width;
                                        }
                                        if (!Object.isUndefined(dash)){
                                            this.__innerBorder__.dash = dash;
                                        }
                                        
                                    }else{
                                        &#x2F;&#x2F;Looks the same method in the super class
                                        this.superMethod(&quot;setInnerBorder&quot;, fill, width, dash, true);
                                    }     

                                    if (!superCall){
                                        this.__redrawInnerBorder__();
                                    }
                                    
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                },  


                            &#x2F;** setOuterBorder(fill [, width, dash])
                            
                                Changes the border of the outer chart area.
                                
                                @method setOuterBorder
                                @since 0.2
                                @chainable
                                @param {String|Object} fill [Mandatory]
                                                             The new color for the border, or &quot;none&quot;
                                                             if it has to be removed;
                                @param {Number} [width] [Mandatory] 
                                                The width of the border line, in pixels;&lt;br&gt;
                                                
                                @param {String} [dash] [Mandatory]
                                                       The dash pattern for the border;&lt;br&gt;
                                                       The format for the dash string parameter allows
                                                       to specify n couples of positive integers
                                                       &lt;i&gt;&quot;#line_1 #space_1 #line_2 #space_2 ... #line_n #space_n&quot;&lt;&#x2F;i&gt;
                                                       where each #line and #space represents the number
                                                       of pixels in the pattern for lines and spaces
                                                       segments respectively.
                                @return {Object}    This chart object, to allow for method chaining.
                              *&#x2F;
            setOuterBorder: function(fill, width, dash, superCall){
                                                       &#x2F;&#x2F; {Boolean} superCall is an internal parameter
                                                       &#x2F;&#x2F;           used to distinguish calls to a super method
                                    if (this.hasOwnProperty(&quot;__outerBorder__&quot;)){
                                        this.__outerBorder__.fill = fill;
                                        if (!Object.isUndefined(width)){
                                            this.__outerBorder__.width = width;
                                        }
                                        if (!Object.isUndefined(dash)){
                                            this.__outerBorder__.dash = dash;
                                        }
                                        
                                    }else{
                                        &#x2F;&#x2F;Looks the same method in the super class
                                        this.superMethod(&quot;setOuterBorder&quot;, fill, width, dash, true);
                                    }  
                                    
                                    if (!superCall){    &#x2F;&#x2F;undefined or falsey
                                        this.__redrawOuterBorder__();
                                    }
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                },      


                                &#x2F;** setAbbreviatedLabel()
                                
                                    Displays abbreviated text for bars&#x27; label.&lt;br&gt;
                                    F.i.: 1.1M instead of 1,123,543 or 4.3K instead of 4,356
                                    
                                    @method setAbbreviatedLabel
                                    @since 0.2
                                    @chainable 
                                    @param {Number} [index=0] [Optional]
                                                    For multi-dimensional data spaces, specifies
                                                    which component is going to be selected;                                      
                                    @return {Object}    This chart object, to allow for method chaining.
                                    @throws {Invalid Index Exception} If the index specified isn&#x27;t valid.                                                                                 
                                  *&#x2F;
            setAbbreviatedLabel: function(index, superCall){
                                                       &#x2F;&#x2F; {Boolean} superCall is an internal parameter
                                                       &#x2F;&#x2F;           used to distinguish calls to a super method 
                                    
                                    if (this.hasOwnProperty(&quot;__abbreviatedLabels__&quot;)){
                                        if (!index){	&#x2F;&#x2F;index === undefined || index === null
                                            index = 0;
                                        }else{
                                            index = parseInt(index, 10);
                                        }
                                        
                                        if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__abbreviatedLabels__.length &gt; index){                                      
                                            this.__abbreviatedLabels__[index] = true;
                                        }
                                    }else{                                 
                                        &#x2F;&#x2F;Looks the same method in the super class
                                        this.superMethod(&quot;setAbbreviatedLabel&quot;, index, true);
                                    }   

                                    if (!superCall){
                                        this.__redrawAll__();
                                    }
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                },  
                                
                                &#x2F;** setExtendedLabel()
                                
                                    Displays extended text for bars&#x27; label.&lt;br&gt;
                                    
                                    @method setExtendedLabel
                                    @since 0.2
                                    @chainable 
                                    @param {Number} [index=0] [Optional]
                                                    For multi-dimensional data spaces, specifies
                                                    which component is going to be selected;                                                  
                                    @return {Object}    This chart object, to allow for method chaining.
                                    @throws {Invalid Index Exception} If the index specified isn&#x27;t valid.                                  
                                  *&#x2F;
            setExtendedLabel: function(index, superCall){
                                                       &#x2F;&#x2F; {Boolean} superCall is an internal parameter
                                                       &#x2F;&#x2F;           used to distinguish calls to a super method  
                         
	                                    
                                    if (this.hasOwnProperty(&quot;__abbreviatedLabels__&quot;)){
                                        if (!index){	&#x2F;&#x2F;index === undefined || index === null
                                            index = 0;
                                        }else{
                                            index = parseInt(index, 10);
                                        }
                                        
                                        if (!isNaN(index) &amp;&amp; index &gt;= 0 &amp;&amp; this.__abbreviatedLabels__.length &gt; index){                                      
                                            this.__abbreviatedLabels__[index] = false;
                                        }
                                    }else{                                   
                                        &#x2F;&#x2F;Looks the same method in the super class
                                        this.superMethod(&quot;setExtendedLabel&quot;, index, true);
                                    }     

                                    if (!superCall){
                                        this.__redrawAll__();
                                    }                                    
                                    return this;	&#x2F;&#x2F;Method chaining oriented
                                },                                 
                       
                      
                &#x2F;** setHorizontalAxe([displayOnTop, title, notches, lineWidth, labelColor, labelSize, titleColor, titleSize])
                
                    Set the properties for an horizontal axe and draws it anew, clearing previous versions.&lt;br&gt;
                    
                    @method setHorizontalAxe
                    @since 0.2
                    @chainable 
                    @param {Boolean} [displayOnTop=false] [Optional]
                                     If passed and thrutey, the vertical axe will be added to the displayOnTop instead than to the bottom
                                     of the chart.
                    @param {String} [title=&quot;&quot;] [Optional]
                                    The title to use for the vertical axe.
                    @param {Number} [notches=0] [Optional]
                                    Number of notches to display on the vertical axe (excluding the 2 extremes).&lt;br&gt;
                                    &lt;b&gt;MUST&lt;&#x2F;b&gt; be a non negative integer.
                    @param {Number} [lineWidth=DEFAULT_AXES_LINE_WIDTH] [Optional]
                                    The desired line width for the axe and notches.&lt;br&gt;
                                    If passed MUST be a positive integer; otherwise it is set to the default value.
                    @param {String} [labelColor=DEFAULT_AXES_COLOR] [Optional]
                                     Color to use for axe&#x27;s drawings and labels. 
                    @param {Number} [labelSize=DEFAULT_AXES_LABEL_SIZE] [Optional]
                                    Size for the notches label&#x27;s text. 
                    @param {String} [titleColor=DEFAULT_AXES_COLOR] [Optional]
                                     Color to use for axe&#x27;s title.                                       
                    @param {Number} [titleSize=DEFAULT_AXES_LABEL_SIZE] [Optional]
                                    The desired size for the title.&lt;br&gt;
                                    If passed MUST be a positive integer; otherwise it is set to the default value.                                  
                    @return {Object}    This chart object, to allow for method chaining.
                    @throws {Invalid Argument Exception} If notches is passed but it&#x27;s not valid (see above).                                  
                  *&#x2F;                                
            setHorizontalAxe: function(displayOnTop, title, notches, lineWidth, labelColor, labelSize, titleColor, titleSize){
                                if (Object.isUndefined(notches)){
                                    notches = 0;
                                }else{
                                    notches = parseInt(notches, 10);
                                    if (isNaN(notches) || notches &lt; 0){
                                        throw &quot;Illegal Argument: notches&quot;;
                                    }
                                }
                                
                                lineWidth = parseInt(lineWidth, 10);
                                if (isNaN(lineWidth) || lineWidth &lt;= 0){
                                    lineWidth = DEFAULT_AXES_LINE_WIDTH;
                                }
                                
                                labelSize = parseInt(labelSize, 10);
                                if (isNaN(labelSize) || labelSize &lt;= 0){
                                    labelSize = DEFAULT_AXES_LABEL_SIZE;
                                }                                
                                
                                if (Object.isUndefined(labelColor)){
                                    labelColor = DEFAULT_AXES_COLOR;
                                }
                                
                                &#x2F;&#x2F;First it clears the previous drawing of the axe, if any is present
                                this.__clearHorizontalAxe__();
                                
                                var axe =   {
                                                notches: notches,
                                                color: labelColor,
                                                lineWidth: lineWidth,
                                                labelSize: labelSize,
                                                title: title,
                                                titleSize: parseInt(titleSize, 10),
                                                titleColor: titleColor                                                              
                                            };                                 
                                
                                if (displayOnTop){
                                    axe.side = &quot;top&quot;;
                                    axe.svgElement = this.__axeTop__;
                                }else{
                                    axe.side = &quot;bottom&quot;;
                                    axe.svgElement = this.__axeBottom__;                              
                                }
                                
                                
                                if (isNaN(axe.titleSize) || axe.titleSize &lt; 0){
                                    axe.titleSize = DEFAULT_AXES_LABEL_SIZE;
                                }
                                
                                if (!axe.titleColor){
                                    axe.titleColor = axe.color;
                                }   
                                
                                Object.freeze(axe); &#x2F;&#x2F;Prevent further modifications
                                this.setProperty(&quot;__horizontalAxe__&quot;, axe);
                                this.__drawHorizontalAxe__();
                                
                                return this;
                            },                                            
            
                &#x2F;** removeHorizontalAxe()
                
                    Removes the horizontal axe object and all related drawings from this chart.
                    
                    @method removeHorizontalAxe
                    @since 0.2
                    @chainable       
                    @return {Object}    This chart object, to allow for method chaining.                                 
                  *&#x2F;             
            removeHorizontalAxe:  function(){
                                    this.__clearHorizontalAxe__();
                                    this.setProperty(&quot;__horizontalAxe__&quot;, null);
                                    return this;
                                },            
                      
                &#x2F;** setVerticalAxe([displayOnRight, title, notches, lineWidth, labelColor, labelSize, titleColor, titleSize])
                
                    Set the properties for a vertical axe and draws it anew, clearing previous versions.&lt;br&gt;
                    
                    @method setVerticalAxe
                    @since 0.2
                    @chainable 
                    @param {Boolean} [displayOnRight=false] [Optional]
                                     If passed and thrutey, the vertical axe will be added to the displayOnRight instead than to the left
                                     of the chart.
                    @param {String} [title=&quot;&quot;] [Optional]
                                    The title to use for the vertical axe.
                    @param {Number} [notches=0] [Optional]
                                    Number of notches to display on the vertical axe (excluding the 2 extremes).&lt;br&gt;
                                    &lt;b&gt;MUST&lt;&#x2F;b&gt; be a non negative integer.
                    @param {Number} [lineWidth=DEFAULT_AXES_LINE_WIDTH] [Optional]
                                    The desired line width for the axe and notches.&lt;br&gt;
                                    If passed MUST be a positive integer; otherwise it is set to the default value.
                    @param {String} [labelColor=DEFAULT_AXES_COLOR] [Optional]
                                     Color to use for axe&#x27;s drawings and labels. 
                    @param {Number} [labelSize=DEFAULT_AXES_LABEL_SIZE] [Optional]
                                    Size for the notches label&#x27;s text.                                      
                    @param {String} [titleColor=DEFAULT_AXES_COLOR] [Optional]
                                     Color to use for axe&#x27;s title.                                     
                    @param {Number} [titleSize=DEFAULT_AXES_LABEL_SIZE] [Optional]
                                    The desired size for the title.&lt;br&gt;
                                    If passed MUST be a positive integer; otherwise it is set to the default value.
                    @return {Object}    This chart object, to allow for method chaining.
                    @throws {Invalid Argument Exception} If notches is passed but it&#x27;s not valid (see above).                                  
                  *&#x2F;                                
            setVerticalAxe: function(displayOnRight, title, notches, lineWidth, labelColor, labelSize, titleColor, titleSize){
                                if (Object.isUndefined(notches)){
                                    notches = 0;
                                }else{
                                    notches = parseInt(notches, 10);
                                    if (isNaN(notches) || notches &lt; 0){
                                        throw &quot;Illegal Argument: notches&quot;;
                                    }
                                }
                                
                                lineWidth = parseInt(lineWidth, 10);
                                if (isNaN(lineWidth) || lineWidth &lt;= 0){
                                    lineWidth = DEFAULT_AXES_LINE_WIDTH;
                                }
                                
                                labelSize = parseInt(labelSize, 10);
                                if (isNaN(labelSize) || labelSize &lt;= 0){
                                    labelSize = DEFAULT_AXES_LABEL_SIZE;
                                }
                                
                                if (Object.isUndefined(labelColor)){
                                    labelColor = DEFAULT_AXES_COLOR;
                                }
                                
                                &#x2F;&#x2F;First it clears the previous drawing of the axe, if any is present
                                this.__clearVerticalAxe__();
                                
                                var axe =   {
                                                notches: notches,
                                                color: labelColor,
                                                lineWidth: lineWidth,
                                                labelSize: labelSize,
                                                title: title,
                                                titleSize: parseInt(titleSize, 10),
                                                titleColor: titleColor                                                                
                                            };
                                
                                if (displayOnRight){
                                    axe.side = &quot;right&quot;;
                                    axe.svgElement = this.__axeRight__;                                    
                                }else{
                                    axe.side = &quot;left&quot;;
                                    axe.svgElement = this.__axeLeft__;
                                }
                                
                                if (isNaN(axe.titleSize) || axe.titleSize &lt; 0){
                                    axe.titleSize = DEFAULT_AXES_LABEL_SIZE;
                                }
                                
                                if (!axe.titleColor){
                                    axe.titleColor = axe.color;
                                }   
                                
                                Object.freeze(axe); &#x2F;&#x2F;Prevent further modifications
                                this.setProperty(&quot;__verticalAxe__&quot;, axe);
                                this.__drawVerticalAxe__(title, titleSize, titleColor);
                                
                                return this;
                            },     
            
                &#x2F;** removeVerticalAxe()
                
                    Removes the vertical axe object and all related drawings from this chart.
                    
                    @method removeVerticalAxe
                    @since 0.2
                    @chainable       
                    @return {Object}    This chart object, to allow for method chaining.                                 
                  *&#x2F;             
            removeVerticalAxe:  function(){
                                    this.__clearVerticalAxe__();
                                    this.setProperty(&quot;__verticalAxe__&quot;, null);
                                    return this;
                                },                              
                                
                        &#x2F;** destroy()
                            
                            Object&#x27;s destructor: helps garbage collector freeing memory, and removes chart DOM elements.&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;: calling destroy on an object will force any further reference 
                                            to its attributes &#x2F; methods to throw exceptions.&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;NOTE&lt;&#x2F;b&gt;:   This function should be override by any class inheriting from this chart.&lt;br&gt;
                                           In order to properly work, any overriding destroyer should:
                                            &lt;ol&gt;
                                                &lt;li&gt; Free any array specific to the object on which is called;&lt;&#x2F;li&gt;
                                                &lt;li&gt; Remove any event listener on chart objects;&lt;&#x2F;li&gt;
                                                &lt;li&gt; Call super object&#x27;s destroy method.&lt;&#x2F;li&gt;
                                            &lt;&#x2F;ol&gt;
                            @method destroy
                            @return {null} to state that the object has been destroyed.
                          *&#x2F;                        
            destroy: 	function(){
                                &#x2F;&#x2F;Removes all the data from the chart;
                                this.clearData();
                                
                                &#x2F;&#x2F;Deletes all the elements from object&#x27;s arrays
                                this.__data__.length = 0;
                                this.__maxVals__.length = 0;
                                this.__yScale__.length = 0;
                                this.__barsStrokeColors__.length = 0;
                                this.__barsFillColors__.length = 0;
                                this.__labelColors__.length = 0;
                                this.__labelsSize__.length = 0;
                                this.__labelsVisible__.length = 0;
                                
                                &#x2F;&#x2F;Removes DOM objects
                                this.__svgElement__.remove();
                                this.__divElement__.remove();
                                
                                &#x2F;&#x2F;Removes legend, if any
                                if (this.__legend__ &amp;&amp; this.__legend__.destroy){
                                    this.__legend__.destroy();
                                }
                                return null;
                            }
                              
                        
		};
        
        &#x2F;&#x2F;  ---------------------  PROTECTED METHODS    ---------------------------------------
          
         Object.defineProperty(basicBarChartSharedPrototype, &quot;__getDatasetLength__&quot;, {
                                &#x2F;** __getDatasetLength__()  
                                    
                                    Utility function to take account of the number of points currently added to the chart
                                    
                                    @method __getDatasetLength__
                                    @protected
                                    @return {Number}    How many points are stored in the dataset right now.
                                *&#x2F;
                        value: 	function(){
                            &#x2F;&#x2F;INVARIANT: there will always be at least 1 element in __data__ array [assumed to avoid defensive programming]
                            return this.__data__[0].length;
						},
						writable: false,
						enumerable: false,
						configurable:false
					});	
                    
        Object.defineProperty(basicBarChartSharedPrototype, &quot;__canAppendData__&quot;, {
                                &#x2F;** __canAppendData__(newDataArray)  
                                 
                                    Checks that new data can be added to the chart (if the chart can represent only a limited number of points);&lt;br&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;: This function SHOULD be overriden in any class inheriting from the base class
                                    in order to handle differents needs
                                    
                                    @method __canAppendData__
                                    @protected

                                    @param {Array} newDataArray    [Mandatory]
                                                            The array of values that should be added;
                                    @return {Array}    The array of values that can still be added to the chart;&lt;br&gt;
                                                       If no other value can be added, return the empty list.                                              
                                *&#x2F;
                        value: 	function(newDataArray){
                            if (!Object.isArray(newDataArray)){
                                return [];
                            }
                            &#x2F;&#x2F;else, if the bar width still has a valid value, returns the input value, otherwise the empty list                           
                            return this.__getDatasetLength__() === 0 || this.getBarWidth(this.__xScale__) &gt; 0 ? newDataArray : [];
						},
						writable: false,
						enumerable: false,
						configurable:false
					});	

		basicBarChartSharedPrototype.addProtectedMethod(&quot;__redrawAll__&quot;,
            &#x2F;** __redrawAll__()
                
                Redraws completely the whole chart, updating all the non-fixed attributes of the drawings.
            
                @method __redrawAll__
                @since 0.2
                @protected
                @return {undefined} Pseudo protected method called only internally, no need to return anything              
              *&#x2F;
            function __redrawAll__(){
                &#x2F;&#x2F;The whole chart must be updated
                var dataSet, labelsSet;
                var newDataLength = this.__getDatasetLength__() * this.__dataDim__;
                
                &#x2F;&#x2F;The max is recomputed every time to retain the ability to switch on the fly between scaling locally and globally
                var max_val;
                
                if (this.__scaleGlobally__){
                    max_val = ChartUtils.fillArray(this.__maxVals__.max(), this.__dataDim__);
                }else{
                    max_val = this.__maxVals__;    &#x2F;&#x2F;Values aren&#x27;t going to be modified, so we can just copy the reference
                }                            
 
                this.__xScale__.domain([0, newDataLength]);
                
                for (var i=0; i &lt; this.__dataDim__; i++){
                                        
                    this.__yScale__[i].domain([0, 	max_val[i]]);
                    
                    dataSet = this.__selectData__(this.__data__, i);
                    labelsSet = this.__selectLabels__(this.__data__, i);

                    this.__refreshDrawing__(dataSet, labelsSet, i, this.__xScale__, this.__yScale__[i]);
                }
                
                return ;
            });                    
                    
        Object.defineProperty(basicBarChartSharedPrototype, &quot;__formatValue__&quot;, {
                                &#x2F;** __formatValue__(value)
                                    
                                    Checks that the value passed corresponds to the data format allowed for the current chart;
                                    This function can be overriden in any class inheriting from the base class
                                    in order to handle differents data formats (i.e. Objects or JSON).
                                    
                                    @method __formatValue__
                                    @protected
                                    @param {Array|Object} value   [Mandatory]
                                                                    The value to be tested;
                                    @return {Array} &lt;ul&gt;
                                                        &lt;li&gt;An array with properly formatted values, each of whom 
                                                            converted to float &lt;=&gt; value is correctly validated&lt;&#x2F;li&gt;
                                                        &lt;li&gt;null &lt;-&gt; Otherwise&lt;&#x2F;li&gt;
                                                    &lt;&#x2F;ul&gt;
                                *&#x2F;
                        value: 	function(value){
                            if (Object.isArray(value)){
                                if (value.length !== this.__dataDim__){
                                    &#x2F;&#x2F;Invalid data;
                                    return null;
                                }
                                for (var i=0; i &lt; this.__dataDim__; i++){
                                    if (!Object.isNumber(value[i])){
                                        return null;
                                    }
                                }
                                &#x2F;&#x2F;At this point we can assume the value is valid
                                return value.map(parseFloat);
                            }else if (Object.isNumber(value) &amp;&amp; this.__dataDim__ === 1){
                                return [parseFloat(value)];
                            }else{
                                &#x2F;&#x2F;Invalid value
                                return null;
                            }
						},
						writable: false,
						enumerable: false,
						configurable:false
					});	
               
		Object.defineProperty(basicBarChartSharedPrototype, &quot;__selectData__&quot;, {
                                &#x2F;** __selectData__(data, index [, n])
                                
                                    Returns the list of the svg elements used to represent data subcomponents
                                    with the required index.&lt;br&gt;
                                    I.e.:   if data space is 3-dimensional (i.e. every point has 3 components)
                                            __selectData__(data, 2) would select the svg elements representing
                                            the 2nd component of every point in data
                                            
                                    @method __selectData__
                                    @protected
                                    
                                    @param {Array} data [Mandatory]
                                                        The dataset on which selection should be applied
                                    @param {Number} index   [Mandatory]
                                                    The index of the required component&lt;br&gt;
                                                    &lt;b&gt;INVARIANT&lt;&#x2F;b&gt;:  to avoid defensive programming,
                                                                        it is assumed 0 &lt;= index &lt; this.__dataDim__
                                    @param {Number} [n] [Optional]
                                                    The maximum number of elements to return;
                                    @return {Object} The proper set of d3 elements.                    
                                  *&#x2F;
						value: 	function(data, index, n){
                                    if (Object.isUndefined(n)){
                                        return this.__chartArea__.selectAll(&quot;rect[index=data_&quot;+index+&quot;]&quot;).data(data[index]);
                                    }else{
                                        return this.__chartArea__.selectAll(&quot;rect[index=data_&quot;+index+&quot;]&quot;).data(data[index].slice(0, n));
                                    }
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});
                    
		Object.defineProperty(basicBarChartSharedPrototype, &quot;__selectLabels__&quot;, {
                                &#x2F;** __selectLabels__(data, index [, n])
                                  
                                    Returns the list of the svg elements used to draw the labels of
                                    subcomponents of data with the required index.&lt;br&gt;
                                    I.e.:   if data space is 3-dimensional (i.e. every point has 3 components)
                                            __selectLabels__(data, 3) would select the svg elements representing
                                            the labels of the 3nd component of every point in data  
                                    
                                    @method __selectLabels__
                                    @protected
                                    

                                    @param {Array} data [Mandatory]
                                                    The dataset on which selection should be applied;
                                    @param {Number} index   [Mandatory]
                                                    The index of the required component;&lt;br&gt;
                                                    &lt;b&gt;INVARIANT&lt;&#x2F;b&gt;:  to avoid defensive programming,
                                                                        it is assumed 0 &lt;= index &lt; this.__dataDim__
                                    @param {Number} [n] [Optional]
                                                    The maximum number of elements to return;
                                    @return {Object}    The proper set of d3 elements.                    
                                  *&#x2F;      
						value: 	function(data, index, n){
                                    if (Object.isUndefined(n)){
                                        return this.__chartArea__.selectAll(&quot;text[index=data_&quot;+index+&quot;]&quot;).data(data[index]);
                                    }else{
                                        return this.__chartArea__.selectAll(&quot;text[index=data_&quot;+index+&quot;]&quot;).data(data[index].slice(0, n));
                                    }
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});

                    
		Object.defineProperty(basicBarChartSharedPrototype, &quot;__drawNewData__&quot;, {
                                &#x2F;** __drawNewData__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                    
                                    Called by appendData() to draw the newly added points in dataSet, once for
                                    every data subcomponent.&lt;br&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                this method and __updateDrawing__ in order to obtain a custom chart.

                                                
                                    
                                    @method __drawNewData__
                                    @protected
                                    @param {Object} dataSet [Mandatory]
                                                    The set of svg elements created so far to represent the data;&lt;br&gt;
                                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;: this parameter should be generated by an appropriate
                                                                    call to __selectData__;
                                    @param {Object} labelsSet [Mandatory]
                                                        The set of svg elements created so far to represent the labels of the data;&lt;br&gt;
                                                        &lt;b&gt;WARNING&lt;&#x2F;b&gt;: this parameter should be generated by an appropriate
                                                                        call to __selectLabels__; 
                                    @param {Number} dataIndex   [Mandatory]
                                                                The index of the component of the data which is to be drawn;
                                    @param {Object} xScale  [Mandatory]
                                                    D3 scale object for X axis;
                                    @param {Object} yScale  [Mandatory]
                                                    D3 scale object for Y axis (specific to current component);
                                    @return {undefined}
                                  *&#x2F;
						value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
									var that = this;
									var height = this.__getChartAreaHeight__();
									var barWidth =  this.getBarWidth(xScale);
                                    
									dataSet.enter().append(&quot;rect&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
										.attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex);})
										.attr(&quot;y&quot;, height)	
										.attr(&quot;width&quot;, barWidth)
										.attr(&quot;height&quot;, 0)	
										.attr(&quot;fill&quot;, that.getBarsFillColor(dataIndex))
                                        .attr(&quot;stroke&quot;, that.getBarsStrokeColor(dataIndex))
										.attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});
										
									
									if (that.areLabelsVisible(dataIndex)){
										labelsSet.enter().append(&quot;text&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
											.text(function(d) {return that.__makeLabel__(d, dataIndex);})
											.attr(&quot;text-anchor&quot;, &quot;middle&quot;)
											.attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex) + barWidth &#x2F; 2;})
											.attr(&quot;y&quot;, height)
											.attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
											.attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
											.attr(&quot;fill&quot;, that.getLabelColor(dataIndex))
                                            .attr(&quot;opacity&quot;, function(){  &#x2F;&#x2F;Show the label only if it fits the bar
                                                                if (this.getComputedTextLength() &lt;= barWidth){
                                                                    return 1;
                                                                }else{
                                                                    return 0;
                                                                }
                                                            });
									}else{
										labelsSet.remove();
									}
										
									return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
								},
						writable: false,
						enumerable: false,
						configurable:false
					});
                    
		Object.defineProperty(basicBarChartSharedPrototype, &quot;__updateDrawing__&quot;, {
                                &#x2F;** __updateDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                    
                                    Called by appendData() to update drawing of the points in dataSet, once for
                                    every data subcomponent.&lt;br&gt;
                                    After new data is inserted by __drawNewData__, appendData performs adjustments
                                    to accomodate for scale change or shift in the drawing due to time, and this
                                    function takes care of updating and fixing the chart representation.&lt;br&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                        this method and __drawNewData__ in order to obtain a custom chart.                                    
                                    @method __updateDrawing__
                                    @protected
                                    @param {Object} dataSet [Mandatory]
                                                    The set of svg elements created so far to represent the data;&lt;br&gt;
                                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;: this parameter should be generated by an appropriate
                                                                    call to __selectData__;
                                    @param {Object} labelsSet   [Mandatory]
                                                        The set of svg elements created so far to represent the labels of the data;&lt;br&gt;
                                                        &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    this parameter should be generated by an appropriate
                                                                            call to __selectLabels__;    
                                    @param {Number} dataIndex   [Mandatory]
                                                        The index of the component of the data which is to be drawn;
                                    @param {Object} xScale  [Mandatory]
                                                            D3 scale object for X axis;
                                    @param {Object} yScale  [Mandatory]
                                                            D3 scale object for Y axis (specific to current component).
                                    @return {undefined}
                                  *&#x2F;					
                        value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                    var that = this;
                                    var height = this.__getChartAreaHeight__();
                                    var barWidth = this.getBarWidth(xScale);							
                                    dataSet.transition()&#x2F;&#x2F;.delay(250)
                                            .attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex);})
                                            .attr(&quot;y&quot;, function(d){return height - yScale(d);})
                                            .attr(&quot;width&quot;, barWidth)
                                            .attr(&quot;height&quot;, function(d){return yScale(d);})
                                            .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});									
                                    if (that.areLabelsVisible(dataIndex)){
                                        labelsSet.transition()&#x2F;&#x2F;.delay(250)
                                                .text(function(d) {return that.__makeLabel__(d, dataIndex);})
                                                .attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex) + barWidth &#x2F; 2;})
                                                .attr(&quot;y&quot;, function(d){return height - yScale(d) + 15 ;})
                                                .attr(&quot;opacity&quot;, function(){ &#x2F;&#x2F;Show the label only if it fits the bar
                                                                    if (this.getComputedTextLength() &lt;= barWidth){
                                                                        return 1;
                                                                    }else{
                                                                        return 0;
                                                                    }
                                                                });                                                
                                                
                                    }else{
                                        labelsSet.remove();
                                    }						
                                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});	
                    
		basicBarChartSharedPrototype.addProtectedMethod(&quot;__refreshDrawing__&quot;,
            &#x2F;** __refreshDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                
                Called by __redrawAll__() to redraw all the data-related drawings, once for
                every data subcomponent.&lt;br&gt;
                The difference with __updateDrawing__ is that the latter is incremental with respect to 
                __drawNewData__ and updates only the properties used to provide animations of the drawing,
                while this method redraws from scratch the data.
                &lt;br&gt;
                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                            this method following __updateDrawing__  behaviour in order to obtain a custom chart.

                            
                
                @method __refreshDrawing__
                @since 0.2
                @protected
                @param {Object} dataSet [Mandatory]
                                The set of svg elements created so far to represent the data;&lt;br&gt;
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;: this parameter should be generated by an appropriate
                                                call to __selectData__;
                @param {Object} labelsSet [Mandatory]
                                    The set of svg elements created so far to represent the labels of the data;&lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;: this parameter should be generated by an appropriate
                                                    call to __selectLabels__; 
                @param {Number} dataIndex   [Mandatory]
                                            The index of the component of the data which is to be drawn;
                @param {Object} xScale  [Mandatory]
                                D3 scale object for X axis;
                @param {Object} yScale  [Mandatory]
                                D3 scale object for Y axis (specific to current component);
                @return {undefined}
              *&#x2F;
            function __refreshDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale){
                var that = this;
                var height = this.__getChartAreaHeight__();
                var barWidth =  this.getBarWidth(xScale);
                
                dataSet.transition()
                    .attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex);})
                    .attr(&quot;y&quot;, function(d){return height - yScale(d);})
                    .attr(&quot;width&quot;, barWidth)
                    .attr(&quot;height&quot;, function(d){return yScale(d);})
                    .attr(&quot;fill&quot;, that.getBarsFillColor(dataIndex))
                    .attr(&quot;stroke&quot;, that.getBarsStrokeColor(dataIndex))
                    .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});                    
                    
                
                if (that.areLabelsVisible(dataIndex)){
                    labelsSet.transition()
                        .text(function(d) {return that.__makeLabel__(d, dataIndex);})
                        .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                        .attr(&quot;x&quot;, function(d, i){return xScale(i * that.__dataDim__ + dataIndex) + barWidth &#x2F; 2;})
                        .attr(&quot;y&quot;, function(d){return height - yScale(d) + 15 ;})
                        .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                        .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                        .attr(&quot;fill&quot;, that.getLabelColor(dataIndex))
                        .attr(&quot;opacity&quot;, function(){  &#x2F;&#x2F;Show the label only if it fits the bar
                                            if (this.getComputedTextLength() &lt;= barWidth){
                                                return 1;
                                            }else{
                                                return 0;
                                            }
                                        });                                         
                }else{
                    labelsSet.remove();
                }
                    
                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
            });                
                    
			Object.defineProperty(basicBarChartSharedPrototype, &quot;__onClearData__&quot;, {
            
                                &#x2F;** __onClearData__(n)
                                    
                                    Takes care of the remaining details related to the removal of part of the values from the chart,
                                    based on to the particular chart needs.&lt;br&gt;
                                    &lt;br&gt;
                                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    Inherited objects MIGHT NEED to override this function.
                                    
                                    @method __onClearData__
                                    @protected
                                    @param {Number} [n]   [Mandatory]
                                                          Must be a positive Integer, or a value that
                                                          can be converted to a positive Integer;
                                                          Number of elements removed from the chart
                                    @return {undefined}
                                  *&#x2F;
                        value:	function(n){
                                    &#x2F;&#x2F;Do nothing: for this object no special action required (but it&#x27;s required to be in the class interface)
                                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});		
                    
			Object.defineProperty(basicBarChartSharedPrototype, &quot;__clearDrawing__&quot;, {            
                                &#x2F;** __clearDrawing__(dataSet, labelsSet)
                                    
                                    Removes the svg objects related to the data cleared by the caller (clearData).
                                    
                                    @method __clearDrawing__
                                    @protected

                                    
                                    @param {Object} dataSet [Mandatory]
                                                            List of drawing objects (default: rects) representing data
                                    @param {Object} labelsSet   [Mandatory]
                                                                List of labels related to data removed
                                    @return {undefined}
                                  *&#x2F;
                        value:	function(dataSet, labelsSet){
                                    dataSet.remove();
                                    labelsSet.remove();	
                                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                },
						writable: false,
						enumerable: false,
						configurable:false
					});	   

&#x2F;&#x2F;HORIZONTAL AXE
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__clearHorizontalAxe__&quot;,
            &#x2F;**  __clearHorizontalAxe__()
              *  Clear all the drawings related to the horizontal axe.
              * 
              *  @method __clearHorizontalAxe__
              *  @since 0.2
              *  @protected
              *  @return {undefined}        
              *  @throws {TypeError} If attribute __horizontalAxe__ is invalid.
              *&#x2F;
            function __clearHorizontalAxe__(){   
                if (this.__horizontalAxe__ === null){
                    return ;
                }
                &#x2F;&#x2F;Clear previous axes
                var axe = this.__horizontalAxe__.svgElement;
                axe.selectAll(&quot;line&quot;).remove();
                axe.selectAll(&quot;text&quot;).remove();
                axe.selectAll(&quot;svg&quot;).remove();
                return ;
            });
            
            
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__drawHorizontalAxeTitle__&quot;,     
                &#x2F;** __drawHorizontalAxeTitle__(axe, width, x, y)
                  *  
                  *  Draws the horizontal axe&#x27;s title.
                  *
                  *  @method __drawHorizontalAxeTitle__
                  *  @since 0.2
                  *  @protected
                  *  @param {Object} axe [Mandatory]
                  *                      The object storing horizontal axe&#x27;s properties.
                  *  @param {Number} width [Mandatory]
                                            The width of the title label (tipically the same width as the axe).          
                  *  @param {Number} x [Mandatory]
                  *                    The x coordinate for the title label.
                  *  @param {Number} y [Mandatory]
                  *                    The y coordinate for the title label.
                  *  @return {undefined}        
                  *  @throws {TypeError} If axe is invalid.
                  *&#x2F;        
                function __drawHorizontalAxeTitle__(axe, width, x, y){
                
                    axe.svgElement
                       .append(&quot;svg&quot;)
                       .attr(&quot;x&quot;, x)
                       .attr(&quot;y&quot;, y)
                       .attr(&quot;width&quot;, width)
                       .attr(&quot;height&quot;, axe.titleSize + LEGEND_MARGIN);

                    &#x2F;* No need to overwrite labels for horizontal axe
                    axe.svgElement.select(&quot;svg&quot;)   
                       .append(&quot;rect&quot;)
                       .attr(&quot;fill&quot;, this.getOuterBackgroundColor())
                       .attr(&quot;x&quot;, 0)
                       .attr(&quot;y&quot;, 0)
                       .attr(&quot;width&quot;, width)
                       .attr(&quot;height&quot;, axe.titleSize + LEGEND_MARGIN); *&#x2F;                              
                    axe.svgElement.select(&quot;svg&quot;)   
                       .append(&quot;text&quot;)
                       .attr(&quot;type&quot;, &quot;axe_title&quot;)
                       .text(axe.title)
                       .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                       .attr(&quot;x&quot;, width &#x2F; 2)&#x2F;&#x2F; LEGEND_MARGIN &#x2F; 2)
                       .attr(&quot;y&quot;, axe.titleSize)
                       .attr(&quot;fill&quot;, axe.titleColor)
                       .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                       .attr(&quot;font-size&quot;, axe.titleSize);                  
                });
                
        &#x2F;** __drawHorizontalAxe__([title, titleSize, titleColor])
          *  
          *  Draws the horizontal axe.
          *
          *  @method __drawHorizontalAxe__
          *  @since 0.2
          *  @protected
          *  @return {undefined}        
          *  @throws {TypeError} If attribute __horizontalAxe__ is invalid.
          *&#x2F;
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__drawHorizontalAxe__&quot;,
            
            function __drawHorizontalAxe__(){
                var axe = this.__horizontalAxe__;
                
                if (axe === null){
                    return ;
                }
                var width = axe.svgElement.attr(&quot;width&quot;), 
                    height = axe.svgElement.attr(&quot;height&quot;), 
                    notchStep = width &#x2F; (axe.notches + 1);
                
                switch (axe.side){
                    case &quot;bottom&quot;:
                        &#x2F;&#x2F;Notches
                        axe.svgElement.selectAll(&quot;line&quot;).data(d3.range(axe.notches + 2))
                                                        .enter()
                                                        .append(&quot;svg:line&quot;)
                                                        .attr(&quot;x1&quot;, function(d,i){
                                                                        return  i * notchStep;
                                                                    })
                                                        .attr(&quot;y1&quot;, 0)
                                                        .attr(&quot;x2&quot;, function(d,i){
                                                                        return  i * notchStep;
                                                                    })
                                                        .attr(&quot;y2&quot;, NOTCH_LINE_LENGTH)
                                                        .attr(&quot;stroke&quot;, axe.color)
                                                        .attr(&quot;stroke-width&quot;, axe.lineWidth);
                        &#x2F;&#x2F;Horizontal line                                
                        axe.svgElement.append(&quot;svg:line&quot;)
                                .attr(&quot;x1&quot;, 0)
                                .attr(&quot;y1&quot;, 0)
                                .attr(&quot;x2&quot;, width)
                                .attr(&quot;y2&quot;, 0)
                                .attr(&quot;stroke&quot;, axe.color)
                                .attr(&quot;stroke-width&quot;, axe.lineWidth);
                        &#x2F;&#x2F;Axe Title
                        if (!Object.isUndefined(axe.title)){
                            this.__drawHorizontalAxeTitle__(axe, width, 0, height - axe.titleSize - LEGEND_MARGIN);
                        }
                        break;
                    case &quot;top&quot;:
                        &#x2F;&#x2F;Notches
                        axe.svgElement.selectAll(&quot;line&quot;).data(d3.range(axe.notches + 2))
                                                        .enter()
                                                        .append(&quot;svg:line&quot;)
                                                        .attr(&quot;x1&quot;, function(d,i){
                                                                        return  i * notchStep;
                                                                    })
                                                        .attr(&quot;y1&quot;, height - NOTCH_LINE_LENGTH)
                                                        .attr(&quot;x2&quot;, function(d,i){
                                                                        return  i * notchStep;
                                                                    })
                                                        .attr(&quot;y2&quot;, height)
                                                        .attr(&quot;stroke&quot;, axe.color)
                                                        .attr(&quot;stroke-width&quot;, axe.lineWidth);                                                        
                        &#x2F;&#x2F;Vertical line                         
                        axe.svgElement.append(&quot;svg:line&quot;)
                                .attr(&quot;x1&quot;, 0)
                                .attr(&quot;y1&quot;, height)
                                .attr(&quot;x2&quot;, width)
                                .attr(&quot;y2&quot;, height)
                                .attr(&quot;stroke&quot;, axe.color)
                                .attr(&quot;stroke-width&quot;, axe.lineWidth);
                         
                        &#x2F;&#x2F;Axe Title
                        if (!Object.isUndefined(axe.title)){
                            this.__drawHorizontalAxeTitle__(axe, width, 0, LEGEND_MARGIN);
                        }
                        break; 
                    default:
                        throw new TypeError(&quot;__verticalAxe__ object is invalid&quot;);
                }
            });
            
            
&#x2F;&#x2F;VERTICAL AXE            
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__clearVerticalAxe__&quot;,
            &#x2F;**  __clearVerticalAxe__()
              *  Clear all the drawings related to the vertical axe.
              * 
              *  @method __clearVerticalAxe__
              *  @since 0.2
              *  @protected
              *  @return {undefined}        
              *  @throws {TypeError} If attribute __verticalAxe__ is invalid.
              *&#x2F;
            function __clearVerticalAxe__(){   
                if (this.__verticalAxe__ === null){
                    return ;
                }
                &#x2F;&#x2F;Clear previous axes
                var axe = this.__verticalAxe__.svgElement;
                axe.selectAll(&quot;line&quot;).remove();
                axe.selectAll(&quot;text&quot;).remove();
                axe.selectAll(&quot;svg&quot;).remove();
                return ;
            });
            
            
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__drawVerticalAxeTitle__&quot;,     
                &#x2F;** __drawVerticalAxeTitle__(axe, height, x, y, textAngle, textX ,textPivot)
                  *  
                  *  Draws the vertical axe&#x27;s title.
                  *
                  *  @method __drawVerticalAxeTitle__
                  *  @since 0.2
                  *  @protected
                  *  @param {Object} axe [Mandatory]
                  *                      The object storing vertical axe&#x27;s properties.
                  *  @param {Number} height [Mandatory]
                                            The height of the title label (tipically the same height as the axe).          
                  *  @param {Number} x [Mandatory]
                  *                    The x coordinate for the title label.
                  *  @param {Number} y [Mandatory]
                  *                    The y coordinate for the title label.
                  *  @param {Number} textAngle [Mandatory]
                  *                        The textAngle for the rotation of the title label.&lt;br&gt;
                  *                        It can be + or - 90 degrees: together with x, y, textX and textPivot parameters,
                  *                        this allows to reuse this method for both left and right axes.
                  *  @param {Number} textX [Mandatory]
                  *                        Internally computed.&lt;br&gt;
                  *                        X position of the axe&#x27;s title.
                  *  @param {Number} textPivot [Mandatory]
                  *                        Internally computed.&lt;br&gt;
                  *                        X position of the pivot point around whom the axe title has to be rotated.
                  *  @return {undefined}        
                  *  @throws {TypeError} If axe is invalid.
                  *&#x2F;        
                function __drawVerticalAxeTitle__(axe, height, x, y, textAngle, textX, textPivot){
                
                    axe.svgElement
                       .append(&quot;svg&quot;)
                       .attr(&quot;x&quot;, x)
                       .attr(&quot;y&quot;, 0)
                       .attr(&quot;width&quot;, axe.titleSize + LEGEND_MARGIN)
                       .attr(&quot;height&quot;, height);

                    axe.svgElement.select(&quot;svg&quot;)   
                       .append(&quot;rect&quot;)
                       .attr(&quot;fill&quot;, this.getOuterBackgroundColor())
                       .attr(&quot;x&quot;, 0)
                       .attr(&quot;y&quot;, 0)
                       .attr(&quot;width&quot;, axe.titleSize)
                       .attr(&quot;height&quot;, height);                               
                    axe.svgElement.select(&quot;svg&quot;)   
                       .append(&quot;text&quot;)
                       .attr(&quot;type&quot;, &quot;axe_title&quot;)
                       .text(axe.title)
                       .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                       .attr(&quot;x&quot;, textX)&#x2F;&#x2F; LEGEND_MARGIN &#x2F; 2)
                       .attr(&quot;y&quot;, y)
                       .attr(&quot;transform&quot;, &quot;rotate(&quot; + textAngle + &quot; &quot; + textPivot + &quot;,&quot; + y + &quot;)&quot;)&#x2F;&#x2F;(LEGEND_MARGIN&#x2F;2)
                       .attr(&quot;fill&quot;, axe.titleColor)
                       .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                       .attr(&quot;font-size&quot;, axe.titleSize);                  
                });
                
        &#x2F;** __drawVerticalAxe__([title, titleSize, titleColor])
          *  
          *  Draws the vertical axe.
          *
          *  @method __drawVerticalAxe__
          *  @since 0.2
          *  @protected
          *  @return {undefined}        
          *  @throws {TypeError} If attribute __verticalAxe__ is invalid.
          *&#x2F;
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__drawVerticalAxe__&quot;,
            
            function __drawVerticalAxe__(){
                var axe = this.__verticalAxe__;
                
                if (axe === null){
                    return ;
                }
                var width = axe.svgElement.attr(&quot;width&quot;), 
                    height = axe.svgElement.attr(&quot;height&quot;), 
                    notchStep = height &#x2F; (axe.notches + 1);
                
                switch (axe.side){
                    case &quot;right&quot;:
                        &#x2F;&#x2F;Notches
                        axe.svgElement.selectAll(&quot;line&quot;).data(d3.range(axe.notches + 2))
                                                        .enter()
                                                        .append(&quot;svg:line&quot;)
                                                        .attr(&quot;x1&quot;, 0)
                                                        .attr(&quot;y1&quot;, function(d,i){
                                                                        return  i * notchStep;
                                                                    })
                                                        .attr(&quot;x2&quot;, NOTCH_LINE_LENGTH)
                                                        .attr(&quot;y2&quot;, function(d,i){
                                                                        return  i * notchStep;
                                                                    })
                                                        .attr(&quot;stroke&quot;, axe.color)
                                                        .attr(&quot;stroke-width&quot;, axe.lineWidth);
                        &#x2F;&#x2F;Vertical line                                
                        axe.svgElement.append(&quot;svg:line&quot;)
                                .attr(&quot;x1&quot;, 0)
                                .attr(&quot;y1&quot;, 0)
                                .attr(&quot;x2&quot;, 0)
                                .attr(&quot;y2&quot;, height)
                                .attr(&quot;stroke&quot;, axe.color)
                                .attr(&quot;stroke-width&quot;, axe.lineWidth);
                        &#x2F;&#x2F;Axe Title
                        if (!Object.isUndefined(axe.title)){
                            this.__drawVerticalAxeTitle__(axe, height, width - axe.titleSize - LEGEND_MARGIN, height &#x2F; 2, 
                                                          90, LEGEND_MARGIN &#x2F; 2, LEGEND_MARGIN &#x2F; 2);
                        }
                        break;
                    case &quot;left&quot;:
                        &#x2F;&#x2F;Notches
                        axe.svgElement.selectAll(&quot;line&quot;).data(d3.range(axe.notches + 2))
                                                        .enter()
                                                        .append(&quot;svg:line&quot;)
                                                        .attr(&quot;x1&quot;, width - NOTCH_LINE_LENGTH)
                                                        .attr(&quot;y1&quot;, function(d,i){
                                                                        return  i * notchStep;
                                                                    })
                                                        .attr(&quot;x2&quot;, width)
                                                        .attr(&quot;y2&quot;, function(d,i){
                                                                        return  i * notchStep;
                                                                    })
                                                        .attr(&quot;stroke&quot;, axe.color)
                                                        .attr(&quot;stroke-width&quot;, axe.lineWidth);                                                        
                        &#x2F;&#x2F;Vertical line                         
                        axe.svgElement.append(&quot;svg:line&quot;)
                                .attr(&quot;x1&quot;, width)
                                .attr(&quot;y1&quot;, 0)
                                .attr(&quot;x2&quot;, width)
                                .attr(&quot;y2&quot;, height)
                                .attr(&quot;stroke&quot;, axe.color)
                                .attr(&quot;stroke-width&quot;, axe.lineWidth);
                         
                        &#x2F;&#x2F;Axe Title
                        if (!Object.isUndefined(axe.title)){
                            this.__drawVerticalAxeTitle__(axe, height, 1, height &#x2F; 2, -90, 0 , axe.titleSize);
                        }
                        break; 
                    default:
                        throw new TypeError(&quot;__verticalAxe__ object is invalid&quot;);
                }
            });
                                
                    
                    
			Object.defineProperty(basicBarChartSharedPrototype, &quot;__getBarOpacity__&quot;, {
                            &#x2F;** __getBarOpacity__(val)
                                
                                 Computes and return the suggested value for the opacity of the bar
                                drawn to represent a certain value.
                                      
                                @method __getBarOpacity__
                                @protected
                                @param {Number} val [Mandatory]
                                            The value to be represented;&lt;br&gt;
                                            Accepts only normalized values (scaled between 0 and 1).&lt;br&gt;
                                            &lt;b&gt;INVARIANT&lt;&#x2F;b&gt;:  to avoid defensive programming,
                                                                it is assumed 0 &lt;= val &lt;=1                               
                                @return {Number}    The opacity to apply to the value representation in the chart.
                              *&#x2F;            
					value:	function(val){
								return 0.25 + val * 0.75;
							},
						writable: false,
						enumerable: false,
						configurable:false
					});

                    
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__makeLabel__&quot;, 
                        &#x2F;** __makeLabel__(val [index, forceAbbreviate])

                            Converts an input number to 
                            
                            @method __makeLabel__
                            @since 0.2
                            @protected
                            @param {Number} val [Mandatory]
                                                The value that must be used in the label.
                            @param {Number} [index=0] [Optional]
                                                The index of the subcomponent of the data.                                                 
                            @param {Boolean} [forceAbbreviate=false] [Optional]
                                             Should the label be coercefully abbreviated?                                                
                            @return {String} The properly formatted text for the label.
                          *&#x2F;
                        function(val, index, forceAbbreviate){

                            &#x2F;&#x2F;INVARIANT: if passed, index is a non-negative integer in the range 0..__dataDim__
                            &#x2F;&#x2F;           (We avoid defensive programming and omit checks)
                            try{
                                if ((forceAbbreviate || (!Object.isUndefined(index) &amp;&amp; 
                                                    this.__abbreviatedLabels__[index])) &amp;&amp; 
                                     Object.isNumber(val)){
                                    
                                            return ChartUtils.abbreviateNumber(val);
                                }else{
                                            return val;
                                }
                            }catch(e){
                                &#x2F;&#x2F;console.log(e);
                                return val;
                            }
                        });                      
                    
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__updateBackground__&quot;, 
                        &#x2F;** __updateBackground__()
                            
                            
                            Called by __drawNewData__() to redraw the background properly;&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override
                                               this method as well as __drawNewData__ and __updateDrawing__ 
                                               in order to obtain a custom chart.
                            
                            @method __updateBackground__
                            @protected
                            @return {undefined}
                          *&#x2F;
                        function(){
                            &#x2F;&#x2F;Nothing to do for this class (added to have a coherent interface)                                                                             
                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                        });   
                        
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__redrawInnerBackground__&quot;, 
                        &#x2F;** __redrawInnerBackground__()                            
                            
                            Properly redraws the background of the main chart area &lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override
                                               this method to reflect its expected behaviour.
                            
                            @method __redrawInnerBackground__
                            @protected
                            @return {undefined}
                          *&#x2F;
                        function(){
                            this.__chartArea__.select(&quot;#innerBackground&quot;).attr(&quot;fill&quot;, this.getInnerBackgroundColor());                                                                                  
                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                        });     

                        
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__redrawOuterBackground__&quot;, 
                        &#x2F;** __redrawOuterBackground__()
                            
                            
                            Properly redraws the background of the outer chart area &lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override
                                               this method to reflect its expected behaviour.
                            
                            @method __redrawOuterBackground__
                            @protected
                            @return {undefined}
                          *&#x2F;
                        function(){
                            this.__svgElement__.select(&quot;#outerBackground&quot;).attr(&quot;fill&quot;, this.getOuterBackgroundColor()); 

                            &#x2F;&#x2F;For both axes, must ensure that the title will be repainted accordingly
                            try{    &#x2F;&#x2F;Try, in case it is null
                                this.__verticalAxe__.svgElement.selectAll(&quot;rect&quot;).attr(&quot;fill&quot;, this.getOuterBackgroundColor()); 
                            }catch(e){
                                &#x2F;&#x2F;Nothing to do
                            }                            
                            try{    &#x2F;&#x2F;Try, in case it is null
                                this.__horizontalAxe__.svgElement.selectAll(&quot;rect&quot;).attr(&quot;fill&quot;, this.getOuterBackgroundColor()); 
                            }catch(e){
                                &#x2F;&#x2F;Nothing to do
                            }
                            
                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                        });                            
                        
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__redrawInnerBorder__&quot;, 
                        &#x2F;** __redrawInnerBorder__([border])
                            
                            
                            Properly redraws the border of the inner chart area.
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override
                                               this method to reflect its expected behaviour.                            
                            
                            @method __redrawInnerBorder__
                            @protected
                            @param {Object} [border=__innerBorder__] [Optional]
                                            An object summarizing all the border properties:
                                            &lt;ul&gt;
                                                &lt;li&gt;&lt;b&gt;fill&lt;&#x2F;b&gt;: The color of the border;&lt;&#x2F;li&gt;
                                                &lt;li&gt;&lt;b&gt;width&lt;&#x2F;b&gt;: The width of the border line, in pixels;&lt;&#x2F;li&gt;
                                                &lt;li&gt;&lt;b&gt;dash&lt;&#x2F;b&gt;: The dash pattern of the line&lt;&#x2F;li&gt;
                                            &lt;&#x2F;ul&gt;
                                            By default, if border is omitted, the chart&#x27;s __innerBorder__ attribute is used.
                            @return {undefined}
                          *&#x2F;
                        function(border){ 
                            if (Object.isUndefined(border)){
                                border = this.__innerBorder__;
                            }                        
                            &#x2F;&#x2F;INVARIANT: border is a valid Object
                            &#x2F;&#x2F;           Protected function: no checking to avoid defensive programming
                            this.__chartArea__.select(&quot;#innerBackground&quot;)
                                              .attr(&quot;stroke&quot;, border.fill)
                                              .attr(&quot;stroke-width&quot;, border.width)
                                              .attr(&quot;stroke-dasharray&quot;, border.dash);
                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                        });
                        
        basicBarChartSharedPrototype.addProtectedMethod(&quot;__redrawOuterBorder__&quot;, 
                        &#x2F;** __redrawOuterBorder__([border])
                            
                            
                            Properly redraws the border of the outer chart area.
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override
                                               this method to reflect its expected behaviour.                            
                            
                            @method __redrawOuterBorder__
                            @protected
                            @param {Object} [border=__outerBorder__] [Optional]
                                            An object summarizing all the border properties:
                                            &lt;ul&gt;
                                                &lt;li&gt;&lt;b&gt;fill&lt;&#x2F;b&gt;: The color of the border;&lt;&#x2F;li&gt;
                                                &lt;li&gt;&lt;b&gt;width&lt;&#x2F;b&gt;: The width of the border line, in pixels;&lt;&#x2F;li&gt;
                                                &lt;li&gt;&lt;b&gt;dash&lt;&#x2F;b&gt;: The dash pattern of the line&lt;&#x2F;li&gt;
                                            &lt;&#x2F;ul&gt;
                                            By default, if border is omitted, the chart&#x27;s __outerBorder__ attribute is used.
                            @return {undefined}
                          *&#x2F;
                        function(border){ 
                            if (Object.isUndefined(border)){
                                border = this.__outerBorder__;
                            }
                            &#x2F;&#x2F;INVARIANT: border is a valid Object
                            &#x2F;&#x2F;           Protected function: no checking to avoid defensive programming
                            this.__svgElement__.select(&quot;#outerBackground&quot;)
                                              .attr(&quot;stroke&quot;, border.fill)
                                              .attr(&quot;stroke-width&quot;, border.width)
                                              .attr(&quot;stroke-dasharray&quot;, border.dash);                                                                                  
                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                        });                        
                        
			basicBarChartSharedPrototype.addProtectedMethod(&quot;__getWidth__&quot;,
                            &#x2F;** __getWidth__()
                                
                                Return the width of the drawing area for the chart.
                                      
                                @method __getWidth__
                                @protected        
                                @return {Number} The total width of the chart.
                              *&#x2F;            
                            function(){
								return parseInt(this.__svgElement__.attr(&quot;width&quot;), 10);
							});    
                            
			basicBarChartSharedPrototype.addProtectedMethod(&quot;__getHeight__&quot;,
                            &#x2F;** __getHeight__()
                                
                                Return the height of the drawing area for the chart.
                                      
                                @method __getHeight__
                                @protected        
                                @return {Number} The total height of the chart.
                              *&#x2F;            
                            function(){
								return parseInt(this.__svgElement__.attr(&quot;height&quot;), 10);
							});	
                            
			basicBarChartSharedPrototype.addProtectedMethod(&quot;__getChartAreaWidth__&quot;,
                            &#x2F;** __getChartAreaWidth__()
                                
                                Return the width of the drawing area for the chart.
                                      
                                @method __getChartAreaWidth__
                                @protected        
                                @return {Number} The width of the drawing area for the chart.
                              *&#x2F;            
                            function(){
								return parseInt(this.__chartArea__.attr(&quot;width&quot;), 10);
							});
                            
			basicBarChartSharedPrototype.addProtectedMethod(&quot;__getChartAreaHeight__&quot;,
                            &#x2F;** __getChartAreaHeight__()
                                
                                Return the height of the drawing area for the chart.
                                      
                                @method __getChartAreaHeight__
                                @protected        
                                @return {Number} The height of the drawing area for the chart.
                              *&#x2F;            
                            function(){
								return parseInt(this.__chartArea__.attr(&quot;height&quot;), 10);
							});	   
            basicBarChartSharedPrototype.addProtectedMethod(&quot;__decodeCSSMultivalueString__&quot;,
                            &#x2F;** __decodeCSSMultivalueString__(str, undefinedOnMiss)
                            
                                @method __decodeCSSMultivalueString__
                                @protected
                                @param {String} str [Mandatory]
                                                A string representing a CSS property with 4 possible subfields, as for margins or border-width:
                                                &lt;b&gt;top, right, bottom and left&lt;&#x2F;b&gt;.&lt;br&gt;
                                                
                                                Unless undefinedOnMiss is passed and it&#x27;s truthy, the format of the string 
                                                is the same as for CSS margin; it can therefore be one of the following:
                                                &lt;ul&gt;
                                                    &lt;li&gt;&quot;&quot;&lt;br&gt;No margin is set&lt;&#x2F;li&gt;
                                                    &lt;li&gt;&quot;top-bottom-right-left;&quot;&lt;br&gt;All 4 subfields are set to the same value&lt;&#x2F;li&gt;
                                                    &lt;li&gt;&quot;top-bottom right-left;&quot;&lt;br&gt;Top and bottom and right and left subfields have the same value&lt;&#x2F;li&gt;
                                                    &lt;li&gt;&quot;top right-left bottom;&quot;&lt;br&gt;right and left subfield are set to the same value&lt;&#x2F;li&gt;
                                                    &lt;li&gt;&quot;top right bottom left;&quot;&lt;br&gt;All 4 subfields are set separately&lt;&#x2F;li&gt;
                                                &lt;&#x2F;ul&gt;
                                @param {Boolean} defaultValue [Optional]
                                                 If it is not passed or it&#x27;s false, the standard CSS format specification for
                                                 multivalue string attributes will be used, as described above.
                                                 Otherwise, if less than 4 values are provided in the string, they are assigned
                                                 to subfields in the order top, right, bottom, left, while for the 
                                                 fields for whom a value isn&#x27;t explicitely inserted, a defaultValue is used.
                                @return {Object}: An object with values for top, right, bottom and left subfields.
                                @throws {Illegal Argument Exception}, if the input string contains more than four values.
                                @throws {Illegal Argument Exception}, if the input string contains no value, 
                                                                      and a default value is not supplied either.
                              *&#x2F;
                            function __decodeCSSMultivalueString__(str, defaultValue){
                                var values = str.match(&#x2F;(\d+(px)?\s+)|(\d+(px)?\s*;$)&#x2F;g); &#x2F;&#x2F;Extract all integers from string
                                var result, val, i;
                                var keys = [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;];
                                
                                if (!values){
                                    if (Object.isUndefined(defaultValue)){
                                        throw &quot;Illegal Arguments: either at least one value or a default value MUST be supplied&quot;;
                                    }
                                    result = {};
                                    if (!Object.isUndefined(defaultValue)){
                                        for (i=0; i &lt; 4; i++){
                                            result[keys[i]] = defaultValue;
                                        }
                                    }
                                    return result;
                                }else{
                                    values = values.map(function(s){return parseInt(s,10);});
                                }
                                

                                if (!Object.isUndefined(defaultValue)){
                                    if (values.length &gt; 4){
                                        throw &quot;Illegal Argument Exception: CSS string contains too many values.&quot;;
                                    }
                                    
                                    result = {};
                                    for (i = 0; i &lt; values.length; i++){
                                        result[keys[i]] = values[i];
                                    }
                                    for (; i &lt; 4; i++){
                                        result[keys[i]] = defaultValue;
                                    }
                                }else{
                                    switch (values.length){
                                        case 0:
                                            result = {};
                                            break;
                                        case 1:
                                            val = values[0];
                                            result = {&quot;top&quot;: val, &quot;right&quot;:val, &quot;bottom&quot;: val, &quot;left&quot;: val};
                                            break;
                                        case 2:
                                            result = {&quot;top&quot;: values[0], &quot;right&quot;: values[1], &quot;bottom&quot;: values[0], &quot;left&quot;: values[1]};
                                            break;
                                        case 3:
                                            result = {&quot;top&quot;: values[0], &quot;right&quot;: values[1], &quot;bottom&quot;: values[2], &quot;left&quot;: values[1]};
                                            break; 
                                        case 4:
                                            result = {&quot;top&quot;: values[0], &quot;right&quot;: values[1], &quot;bottom&quot;: values[2], &quot;left&quot;: values[3]};
                                            break;    
                                        default:    &#x2F;&#x2F;More than 4 values defined
                                            throw &quot;Illegal Argument Exception: CSS string contains too many values.&quot;;      
                                    }
                                }
                                return result;
                            });
                            
            basicBarChartSharedPrototype.addProtectedMethod(&quot;__encodeCSSMultivalueString__&quot;,
                            &#x2F;** __encodeCSSMultivalueString__(str, undefinedOnMiss)
                            
                                @method __encodeCSSMultivalueString__
                                @protected
                                @param {Object} obj [Mandatory]
                                                An object storing the values for the property.&lt;br&gt;
                                                Fields top, right, bottom, left are checked in order: as soon as
                                                one is missing, no more data will be added to the string
                                                
                                @return {String}: A string with a proper representation of the property.
                                @throws {Illegal Argument Exception}, if the input string contains more than four values.
                              *&#x2F;
                            function __encodeCSSMultivalueString__(obj){
                                var values = [];
                                var i, keys = [&quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;];
    

                                for (i=0; i &lt; 4; i++){
                                    try{
                                        values.push(obj[keys[i]]);
                                    }catch(e){
                                        break;
                                    }
                                }
                                if (values.length &gt; 0){
                                    return values.join(&quot; &quot;) + &quot;;&quot;;  &#x2F;&#x2F;Need to add a final semicolon
                                }else{
                                    return &quot;&quot;;
                                }
                            });
                            
            basicBarChartSharedPrototype.addProtectedMethod(&quot;__updateAxes__&quot;, 
                &#x2F;** __updateAxes__(yScale)
               
                    Called by __updateDrawing__() to update the labels of the vertical axe
                    when vertical scale changes;&lt;br&gt;
                    &lt;br&gt;
                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:     if you inherit from this class you might want to override
                                        this method as well as __drawNewData__ and __updateDrawing__ 
                                        in order to obtain a custom chart.
                              
                    @method __updateAxes__
                    @protected
                    @chainable
                    @param {Object} yScale  [Mandatory]
                                            D3 scale object for Y axis;
                    @return {Object}    The current chart object, to allow for method chaining.
                  *&#x2F;
                function __updateAxes__(yScale){
                        var vAxe = this.__verticalAxe__;
                        var i, notches;
                        var axeLabels, m,
                            anchor,
                            labels,
                            x,
                            height,
                            that = this;
                        &#x2F;&#x2F;VERTICAL AXE
                        if (vAxe){
                            if (this.__scaleGlobally__ || this.__dataDim__ === 1){
                                &#x2F;&#x2F;If data is drawn with a global scaling, or there is only one subcomponent,
                                &#x2F;&#x2F;then Vertical axe CAN BE DRAWN
                                m = this.__maxVals__.max();
                                notches = vAxe.notches;
                                axeLabels = [m];
                                for (i = notches; i &gt; 0; i--){
                                    axeLabels.push(m * i &#x2F; (notches + 1));
                                }
                                axeLabels.push(0);
                            }else{
                                &#x2F;&#x2F;If data is drawn with local scaling for each component
                                &#x2F;&#x2F;then Vertical axe WOULD HAVE NO MEANING
                                axeLabels = [];
                            }
                            
                            labels = vAxe.svgElement.selectAll(&quot;text[type=axe_label]&quot;).data(axeLabels);
                            height = vAxe.svgElement.attr(&quot;height&quot;);
                            
                            if (vAxe.side === &quot;right&quot;){
                                x = NOTCH_LINE_LENGTH;
                                anchor = &quot;start&quot;;
                            }else{
                                x = vAxe.svgElement.attr(&quot;width&quot;) - NOTCH_LINE_LENGTH;
                                anchor = &quot;end&quot;;
                            }
                            
                            labels.exit().remove();
                            labels.enter().insert(&quot;text&quot;, &quot;svg&quot;)    &#x2F;&#x2F;Insert before svg block
                                    .attr(&quot;type&quot;, &quot;axe_label&quot;)
                                    .attr(&quot;text-anchor&quot;, anchor)
                                    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                    .attr(&quot;font-size&quot;, vAxe.labelSize);
                            
                            labels.text(function(d){return that.__makeLabel__(d, undefined, true);})
                                  .attr(&quot;x&quot;, x)
                                  .attr(&quot;y&quot;, function(d){return Math.max(vAxe.labelSize *0.75, 
                                                                         Math.min(height, height - yScale(d) + vAxe.labelSize * 0.375));})
                                  .attr(&quot;fill&quot;, vAxe.color);
                            
                        }    
                        
                        return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this    
                });                            
                            
			basicBarChartSharedPrototype.addProtectedMethod(&quot;__initAxes__&quot;,
                            &#x2F;** __initAxes__(width, height)
                                
                                Inits the 4 axes surrounding the chart main area according to the specific chart type.&lt;br&gt;
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;: This method SHOULD be overridden in any inheriting class.&lt;br&gt;
                                This method sets only those properties of the four axes that are peculiar to this chart
                                and that can be set:
                                &lt;ul&gt;
                                    &lt;li&gt;For top and bottom axes, only height can be set (their width is the same as the svg containing element)&lt;&#x2F;li&gt;
                                    &lt;li&gt;For left and right axes, only width can be set (their height is the same as the main chart area)&lt;&#x2F;li&gt;
                                &lt;&#x2F;ul&gt;

                                @method __initAxes__
                                @protected         
                                @param {Number} width [Mandatory]
                                                The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                                Can be any value that is or can be converted to a positive integer.
                                @param {Number} height [Mandatory]
                                                The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                                Can be any value that is or can be converted to a positive integer.                                
                                                
                                @return {undefined}
                              *&#x2F;            
                            function(width, height){
                                
                                this.__svgElement__.insert(&quot;rect&quot;, &quot;#chart_area&quot;)   &#x2F;&#x2F;Insert before the chart main area
                                                  .attr(&quot;id&quot;,&quot;outerBackground&quot;)
                                                  .attr(&quot;width&quot;, width)
                                                  .attr(&quot;height&quot;, height)
                                                  .attr(&quot;x&quot;, 0)
                                                  .attr(&quot;y&quot;, 0);
                                
                                var chartWidth = width - this.__margins__.left - this.__margins__.right - 2,
                                    chartHeight = height - this.__margins__.top - this.__margins__.bottom - 2;
                                
                                &#x2F;&#x2F;Top axe
                                this.__axeTop__.attr(&quot;width&quot;, chartWidth)
                                               .attr(&quot;height&quot;, this.__margins__.top)
                                               .attr(&quot;x&quot;, this.__margins__.left)
                                               .attr(&quot;y&quot;, 0);
                                &#x2F;&#x2F;Right Axe
                                this.__axeRight__.attr(&quot;width&quot;, this.__margins__.right)   
                                                 .attr(&quot;height&quot;, chartHeight)  
                                                 .attr(&quot;x&quot;, width - this.__margins__.right)
                                                 .attr(&quot;y&quot;, this.__margins__.top + 1);
                                &#x2F;&#x2F;Bottom axe
                                this.__axeBottom__.attr(&quot;width&quot;, chartWidth)
                                                  .attr(&quot;height&quot;, this.__margins__.bottom)
                                                  .attr(&quot;x&quot;, this.__margins__.left)
                                                  .attr(&quot;y&quot;, height - this.__margins__.bottom);                                
                                &#x2F;&#x2F;Left Axe
                                this.__axeLeft__.attr(&quot;width&quot;, this.__margins__.left)   
                                                .attr(&quot;height&quot;, chartHeight) 
                                                .attr(&quot;x&quot;, 0)
                                                .attr(&quot;y&quot;, this.__margins__.top + 1);                                 
                                
                                &#x2F;&#x2F;Main Chart
                                this.__chartArea__.attr(&quot;width&quot;, chartWidth)
                                                  .attr(&quot;height&quot;, chartHeight)
                                                  .attr(&quot;x&quot;, this.__margins__.left + 1)
                                                  .attr(&quot;y&quot;, this.__margins__.top + 1);
                                                  
                                this.__chartArea__.append(&quot;rect&quot;)
                                                  .attr(&quot;id&quot;,&quot;innerBackground&quot;)
                                                  .attr(&quot;width&quot;, this.__chartArea__.attr(&quot;width&quot;))
                                                  .attr(&quot;height&quot;, this.__chartArea__.attr(&quot;height&quot;))
                                                  .attr(&quot;x&quot;, 0)
                                                  .attr(&quot;y&quot;, 0);
                                 
                                this.__redrawInnerBackground__();
                                this.__redrawOuterBackground__();
                                this.__redrawInnerBorder__();
                                this.__redrawOuterBorder__();
                                                 
                                return ;
							});                            

		Object.freeze(basicBarChartSharedPrototype);

        &#x2F;** BasicBarChart(width, height [, chartMargins, dataDim, parent])
 
            @method BasicBarChart
            @chainable
            
            @param {Number} width [Mandatory]
                            The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} height [Mandatory]
                            The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {String} [chartMargins=&quot;&quot;] [Optional]
                                A String of 0 to 4 space-separated values that specifies the 4 margins of the chart.&lt;br&gt;
                                The string should respect the following format: &lt;b&gt;&quot;top right bottom left;&quot;&lt;&#x2F;b&gt; (notice the trailing semicolon)&lt;br&gt;
                                If less then 4 values are passed, only the covered subfield will be assigned using the input string,
                                while the remaining ones will take a default value specified as an inner attribute of the class.                              
            @param {Number} [dataDim=1] [Optional]
                            The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                            Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
            @param {Object} [parent=body] [Optional]
                            The DOM element to which the diagram should be appended as a child
            @return {Object}    A new BasicBarChart object
            @throws
                                -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                                    (through setWidth or setHeight)
                                -   Illegal Argument exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                -   Exception, if dataDim exceeds the maximum data dimension
                                -   Exception, if parent is passed but it is not a valid DOM element
          *&#x2F;
        function BasicBarChart(width, height, chartMargins, dataDim, parent){
                   
            &#x2F;** __initChart__(width, height [, chartMargins])
                
                Inits the chart DIV and SVG container, setting width and height, if they are passed as arguments;
                
                @method __initChart__
                @private
                
                @param {Object} chart   [Mandatory]
                                The chart object that needs initialization;
                @param {Number} width   [Mandatory]
                                The desired width for the chart;
                                If passed, MUST be a positive integer, or a value that
                                can be converted to a positive integer
                @param {Number} height   [Mandatory]
                                The desired height for the chart;
                                If passed, MUST be a positive integer, or a value that
                                can be converted to a positive integer
                @param {String} [margins] [Optional]
                                A String of 0 to 4 comma-separated valued that specifies the 4 margins of the chart.&lt;br&gt;
                                Omitted margins will get the default margin for this class. 
                @return {undefined}
                @throws     
                            - Inconsitent Chart State Exception, if the internale state of the object is compromised;
                            - Illegal Argument Exception, through setWidth or setHeight, if one of the arguments is
                                not valid.
            *&#x2F;
            function __initChart__(chart, width, height, chartMargins){
                if (!chart.__svgElement__ || !chart.__divElement__){
                    throw &quot;Inconsitent Chart State: null&quot;;
                }
                &#x2F;&#x2F;else
                
                chart.setWidth(width);
                chart.setHeight(height);

                if (Object.isUndefined(chartMargins)){
                    chartMargins = &quot;&quot;;
                }                
                  
                                
                                                    &#x2F;**
                                                        The four margins of the chart object;
                                                        @property __margins__
                                                        @type {Object}
                                                        @readOnly
                                                        @protected                                                      
                                                      *&#x2F;                                    
                Object.defineProperty(chart, &quot;__margins__&quot;, {
                                        value: chart.__decodeCSSMultivalueString__(chartMargins, DEFAULT_AXE_MARGIN),
                                        writable: false,
                                        enumerable: false,
                                        configurable: false
                                    });	                    
                
   
                chart.__initAxes__(width, height);
                
                var __xScale__ = d3.scale.linear().range([0, chart.__getChartAreaWidth__()]);
                var __yScaleGenerator__ = function(){return d3.scale.linear().range([0, chart.__getChartAreaHeight__()]);};   
                
                                                    &#x2F;**
                                                        Scale object for the horizontal axis of the chart 
                                                        (common to all data subcomponents)
                                                        @property __xScale__
                                                        @type {Object}
                                                        @readOnly
                                                        @protected                                                      
                                                      *&#x2F;                                    
                Object.defineProperty(chart, &quot;__xScale__&quot;, {
                                        value: __xScale__,
                                        writable: false,
                                        enumerable: false,
                                        configurable: false
                                    });	                              

                                                    &#x2F;**
                                                        Scale objects for the vertical axis of the chart 
                                                        (array with one obj for each data subcomponents,
                                                         so that each component can be scaled independently)
                                                        @property __yScale__
                                                        @type {Array}
                                                        @readOnly
                                                        @protected
                                                      *&#x2F;                                       
                Object.defineProperty(chart, &quot;__yScale__&quot;, {
                                        value: ChartUtils.fillArray(__yScaleGenerator__, chart.__dataDim__),
                                        writable: false,
                                        enumerable: false,
                                        configurable: false
                                    });            
                
                return;     &#x2F;&#x2F;(Pseudo)private method, no need to retun anything
            }  
            
            &#x2F;** __initData__(basicCharObj [, dataDim])
                
                Performs all the settings related to the data handling area of the chart;
                
                @method __initData__
                @private
                @param {Object} basicCharObj [Mandatory]
                                             The chart object to init;
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues
                                for each data entry;&lt;br&gt;
                                Can take any value that is or can be converted to an integer 
                                between 1 and MAX_SPACE_DIMENSION.
                @return {undefined}   
                @throws
                                    -   Illegal Argument exception, if dataDim is passed but it&#x27;s 
                                        not valid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension                             
               *&#x2F;
            function __initData__(basicCharObj, dataDim){
                if (Object.isUndefined(dataDim)){
                    dataDim = 1;   &#x2F;&#x2F;1 by default
                }else{
                    dataDim = parseInt(dataDim, 10);
                    if (isNaN(dataDim) || dataDim &lt;= 0){
                        throw &quot;Illegal Argument: dataDim&quot;;
                    }else if (dataDim &gt; MAX_SPACE_DIMENSION){
                        throw &quot;Max number of subvalues for each point (&quot; + MAX_SPACE_DIMENSION + &quot;) exceeded&quot;;
                    }
                }            
                  
                                                     &#x2F;** 
                                                         Dimension of the data space, 
                                                         i.e. number of subcomponents of each data &quot;point&quot;
                                                         @property __dataDim__
                                                         @type {Number}
                                                         @readOnly
                                                         @protected                                                         
                                                       *&#x2F;
                Object.defineProperty(basicBarChart, &quot;__dataDim__&quot;, {
                                        value: dataDim,
                                        writable: false,
                                        enumerable: false,
                                        configurable: false
                                    });   
                                            
                                                    &#x2F;** 
                                                        The array that will hold data, separately for each component
                                                        Initially every component&#x27;s array is set to []
                                                         @property __data__
                                                         @type {Array}
                                                         @readOnly
                                                         @protected                                                          
                                                      *&#x2F;
                Object.defineProperty(basicBarChart, &quot;__data__&quot;, {
                                        value: ChartUtils.fillArray(function(){return [];}, basicBarChart.__dataDim__),
                                        writable: false,
                                        enumerable: false,
                                        configurable: false
                                    });
                                                     &#x2F;** 
                                                         Array of maximum values for each component
                                                         (used to compute the vertical scale)&lt;br&gt;
                                                         @property __maxVals__
                                                         @type {Number}
                                                         @readOnly
                                                         @protected                                                           
                                                         @default [0]*
                                                       *&#x2F;
                Object.defineProperty(basicBarChart, &quot;__maxVals__&quot;, {
                                        value: ChartUtils.fillArray(0, basicBarChart.__dataDim__),
                                        writable: false,
                                        enumerable: false,
                                        configurable: false
                                    });      
                                    
                                             
                    &#x2F;** 
                        Keeps track of how much data has been actually inserted into
                        the chart from its creation (to synch the highlighted ticks).
                        
                        @property __dataCounter__
                        @type {Number}
                        @protected
                        @default 0                                                
                      *&#x2F;
            Object.defineProperty(basicBarChart, &quot;__dataCounter__&quot;, {
                                value: 	0,
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });                                    
                
                return;     &#x2F;&#x2F;Private method, no need to return anything
            }
        

            if (Object.isUndefined(width)  || Object.isUndefined(height)){
                throw &quot;Wrong number of arguments: width and height are mandatory&quot;;
            }
            if (Object.isUndefined(parent)){	&#x2F;&#x2F;By default, added to page&#x27;s body
                parent = d3.select(&quot;body&quot;);
            }
            
            
            
            var div = parent.append(&quot;div&quot;).attr(&quot;id&quot;, &quot;dynamic_chart_&quot; + next_id);
            var svg = div.append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;dynamic_chart_&quot; + next_id); &#x2F;&#x2F;NOTE: ++next_id needed after this
            next_id += 1;
            
            var basicBarChart = Object.create(basicBarChartSharedPrototype);
            
            __initData__(basicBarChart, dataDim);
   

                                                &#x2F;** 
                                                    The parent object to whom the chart is added
                                                    @property __parent__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected
                                                  *&#x2F;
            Object.defineProperty(basicBarChart, &quot;__parent__&quot;, {
                                    value: parent,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
            
                                                &#x2F;**
                                                    The div element that will be a container to the chart&#x27;s svg element
                                                    @property __divElement__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                    
                                                  *&#x2F;
            Object.defineProperty(basicBarChart, &quot;__divElement__&quot;, {
                                    value: div,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                                
                                                &#x2F;**
                                                    The chart&#x27;s svg element
                                                    @property __svgElement__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__svgElement__&quot;, {
                                    value: svg,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                                
                                                &#x2F;**
                                                    The svg element for the main chart area
                                                    @property __chartArea__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__chartArea__&quot;, {
                                    value: svg.append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;chart_area&quot;),
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });  
                                                &#x2F;**
                                                    The svg element for the left axe area
                                                    @property __axeLeft__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__axeLeft__&quot;, {
                                    value: svg.append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;axe_left&quot;).attr(&quot;fill&quot;,&quot;none&quot;),
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });   
                                                &#x2F;**
                                                    The svg element for the right axe area
                                                    @property __axeRight__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__axeRight__&quot;, {
                                    value: svg.append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;axe_right&quot;).attr(&quot;fill&quot;,&quot;none&quot;),
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });                                 
                                                &#x2F;**
                                                    The svg element for the top axe area
                                                    @property __axeTop__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__axeTop__&quot;, {
                                    value: svg.append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;axe_top&quot;).attr(&quot;fill&quot;,&quot;none&quot;),
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });   
                                                &#x2F;**
                                                    The svg element for the bottom axe area
                                                    @property __axeBottom__
                                                    @type {Object}
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__axeBottom__&quot;, {
                                    value: svg.append(&quot;svg&quot;).attr(&quot;id&quot;, &quot;axe_bottom&quot;).attr(&quot;fill&quot;,&quot;none&quot;),
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                                
                                                &#x2F;**
                                                    An object describing the Y axe&#x27;s properties, or null if
                                                    it isn&#x27;t supposed to be drawn.&lt;br&gt;
                                                    If assigned, the object must have the following fields:
                                                    &lt;ul&gt;
                                                        &lt;li&gt;side&lt;&#x2F;li&gt; - Can be either &quot;left&quot; or &quot;right&quot;
                                                        &lt;li&gt;svgElement&lt;&#x2F;li&gt; - Can be either __axeLeft__ or __axeRight__
                                                        &lt;li&gt;notches&lt;&#x2F;li&gt; - The number of notches to be shown (Must be a positive integer)
                                                    &lt;&#x2F;ul&gt;
                                                    
                                                    @property __verticalAxe__
                                                    @type {Object}
                                                    @default null
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__verticalAxe__&quot;, {
                                    value: null,
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });                                    
                                                &#x2F;**
                                                    An object describing the X axe&#x27;s properties, or null if
                                                    it isn&#x27;t supposed to be drawn.&lt;br&gt;
                                                    If assigned, the object must have the following fields:
                                                    &lt;ul&gt;
                                                        &lt;li&gt;side&lt;&#x2F;li&gt; - Can be either &quot;top&quot; or &quot;bottom&quot;
                                                        &lt;li&gt;svgElement&lt;&#x2F;li&gt; - Can be either __axeBottom__ or __axeTop__
                                                        &lt;li&gt;notches&lt;&#x2F;li&gt; - The number of notches to be shown (Must be a positive integer)
                                                    &lt;&#x2F;ul&gt;
                                                    
                                                    @property __horizontalAxe__
                                                    @type {Object}
                                                    @default null
                                                    @readOnly
                                                    @protected                                                      
                                                  *&#x2F;                                    
            Object.defineProperty(basicBarChart, &quot;__horizontalAxe__&quot;, {
                                    value: null,
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });                                
                                
                                                 &#x2F;**
                                                    For data space with dimension gt 1, states
                                                    if the different components should scale locally or globally
                                                    @property __scaleGlobally__
                                                    @type {Boolean}
                                                    @protected
                                                    @default true
                                                   *&#x2F;
            Object.defineProperty(basicBarChart, &quot;__scaleGlobally__&quot;, {
                                    value: true,  &#x2F;&#x2F;By default, scales globally
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                }); 

                                                 &#x2F;**
                                                    For each data subcomponent, stores the size to be used
                                                    for its label
                                                    @property __labelsSize__
                                                    @type {Number}
                                                    @readOnly
                                                    @protected
                                                    @default DEFAULT_LABEL_SIZE
                                                  *&#x2F;   
            Object.defineProperty(basicBarChart, &quot;__labelsSize__&quot;, {
                                    value: ChartUtils.fillArray(DEFAULT_LABEL_SIZE, basicBarChart.__dataDim__),
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });		
                                                 &#x2F;**
                                                    For each data subcomponent, states whether or not
                                                    its label is visible
                                                    @property __labelsVisible__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                    @default [true]*
                                                  *&#x2F;                                      
            Object.defineProperty(basicBarChart, &quot;__labelsVisible__&quot;, {
                                    value: ChartUtils.fillArray(true, basicBarChart.__dataDim__),    &#x2F;&#x2F;All labels visible by default
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	
                                
                                                 &#x2F;**
                                                    For each data subcomponent, states whether or not
                                                    its label is abbreviated (as in, f.i., 1.1M instead of 1,123,456)
                                                    @property __abbreviatedLabels__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                    @default [false]*
                                                  *&#x2F;                                      
            Object.defineProperty(basicBarChart, &quot;__abbreviatedLabels__&quot;, {
                                    value: ChartUtils.fillArray(false, basicBarChart.__dataDim__),    &#x2F;&#x2F;All labels visible by default
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });                                
                                
                                
                                                 &#x2F;**
                                                    For each data subcomponent, stores the color to be used
                                                    to fill its drawing component
                                                    @property __barsFillColors__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                  *&#x2F;                                      
            Object.defineProperty(basicBarChart, &quot;__barsFillColors__&quot;, {
                                    value: FILL_COLORS.shallowCopy(basicBarChart.__dataDim__),  &#x2F;&#x2F;Default values
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });

                                                 &#x2F;**
                                                    For each data subcomponent, stores the color to be used
                                                    for the stroke of its drawing component
                                                    @property __barsStrokeColors__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                    @default [&quot;black&quot;]*
                                                  *&#x2F;                                       
            Object.defineProperty(basicBarChart, &quot;__barsStrokeColors__&quot;, {
                                    value: ChartUtils.fillArray(&quot;black&quot;, basicBarChart.__dataDim__),  &#x2F;&#x2F;Default values: black
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	
                                                 &#x2F;**
                                                    For each data subcomponent, stores the color to be used
                                                    to draw its labels
                                                    @property __labelColors__
                                                    @type {Array}
                                                    @readOnly
                                                    @protected
                                                    @default [&quot;black&quot;]*                                                    
                                                  *&#x2F;                                       
            Object.defineProperty(basicBarChart, &quot;__labelColors__&quot;, {
                                    value: ChartUtils.fillArray(&quot;black&quot;, basicBarChart.__dataDim__),  &#x2F;&#x2F;Default values: black
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	  
 
                                                &#x2F;** 
                                                    Color of the background of the main chart area.
                                                    
                                                    @property __innerBackgroundColor__
                                                    @type {String|Object}
                                                    @protected
                                                    @default DEFAULT_INNER_BACKGROUND                                                         
                                                  *&#x2F; 
            Object.defineProperty(basicBarChart, &quot;__innerBackgroundColor__&quot;, {
                                value: 	DEFAULT_INNER_BACKGROUND,
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });   
                                                &#x2F;** 
                                                    Color of the background of the outer area of the whole chart div.
                                                    
                                                    @property __outerBackgroundColor__
                                                    @type {String|Object}
                                                    @protected
                                                    @default DEFAULT_OUTER_BACKGROUND                                                         
                                                  *&#x2F; 
            Object.defineProperty(basicBarChart, &quot;__outerBackgroundColor__&quot;, {
                                value: 	DEFAULT_OUTER_BACKGROUND,
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });   

                                                &#x2F;** 
                                                   Border of the main chart area.
                                                    
                                                    @property __innerBorder__
                                                    @type {Object}
                                                    @protected
                                                    @default DEFAULT_INNER_BORDER                                                         
                                                  *&#x2F; 
            Object.defineProperty(basicBarChart, &quot;__innerBorder__&quot;, {
                                value: 	DEFAULT_INNER_BORDER.shallowCopy(),
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });   
                                                &#x2F;** 
                                                    Color of the background of the outer area of the whole chart div.
                                                    
                                                    @property __outerBorder__
                                                    @type {Object}
                                                    @protected
                                                    @default DEFAULT_OUTER_BORDER                                                         
                                                  *&#x2F; 
            Object.defineProperty(basicBarChart, &quot;__outerBorder__&quot;, {
                                value: 	DEFAULT_OUTER_BORDER.shallowCopy(),
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });                             

                                                 &#x2F;**
                                                    Placeholder for a possible legend object, if the consumer
                                                    decides to add a legend to the chart;
                                                    @property __legend__
                                                    @type {Object}
                                                    @protected
                                                    @default null
                                                  *&#x2F;                                       
            Object.defineProperty(basicBarChart, &quot;__legend__&quot;, {
                                    value: null,  &#x2F;&#x2F;Default value: none
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });	  

            
            __initChart__(basicBarChart, width, height, chartMargins);
            Object.seal(basicBarChart);

            return basicBarChart;
        }
        
        &#x2F;** 
            Advanced Chart: &lt;b&gt;FixedWidthBarChart&lt;&#x2F;b&gt;&lt;br&gt;
            Inherits from BasicBarChart redefining the drawing methods.&lt;br&gt;
            As for its super class values are represented using vertical bars, and each point 
            can have up to 10 subcomponents, where each component can be any non-negative 
            real number (i.e., each point can be in R_+^i, for 1 &lt;= i &lt;= 10).&lt;br&gt;
            &lt;br&gt;
            For this chart the bar width is fixed (although can be set at run time)
            It is possible to choose between having only a fixed number of values accepted,
            or if a certain number of the oldest values should be removed when the
            chart is full.
            
            @class FixedWidthBarChart
            @private
            @beta
            @extends BasicBarChart
          *&#x2F;
        &#x2F;** FixedWidthBarChart(ticks, startingPoint, width, height [, chartMargins, dataDim, parent])
            
            FixedWidthBarChart (pseudo)Constructor
            
            @method FixedWidthBarChart
            @param {Number} ticks [Mandatory]
                            The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} startingPoint [Mandatory, but not used at the moment: inserted for future back-compatibility]&lt;br&gt;
                            The reference for the label of the first point.&lt;br&gt;
                            Should be an incrementable value;
            @param {Number} width [Mandatory]
                            The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} height [Mandatory]
                            The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {String} [chartMargins=&quot;&quot;] [Optional]
                            A String of 0 to 4 space-separated values that specifies the 4 margins of the chart.&lt;br&gt;
                            The string should respect the following format: &lt;b&gt;&quot;top right bottom left;&quot;&lt;&#x2F;b&gt; (notice the trailing semicolon)&lt;br&gt;
                            If less then 4 values are passed, only the covered subfield will be assigned using the input string,
                            while the remaining ones will take a default value specified as an inner attribute of the class.                             
            @param {Number} [dataDim=1] [Optional]
                            The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                            Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
            @param {Object} [parent=body] [Optional]
                            The DOM element to which the diagram should be appended as a child
            @return:    A new FixedWidthBarChart object
            @throws
                                -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                    (through setWidth or setHeight)
                                -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                -   Exception, if dataDim exceeds the maximum data dimension
                                -   Exception, if the ratio between chart&#x27;s width and number of ticks is such
                                    that the computed bar height is smaller than 1 pixel
                                -   Exception, if parent is passed but it is not a valid DOM element
          *&#x2F;                
        function FixedWidthBarChart(ticks, startingPoint, width, height, chartMargins, dataDim, parent){
   
            ticks = parseInt(ticks, 10);
            if (isNaN(ticks) || ticks &lt;= 0){
                throw &quot;Illegal Argument: ticks&quot;;
            }
            
            var proto = BasicBarChart(width, height, chartMargins, dataDim, parent);
            var fixedWidthBarChart = Object.create(proto);   
              

                                                &#x2F;** 
                                                    Number of different values that can be 
                                                    drawn at the same time in this chart
                                                    @property __ticks__
                                                    @type {Number}
                                                    @readOnly
                                                    @protected                                                  
                                                  *&#x2F;
            Object.defineProperty(fixedWidthBarChart, &quot;__ticks__&quot;, {
                                    value: ticks,
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                                                    &#x2F;** 
                                                        Tick length, in minutes
                                                        @property __tickLength__
                                                        @type {Number}
                                                        @protected
                                                        @default 1                                                          
                                                      *&#x2F;
            Object.defineProperty(fixedWidthBarChart, &quot;__tickLength__&quot;, {
                                    value: 1,
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });	
                                                
                                                    &#x2F;** 
                                                        When __ticks__ data points have already been plotted,
                                                        new plots would override previous ones.
                                                        Two solutions are made available:
                                                        1)  By default, new data is rejected, generating a full stack exception;
                                                        2)  A certain number of the oldest data points can be purged off the chart,
                                                            counter-clockwise rotating the data.
                                                            
                                                        @property __ticksToRemoveOnFullQueue__
                                                        @type {Number}
                                                        @protected
                                                        @default 0  
                                                      *&#x2F;
            Object.defineProperty(fixedWidthBarChart, &quot;__ticksToRemoveOnFullQueue__&quot;, {
                                    value: 0,           &#x2F;&#x2F;By default, no previous data is cleared: new data is simply rejected
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });	   
                                

            Object.defineProperty(fixedWidthBarChart, &quot;setFixedDataLengthMode&quot;, {
                                            &#x2F;** setFixedDataLengthMode()
                                            
                                                Sets fixed data length mode.&lt;br&gt;
                                                &lt;br&gt;
                                                When __ticks__ data points have already been plotted,
                                                new plots would override previous ones.&lt;br&gt;
                                                Two solutions are made available:
                                                &lt;ol&gt;
                                                    &lt;li&gt;  By default, new data is rejected, generating a full stack exception;&lt;&#x2F;li&gt;
                                                    &lt;li&gt;  A certain number of the oldest data points can be purged off the chart,
                                                        counter-clockwise rotating the data;&lt;&#x2F;li&gt;
                                                &lt;&#x2F;ol&gt;
                                                &lt;br&gt;    
                                                This function sets the first option.
                                                
                                                @method setFixedDataLengthMode
                                                @chainable
                                                @return {Object}    This chart object, to allow for methd chaining.
                                              *&#x2F;                
                                    value:  function(){                                        
                                                if (this.hasOwnProperty(&quot;__ticksToRemoveOnFullQueue__&quot;)){
                                                    this.__ticksToRemoveOnFullQueue__ = 0;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setFixedDataLengthMode){
                                                        proto.setFixedDataLengthMode();
                                                    }
                                                }                                         
                                                return this;	&#x2F;&#x2F;Method chaining oriented
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });	                                      
                                

            Object.defineProperty(fixedWidthBarChart, &quot;setShifitingDataMode&quot;, {
                                            &#x2F;** setShifitingDataMode(ticksToRemove)
                                            
                                                Sets data shift mode.&lt;br&gt;
                                                &lt;br&gt;
                                                When __ticks__ data points have already been plotted,
                                                new plots would override previous ones.&lt;br&gt;
                                                Two solutions are made available:
                                                &lt;ol&gt;
                                                    &lt;li&gt;  By default, new data is rejected, generating a full stack exception;&lt;&#x2F;li&gt;
                                                    &lt;li&gt;  A certain number of the oldest data points can be purged off the chart,
                                                        counter-clockwise rotating the data;&lt;&#x2F;li&gt;
                                                &lt;&#x2F;ol&gt;
                                                &lt;br&gt;
                                                This function sets the second option.
                                                
                                                @method setShifitingDataMode
                                                @chainable
                                                @param {Number} ticksToRemove [Mandatory]
                                                                              How much data to remove on full chart;
                                                @return {Object}    This object, to allow for method chaining;
                                                @throws     Illegal Argument Exception, if the argument isn&#x27;t valid (see above).
                                              *&#x2F;
                                    value:  function(ticksToRemove){
                                                ticksToRemove = parseInt(ticksToRemove, 10);
                                                if (isNaN(ticksToRemove) || ticksToRemove &lt;= 0){
                                                    throw &quot;Illegal Arguments: ticksToRemove&quot;;
                                                }
                                                if (this.hasOwnProperty(&quot;__ticksToRemoveOnFullQueue__&quot;)){
                                                    this.__ticksToRemoveOnFullQueue__ = ticksToRemove;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setShifitingDataMode){
                                                        proto.setShifitingDataMode(ticksToRemove);
                                                    }
                                                }                                                      
                                                return this;	&#x2F;&#x2F;Method chaining oriented
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });                                    

                                    
            Object.defineProperty(fixedWidthBarChart, &quot;getBarWidth&quot;, {
                                            &#x2F;** getBarWidth()
                                                
                                                Returns current bars&#x27; width.
                                                The overridden version takes a parameter, but this method
                                                doesn&#x27;t need it because barWidth is fixed for this chart.
                                                @method getBarWidth
                                                @return {Number} the value set for __barWidth__.
                                                @override  BasicBarChart.getBarWidth
                                              *&#x2F;
                                    value: 	function(){
                                                return this.__barWidth__;   &#x2F;&#x2F;Stroke tickness is 1 point per side
                                            },   
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });	                              

            Object.defineProperty(fixedWidthBarChart, &quot;__canAppendData__&quot;, {
                                        &#x2F;** __canAppendData__(newDataArray)
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;: This function SHOULD be overriden in any class inheriting from the base class
                                                            in order to handle differents needs.&lt;br&gt;
                                            See base class for method signature and details.
                                             
                                            @method __canAppendData__ 
                                            @protected   
                                            @override  BasicBarChart.__canAppendData__
                                        *&#x2F;
                                value: 	function(newDataArray){
                                    if (!Object.isArray(newDataArray)){
                                        return [];
                                    }
                                    &#x2F;&#x2F;else, checks if there is room for the new data
                                    var m = this.__getDatasetLength__(), 
                                        n = this.__ticks__ - m;
                                    
                                    if (newDataArray.length &lt;= n){
                                        return newDataArray;
                                    }else if (this.__ticksToRemoveOnFullQueue__ === 0){
                                        if (n &lt;= 0){
                                            &#x2F;&#x2F;Can&#x27;t add any more data
                                            return [];
                                        }else{
                                            &#x2F;&#x2F;Can add at most n elements
                                            return newDataArray.splice(0, n);
                                        }
                                    }else{
                                        &#x2F;&#x2F;Must delete __ticksToRemoveOnFullQueue__ elements from the data, and then can add the new ones 
                                        m =  Math.min(this.__ticksToRemoveOnFullQueue__, m);                                            
                                        this.clearData(m);
                                        
                                        &#x2F;&#x2F;Will update as soon as it returns control to the caller (appendData)
                                        
                                        return this.__canAppendData__(newDataArray);  &#x2F;&#x2F;reiterate the request
                                    }
                                    
                                },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });	      		

                    Object.defineProperty(fixedWidthBarChart, &quot;__drawNewData__&quot;, {
                                        &#x2F;** __drawNewData__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                            
                                                                                           
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                               this method and __updateDrawing__ in order to obtain a custom chart.&lt;br&gt;
                                            See base class for method signature and details.

                                            @method __drawNewData__
                                            @protected
                                            @override   BasicBarChart.__drawNewData__
                                          *&#x2F;
                                value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                            var that = this;
                                            var height = this.__getChartAreaHeight__();
                                            var barWidth =  this.getBarWidth(xScale);
                                            
                                            dataSet.enter().append(&quot;rect&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                                .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex)*barWidth;})
                                                .attr(&quot;y&quot;, height)	
                                                .attr(&quot;width&quot;, barWidth)
                                                .attr(&quot;height&quot;, 0)	
                                                .attr(&quot;fill&quot;, that.getBarsFillColor(dataIndex))
                                                .attr(&quot;stroke&quot;, that.getBarsStrokeColor(dataIndex))
                                                .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});
                                                
                                            
                                            if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                                                labelsSet.enter().append(&quot;text&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                                    .text(function(d) {return that.__makeLabel__(d, dataIndex);})
                                                    .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                                    .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex + 0.5) * barWidth;})
                                                    .attr(&quot;y&quot;, height)
                                                    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                                    .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                                                    .attr(&quot;fill&quot;, that.getLabelColor(dataIndex));	
                                            }else{
                                                labelsSet.remove();
                                            }
                                                
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });
                
                Object.defineProperty(fixedWidthBarChart, &quot;__updateDrawing__&quot;, {
                                        &#x2F;** __updateDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                               this method and __drawNewData__ in order to obtain a custom chart.&lt;br&gt;
                                            See base class for method signature and details.
                                             
                                            @method  __updateDrawing__
                                            @protected
                                            @override  BasicBarChart.__updateDrawing__
                                          *&#x2F;					
                                value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                            var that = this;
                                            var height = this.__getChartAreaHeight__();
                                            var barWidth = this.getBarWidth(xScale);							
                                            dataSet.transition()&#x2F;&#x2F;.delay(250)
                                                    .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex)*barWidth;})
                                                    .attr(&quot;y&quot;, function(d){return height - yScale(d);})
                                                    .attr(&quot;width&quot;, barWidth)
                                                    .attr(&quot;height&quot;, function(d){return yScale(d);})
                                                    .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});									
                                            if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                                                labelsSet.transition()&#x2F;&#x2F;.delay(250)
                                                        .text(function(d) {return that.__makeLabel__(d, dataIndex);})
                                                        .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex + 0.5) * barWidth;})
                                                        .attr(&quot;y&quot;, function(d){return height - yScale(d) + that.getLabelsSize(dataIndex) ;});
                                                        
                                            }else{
                                                labelsSet.remove();
                                            }						
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });	 

                fixedWidthBarChart.addProtectedMethod(&quot;__refreshDrawing__&quot;, 
                            &#x2F;** __refreshDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                
                                Called by __redrawAll__() to redraw all the data-related drawings, once for
                                every data subcomponent.&lt;br&gt;
                                The difference with __updateDrawing__ is that the latter is incremental with respect to 
                                __drawNewData__ and updates only the properties used to provide animations of the drawing,
                                while this method redraws from scratch the data.
                                &lt;br&gt;
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                            this method following __updateDrawing__  behaviour in order to obtain a custom chart.

                                @method __refreshDrawing__
                                @protected
                                @override   BasicBarChart.__refreshDrawing__
                              *&#x2F;
                    function __refreshDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale){
                        var that = this;
                        var height = this.__getChartAreaHeight__();
                        var barWidth =  this.getBarWidth(xScale);
                        
                        dataSet.transition()
                            .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex)*barWidth;})
                            .attr(&quot;y&quot;, height)	
                            .attr(&quot;width&quot;, barWidth)
                            .attr(&quot;height&quot;, 0)	
                            .attr(&quot;fill&quot;, that.getBarsFillColor(dataIndex))
                            .attr(&quot;stroke&quot;, that.getBarsStrokeColor(dataIndex))
                            .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});
                            
                        
                        if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                            labelsSet.transition()
                                .text(function(d) {return that.__makeLabel__(d, dataIndex);})
                                .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                .attr(&quot;x&quot;, function(d, i){return (i * that.__dataDim__ + dataIndex + 0.5) * barWidth;})
                                .attr(&quot;y&quot;, height)
                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                                .attr(&quot;fill&quot;, that.getLabelColor(dataIndex));	
                        }else{
                            labelsSet.remove();
                        }
                            
                        return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                    });
                           
                fixedWidthBarChart.addProtectedMethod(&quot;__updateAxes__&quot;,
                    &#x2F;** __updateAxes__(yScale)
                   
                        Called by __updateDrawing__() to update the labels of the vertical axe
                        when vertical scale changes;&lt;br&gt;
                        &lt;br&gt;
                        &lt;b&gt;WARNING&lt;&#x2F;b&gt;:     if you inherit from this class you might want to override
                                            this method as well as __drawNewData__ and __updateDrawing__ 
                                            in order to obtain a custom chart.
                                  
                        @method __updateAxes__
                        @protected
                        @chainable
                        @override FixedWidthBarChart.__updateAxes__
                        @param {Object} yScale  [Mandatory]
                                                D3 scale object for Y axis;
                        @return {Object}    The current chart object, to allow for method chaining.
                      *&#x2F;
                    function __updateAxes__(yScale){
                        var vAxe = this.__verticalAxe__,
                            hAxe = this.__horizontalAxe__;
                        var i, notches;
                        var axeLabels, m, n, k,
                            anchor,
                            labels,
                            x, y,
                            width, height,
                            scaleFactor,
                            that = this;
                        &#x2F;&#x2F;VERTICAL AXE
                        if (vAxe){
                            if (this.__scaleGlobally__ || this.__dataDim__ === 1){
                                &#x2F;&#x2F;If data is drawn with a global scaling, or there is only one subcomponent,
                                &#x2F;&#x2F;then Vertical axe CAN BE DRAWN
                                m = this.__maxVals__.max();
                                notches = vAxe.notches;
                                axeLabels = [m];
                                for (i = notches; i &gt; 0; i--){
                                    axeLabels.push(m * i &#x2F; (notches + 1));
                                }
                                axeLabels.push(0);
                            }else{
                                &#x2F;&#x2F;If data is drawn with local scaling for each component
                                &#x2F;&#x2F;then Vertical axe WOULD HAVE NO MEANING
                                axeLabels = [];
                            }
                            
                            labels = vAxe.svgElement.selectAll(&quot;text[type=axe_label]&quot;).data(axeLabels);
                            height = vAxe.svgElement.attr(&quot;height&quot;);
                            
                            if (vAxe.side === &quot;right&quot;){
                                x = NOTCH_LINE_LENGTH;
                                anchor = &quot;start&quot;;
                            }else{
                                x = vAxe.svgElement.attr(&quot;width&quot;) - NOTCH_LINE_LENGTH;
                                anchor = &quot;end&quot;;
                            }
                            
                            labels.exit().remove();
                            labels.enter().insert(&quot;text&quot;, &quot;svg&quot;)    &#x2F;&#x2F;Insert before svg block
                                    .attr(&quot;type&quot;, &quot;axe_label&quot;)
                                    .attr(&quot;text-anchor&quot;, anchor)
                                    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                    .attr(&quot;font-size&quot;, vAxe.labelSize);
                            
                            labels.text(function(d){return that.__makeLabel__(d, undefined, true);})
                                  .attr(&quot;x&quot;, x)
                                  .attr(&quot;y&quot;, function(d){return Math.max(vAxe.labelSize *0.75, 
                                                                         Math.min(height, height - yScale(d) + vAxe.labelSize * 0.375));})
                                  .attr(&quot;fill&quot;, vAxe.color);
                            
                        }
                        &#x2F;&#x2F;HORIZONTAL AXE
                        if (hAxe){
                            width = hAxe.svgElement.attr(&quot;width&quot;);
                            height = hAxe.svgElement.attr(&quot;height&quot;);
                            
                            m = this.__dataCounter__ - this.__getDatasetLength__();
                            notches = hAxe.notches;
                            scaleFactor = width &#x2F; (notches + 1);
                            
                            axeLabels = [m];
                            for (i = 1; i &lt;= notches; i++){
                                k = m + (this.__ticks__* i &#x2F; (notches + 1));
                                axeLabels.push(k);    &#x2F;&#x2F;Add element to the head of the list
                            }
                            axeLabels.push(m + this.__ticks__);
                            
                            labels = hAxe.svgElement.selectAll(&quot;text[type=axe_label]&quot;).data(axeLabels);
                            
                            if (hAxe.side === &quot;bottom&quot;){
                                y = NOTCH_LINE_LENGTH + hAxe.labelSize;
                            }else{
                                y = height - NOTCH_LINE_LENGTH;
                                anchor = &quot;end&quot;;
                            }
                            
                            n = 0;
                            
                            labels.exit().remove();
                            labels.enter().insert(&quot;text&quot;, &quot;svg&quot;)    &#x2F;&#x2F;Insert before svg block
                                    .attr(&quot;type&quot;, &quot;axe_label&quot;)
                                    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                    .attr(&quot;text-anchor&quot;, function(){ ++n; return n === 1 ? &quot;start&quot; : n === axeLabels.length ? &quot;end&quot; :&quot;middle&quot;;})
                                    .attr(&quot;font-size&quot;, hAxe.labelSize);
                            &#x2F;&#x2F;Updates labels
                            labels.text(function(d){return Object.isNumber(d) ? Math.round(d) : d;})
                                  .attr(&quot;x&quot;, function(d, i){return i * scaleFactor;})
                                  .attr(&quot;y&quot;, y)                                                   
                                  .attr(&quot;fill&quot;, hAxe.color);
                        }      
                        
                        return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this                                            
                    });
                        
            &#x2F;** __init__()

                Inits the chart by computing the allowed barWidth;
                            
                @method __init__
                @private
                @param {Object} chart   [Mandatory]
                                        The chart object that needs initialization;                   
                @param {Number} width   [Mandatory]
                                        Chart&#x27;s width;
                @param {Number} height  [Mandatory]
                                        Chart&#x27;s height;                                                            
                
                @return {undefined}
              *&#x2F;                                    
            function __init__(chart, width, height){
                var barWidth = width &#x2F; (chart.__dataDim__ * chart.__ticks__);
                if (barWidth &lt;= 0){
                    throw &quot;Illegal Arguments combination: width too small to draw &#x27;ticks&#x27; values&quot;;
                }
                                            &#x2F;** 
                                                Chart&#x27;s bars&#x27; width, in pixel &lt;br&gt;
                                                Can be changed at runtime
                                                @property __barWidth__
                                                @type {Number}
                                                @protected
                                                @default 8
                                                @override  FixedWidthBarChart.__barWidth__  
                                              *&#x2F;                                     
                Object.defineProperty(chart, &quot;__barWidth__&quot;, {
                                            value: barWidth,
                                            writable: false,
                                            enumerable: false,
                                            configurable: false
                                        });	
                return ;
            }

            __init__(fixedWidthBarChart,  fixedWidthBarChart.__getChartAreaWidth__(), fixedWidthBarChart.__getChartAreaHeight__());
            Object.seal(fixedWidthBarChart);
            
            return fixedWidthBarChart;
        }

        &#x2F;** 
            
            Advanced Chart: &lt;b&gt;SlidingBarChart&lt;&#x2F;b&gt;&lt;br&gt;
            Inherits from FixedWidthBarChart redefining the drawing methods.&lt;br&gt;
            As for its super class values are represented using vertical bars, and each point 
            can have up to 10 subcomponents, where each component can be any non-negative 
            real number (i.e., each point can be in R_+^i, for 1 &lt;= i &lt;= 10).&lt;br&gt;
            &lt;br&gt;
            For this chart the bar width is fixed (although can be set at run time)
            It is possible to choose between having only a fixed number of values accepted,
            or if a certain number of the oldest values should be removed when the
            chart is full.&lt;br&gt;
            &lt;br&gt;
            Every __ticksBetweenHighlights__ values inserted (where __ticksBetweenHighlights__ can 
            be set at runtime, although it defaults to 10) the background of those values is highlighted, 
            to stress out time progression.       
            
            @class SlidingBarChart
            @private
            @beta
            @extends FixedWidthBarChart
        *&#x2F;
        &#x2F;** SlidingBarChart(ticks, width, height [, chartMargins, dataDim, parent])

            SlidingBarChart (pseudo)Constructor.
            
            @method SlidingBarChart
            @param {Number} ticks [Mandatory]
                            The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} width [Mandatory]
                            The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} height [Mandatory]
                            The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {String} [chartMargins=&quot;&quot;] [Optional]
                            A String of 0 to 4 space-separated values that specifies the 4 margins of the chart.&lt;br&gt;
                            The string should respect the following format: &lt;b&gt;&quot;top right bottom left;&quot;&lt;&#x2F;b&gt; (notice the trailing semicolon)&lt;br&gt;
                            If less then 4 values are passed, only the covered subfield will be assigned using the input string,
                            while the remaining ones will take a default value specified as an inner attribute of the class.  &lt;br&gt;
                            For this particular chart the right margin can&#x27;t be less than AXES_LABEL_WIDTH pixel wide (if a smaller
                            value is passed, it will be overwritten).
            @param {Number} [dataDim=1] [Optional]
                            The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                            Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
            @param {Object} [parent=body] [Optional]
                            The DOM element to which the diagram should be appended as a child
            @return {Object}    A new SlidingBarChart object.
            @throws
                                -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                    (through setWidth or setHeight)
                                -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                -   Exception, if dataDim exceeds the maximum data dimension
                                -   Exception, if the ratio between chart&#x27;s width and number of ticks is such
                                    that the computed bar height is smaller than 1 pixel
                                -   Exception, if parent is passed but it is not a valid DOM element
          *&#x2F;                
        function SlidingBarChart (ticks, width, height, chartMargins, dataDim, parent){
   
            ticks = parseInt(ticks, 10);
            if (isNaN(ticks) || ticks &lt;= 0){
                throw &quot;Illegal Argument: ticks&quot;;
            }
  

                &#x2F;** 
                    Default highlight color for background
                    @property DEFAULT_INNER_BACKGROUND_HIGHLIGHT
                    @for SlidingBarChart
                    @type {String|Object}
                    @default = &quot;lightpink&quot;
                    @final
                    @private     
                  *&#x2F;             
            var DEFAULT_INNER_BACKGROUND_HIGHLIGHT = &quot;lightpink&quot;;
           
                &#x2F;** 
                    Default width of axes&#x27; labels
                    @property AXES_LABEL_WIDTH
                    @for SlidingBarChart
                    @type {Number}
                    @default = 55
                    @final
                    @private     
                  *&#x2F;            
            var AXES_LABEL_WIDTH = 55;

            
            var chartMarginsObj;
                try{
                    chartMarginsObj = basicBarChartSharedPrototype.__decodeCSSMultivalueString__(chartMargins, undefined);
                    chartMarginsObj.right = Math.max(chartMarginsObj.right, AXES_LABEL_WIDTH);
                }catch(e){
                    chartMarginsObj = {top: 0, right: AXES_LABEL_WIDTH};
                }
            chartMargins = basicBarChartSharedPrototype.__encodeCSSMultivalueString__(chartMarginsObj);

            var proto = FixedWidthBarChart(ticks, 0, width, height, chartMargins, dataDim, parent);	
            var slidingBarChart = Object.create(proto);  
            &#x2F;&#x2F;Override any possible value passed
            

                                                    &#x2F;** 
                                                        Every __ticksBetweenHighlights__ ticks, the data is &quot;higlighted&quot;
                                                        by applying the selected highlight style to the background.
                                                        
                                                        @property __ticksBetweenHighlights__
                                                        @type {Number}
                                                        @protected
                                                        @default 10 
                                                      *&#x2F;
            Object.defineProperty(slidingBarChart, &quot;__ticksBetweenHighlights__&quot;, {
                                value: 	10,
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });  
                            
            Object.defineProperty(slidingBarChart, &quot;getTicksBetweenHighlights&quot;, {
                                            &#x2F;** getTicksBetweenHighlights()
                                            
                                                Returns the number of ticks between two consecutive highlights (one extreme inclusive)
                                                
                                                @method getTicksBetweenHighlights
                                                @return {Number}    The number of ticks between two consecutive highlights;
                                              *&#x2F;
                                    value:  function(){
                                                return this.__ticksBetweenHighlights__;                                                    
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });  
                                
            Object.defineProperty(slidingBarChart, &quot;setTicksBetweenHighlights&quot;, {
                                            &#x2F;** setTicksBetweenHighlights(ticks)
                                                
                                                Sets the number of ticks between two consecutive highlights (one extreme inclusive)
                                                
                                                @method setTicksBetweenHighlights
                                                @chainable
                                                @param {Number} ticks   [Mandatory]
                                                                        The number of ticks between two consecutive highlights;
                                                @return {Object}    This object, to allow for method chaining;
                                              *&#x2F;
                                    value:  function(ticks){
                                                
                                                if (this.hasOwnProperty(&quot;__ticksBetweenHighlights__&quot;)){
                                                    this.__ticksBetweenHighlights__ = ticks;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setTicksBetweenHighlights){
                                                        proto.setTicksBetweenHighlights(ticks);
                                                    }
                                                }                                                      
                                                return this;	&#x2F;&#x2F;Method chaining oriented
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });                                    

                            
                                                    &#x2F;**
                                                        Color of the background bars when highlighted

                                                        @property __backgroundHighlightColor__
                                                        @type {String|Object}
                                                        @protected
                                                        @default DEFAULT_INNER_BACKGROUND_HIGHLIGHT    
                                                      *&#x2F;
            Object.defineProperty(slidingBarChart, &quot;__backgroundHighlightColor__&quot;, {
                                value: 	DEFAULT_INNER_BACKGROUND_HIGHLIGHT,
                                writable: true,
                                enumerable: false,
                                configurable:false
                            });



            Object.defineProperty(slidingBarChart, &quot;setInnerBackgroundHighlightColor&quot;, {
                                            &#x2F;** setInnerBackgroundHighlightColor(bgHColor)
                                            
                                                Changes the background color for &quot;highlighted&quot; values
                                                
                                                @method setInnerBackgroundHighlightColor
                                                @chainable
                                                @param {String|Object} bgHColor [Mandatory]
                                                                                The new color for highlighted background bars;
                                                @return {Object}    This object, to allow for method chaining.
                                              *&#x2F;
                                    value:  function(bgHColor){
                                                
                                                if (this.hasOwnProperty(&quot;__backgroundHighlightColor__&quot;)){
                                                    this.__backgroundHighlightColor__ = bgHColor;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setInnerBackgroundHighlightColor){
                                                        proto.setInnerBackgroundHighlightColor(bgHColor);
                                                    }
                                                }                                                      
                                                return this;	&#x2F;&#x2F;Method chaining oriented
                                            },           &#x2F;&#x2F;No previous data is cleared: new data is simply rejected
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });                                    

                                    
            Object.defineProperty(slidingBarChart, &quot;getBackgroundHighlightColor&quot;, {
                                            &#x2F;** getBackgroundHighlightColor()
                                                
                                                Returns current color for background highlighted bars
                                                
                                                @method getBackgroundHighlightColor
                                                @return {String|Object} The value set for __backgroundHighlightColor__
                                              *&#x2F;
                                    value: 	function(){
                                                return this.__backgroundHighlightColor__;
                                            },   
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                });	                                    

                                
            Object.defineProperty(slidingBarChart, &quot;__canAppendData__&quot;, {
                                        &#x2F;** __canAppendData__(newDataArray)
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;: This function SHOULD be overriden in any class inheriting from the base class
                                                            in order to handle differents needs.&lt;br&gt;
                                            See base class for method signature and details.
                                             
                                            @method __canAppendData__ 
                                            @protected
                                            @override  FixedWidthBarChart.__canAppendData__
                                        *&#x2F;
                                value: 	function(newDataArray){
                                    if (!Object.isArray(newDataArray)){
                                        return [];
                                    }
                                    &#x2F;&#x2F;else, checks if there is room for the new data
                                    var m = this.__getDatasetLength__(), 
                                        n = this.__ticks__ - m,
                                        k = newDataArray.length;

                                    &#x2F;&#x2F;Checks that it isn&#x27;t trying to add more data than it is allowed to...
                                    if (k &gt; this.__ticks__){
                                        &#x2F;&#x2F;... if it is so, discards the oldest surplus among the new data
                                        newDataArray.splice(0, k - this.__ticks__);
                                        k = this.__ticks__;
                                    }
                                    
                                    if (k &lt;= n){
                                        return newDataArray;
                                    }else{
                                        &#x2F;&#x2F;Must delete the exceding elements from the data, and then can add the new ones 
                                        m =  Math.min(k, m);                                            
                                        this.clearData(m);
                                        
                                        &#x2F;&#x2F;Will update as soon as it returns control to the caller (appendData)                                          
                                        return newDataArray;  &#x2F;&#x2F;reiterate the request
                                    }
                                    
                                },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });	 
                            
                    Object.defineProperty(slidingBarChart, &quot;__selectBackgroundBars__&quot;, {
                                            &#x2F;** __selectBackgroundBars__([filter])

                                                Returns the list of the svg elements used to draw background; &lt;br&gt;
                                                Elements can be filtered using a custom filter passad as an optional
                                                parameter;
                                        
                                                @method __selectBackgroundBars__
                                                @protected
                                                @param {String|Object} filter  [Optional]
                                                                                A filter to be applied to the selection;
                                                @return {Object}    The proper set of d3 elements.                    
                                              *&#x2F;
                                    value: 	function(filter){
                                                if (Object.isUndefined(filter)){
                                                    return this.__chartArea__.selectAll(&quot;rect[type=back]&quot;);
                                                }else{
                                                    return this.__chartArea__.selectAll(&quot;rect[type=back]&quot;).filter(filter);
                                                }
                                            },
                                    writable: false,
                                    enumerable: false,
                                    configurable:false
                                });
                                
                    Object.defineProperty(slidingBarChart, &quot;__updateBackground__&quot;, {
                                        &#x2F;** __updateBackground__()
                                            
                                            
                                            Called by __drawNewData__() to redraw the background properly;&lt;br&gt;
                                            &lt;br&gt;
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override
                                                               this method as well as __drawNewData__ and __updateDrawing__ 
                                                               in order to obtain a custom chart.
                                            
                                            @method __updateBackground__
                                            @protected
                                            @override BasicBarChart.__updateBackground__
                                            @return {undefined}
                                          *&#x2F;
                                value: 	function(){
                                            var counter = this.__dataCounter__,
                                                ticks = this.getTicksBetweenHighlights();
                                            var bgColor = this.getInnerBackgroundColor(),
                                                bgHColor = this.getBackgroundHighlightColor();
                                            &#x2F;&#x2F;Redraws all background bars with normal style 
                                            this.__selectBackgroundBars__()
                                                .attr(&quot;fill&quot;, bgColor);
                                             
                                            &#x2F;&#x2F;Redraws only the highlighted ones with highlighted style 
                                            this.__selectBackgroundBars__(  function(){
                                                                                return counter &gt; this.d_index &amp;&amp; 
                                                                                       (counter - this.d_index) % ticks === 0; 
                                                                            })
                                                                        .attr(&quot;fill&quot;, bgHColor);
                                                                                                  
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });
                            
                    slidingBarChart.addProtectedMethod(&quot;__updateAxes__&quot;,
                        &#x2F;** __updateAxes__(yScale)
                       
                            Called by __updateDrawing__() to update the labels of the vertical axe
                            when vertical scale changes;&lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:     if you inherit from this class you might want to override
                                                this method as well as __drawNewData__ and __updateDrawing__ 
                                                in order to obtain a custom chart.
                                      
                            @method __updateAxes__
                            @protected
                            @chainable
                            @override FixedWidthBarChart.__updateAxes__
                            @param {Object} yScale  [Mandatory]
                                                    D3 scale object for Y axis;
                            @return {Object}    The current chart object, to allow for method chaining.
                          *&#x2F;
                        function(yScale){
                            var vAxe = this.__verticalAxe__,
                                hAxe = this.__horizontalAxe__;
                            var i, notches;
                            var axeLabels, m, n, k,
                                anchor,
                                labels,
                                x, y,
                                width, height,
                                scaleFactor,
                                that = this;
                            &#x2F;&#x2F;VERTICAL AXE
                            if (vAxe){
                                if (this.__scaleGlobally__ || this.__dataDim__ === 1){
                                    &#x2F;&#x2F;If data is drawn with a global scaling, or there is only one subcomponent,
                                    &#x2F;&#x2F;then Vertical axe CAN BE DRAWN
                                    m = this.__maxVals__.max();
                                    notches = vAxe.notches;
                                    axeLabels = [m];
                                    for (i = notches; i &gt; 0; i--){
                                        axeLabels.push(m * i &#x2F; (notches + 1));
                                    }
                                    axeLabels.push(0);
                                }else{
                                    &#x2F;&#x2F;If data is drawn with local scaling for each component
                                    &#x2F;&#x2F;then Vertical axe WOULD HAVE NO MEANING
                                    axeLabels = [];
                                }
                                
                                labels = vAxe.svgElement.selectAll(&quot;text[type=axe_label]&quot;).data(axeLabels);
                                height = vAxe.svgElement.attr(&quot;height&quot;);
                                
                                if (vAxe.side === &quot;right&quot;){
                                    x = NOTCH_LINE_LENGTH;
                                    anchor = &quot;start&quot;;
                                }else{
                                    x = vAxe.svgElement.attr(&quot;width&quot;) - NOTCH_LINE_LENGTH;
                                    anchor = &quot;end&quot;;
                                }
                                
                                labels.exit().remove();
                                labels.enter().insert(&quot;text&quot;, &quot;svg&quot;)    &#x2F;&#x2F;Insert before svg block
                                        .attr(&quot;type&quot;, &quot;axe_label&quot;)
                                        .attr(&quot;text-anchor&quot;, anchor)
                                        .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                        .attr(&quot;font-size&quot;, vAxe.labelSize);
                                
                                labels.text(function(d){return that.__makeLabel__(d, undefined, true);})
                                      .attr(&quot;x&quot;, x)
                                      .attr(&quot;y&quot;, function(d){return Math.max(vAxe.labelSize *0.75, 
                                                                             Math.min(height, height - yScale(d) + vAxe.labelSize * 0.375));})
                                      .attr(&quot;fill&quot;, vAxe.color);
                                
                            }
                            &#x2F;&#x2F;HORIZONTAL AXE
                            if (hAxe){
                                width = hAxe.svgElement.attr(&quot;width&quot;);
                                height = hAxe.svgElement.attr(&quot;height&quot;);
                                
                                m = this.__dataCounter__ - this.__ticks__;
                                notches = hAxe.notches;
                                scaleFactor = width &#x2F; (notches + 1);
                                
                                axeLabels = [m &gt;= 0 ? m : &quot;&quot;];
                                for (i = 1; i &lt;= notches; i++){
                                    k = m + (this.__ticks__* i &#x2F; (notches + 1));
                                    axeLabels.push(k &gt;= 0 ? k : &quot;&quot;);
                                }
                                axeLabels.push(this.__dataCounter__);
                                
                                labels = hAxe.svgElement.selectAll(&quot;text[type=axe_label]&quot;).data(axeLabels);
                                
                                if (hAxe.side === &quot;bottom&quot;){
                                    y = NOTCH_LINE_LENGTH + hAxe.labelSize;
                                }else{
                                    y = height - NOTCH_LINE_LENGTH;
                                    anchor = &quot;end&quot;;
                                }
                                
                                n = 0;
                                
                                labels.exit().remove();
                                labels.enter().insert(&quot;text&quot;, &quot;svg&quot;)    &#x2F;&#x2F;Insert before svg block
                                        .attr(&quot;type&quot;, &quot;axe_label&quot;)
                                        .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                        .attr(&quot;text-anchor&quot;, function(){ ++n; return n === 1 ? &quot;start&quot; : n === axeLabels.length ? &quot;end&quot; :&quot;middle&quot;;})
                                        .attr(&quot;font-size&quot;, hAxe.labelSize);
                                &#x2F;&#x2F;Updates labels
                                labels.text(function(d){return Object.isNumber(d) ? Math.round(d) : d;})
                                      .attr(&quot;x&quot;, function(d, i){return i * scaleFactor;})
                                      .attr(&quot;y&quot;, y)                                                   
                                      .attr(&quot;fill&quot;, hAxe.color);
                                
                            }      
                            
                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this                                            
                        });
                            
                    Object.defineProperty(slidingBarChart, &quot;__drawNewData__&quot;, {
                                        &#x2F;** __drawNewData__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                            
                                                                                           
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                               this method and __updateDrawing__ in order to obtain a custom chart.&lt;br&gt;
                                            See base class for method signature and details.

                                            @method __drawNewData__
                                            @protected
                                            @override   FixedWidthBarChart.__drawNewData__
                                          *&#x2F;
                                value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                            var that = this;
                                            var height = this.__getChartAreaHeight__();
                                            var barWidth =  this.getBarWidth(xScale);
                                            var initial_x = (this.__ticks__ - this.__getDatasetLength__()) * that.__dataDim__ * barWidth;
                                             
                                            &#x2F;&#x2F;Adds value bars 
                                            dataSet.enter().append(&quot;rect&quot;)
                                                .attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                                .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex) * barWidth + 1;})
                                                .attr(&quot;y&quot;, height)	
                                                .attr(&quot;width&quot;, barWidth - 3)
                                                .attr(&quot;height&quot;, 0)	
                                                .attr(&quot;fill&quot;, that.getBarsFillColor(dataIndex))
                                                .attr(&quot;stroke&quot;, that.getBarsStrokeColor(dataIndex))
                                                .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});
                                                
                                            
                                            if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                                                labelsSet.enter().append(&quot;text&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                                    .text(function(d) {return that.__makeLabel__(d, dataIndex);})
                                                    .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                                    .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex + 0.5) * barWidth + 1;})
                                                    .attr(&quot;y&quot;, height)
                                                    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                                    .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                                                    .attr(&quot;fill&quot;, that.getLabelColor(dataIndex));	
                                            }else{
                                                labelsSet.remove();
                                            }
                                                
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });
                
                Object.defineProperty(slidingBarChart, &quot;__updateDrawing__&quot;, {
                                        &#x2F;** __updateDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                            
                                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                               this method and __drawNewData__ in order to obtain a custom chart.&lt;br&gt;
                                            See base class for method signature and details.
                                             
                                            @method  __updateDrawing__
                                            @protected
                                            @override  FixedWidthBarChart.__updateDrawing__
                                          *&#x2F;					
                                value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                            var that = this;
                                            var height = this.__getChartAreaHeight__();
                                            var barWidth = this.getBarWidth(xScale);
                                            var initial_x = (this.__ticks__ - this.__getDatasetLength__()) * that.__dataDim__ * barWidth;
                                                
                                            dataSet.transition().duration(100)&#x2F;&#x2F;.delay(250)
                                                    .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex) * barWidth + 1;})
                                                    .attr(&quot;y&quot;, function(d){return height - yScale(d);})
                                                    .attr(&quot;width&quot;, barWidth - 3)
                                                    .attr(&quot;height&quot;, function(d){return yScale(d);})
                                                    .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});									
                                                    
                                            if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                                                labelsSet.transition()&#x2F;&#x2F;.delay(250)
                                                        .text(function(d) {return that.__makeLabel__(d, dataIndex);})
                                                        .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex + 0.5) * barWidth + 1;})
                                                        .attr(&quot;y&quot;, function(d){return height - yScale(d) + that.getLabelsSize(dataIndex) ;});
                                                        
                                            }else{
                                                labelsSet.remove();
                                            }						
                                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                        },
                                writable: false,
                                enumerable: false,
                                configurable:false
                            });	      
                                   
                            
                    slidingBarChart.addProtectedMethod(&quot;__refreshDrawing__&quot;,
                        &#x2F;** __refreshDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                            
                                                                           
                            Called by __redrawAll__() to redraw all the data-related drawings, once for
                            every data subcomponent.&lt;br&gt;
                            The difference with __updateDrawing__ is that the latter is incremental with respect to 
                            __drawNewData__ and updates only the properties used to provide animations of the drawing,
                            while this method redraws from scratch the data.
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                        this method following __updateDrawing__  behaviour in order to obtain a custom chart.

                            @method __refreshDrawing__
                            @protected
                            @override   FixedWidthBarChart.__refreshDrawing__
                          *&#x2F;
                        function __refreshDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale){
                            var that = this;
                            var height = this.__getChartAreaHeight__();
                            var barWidth =  this.getBarWidth(xScale);
                            var initial_x = (this.__ticks__ - this.__getDatasetLength__()) * that.__dataDim__ * barWidth;
                             
                            &#x2F;&#x2F;Adds value bars 
                            dataSet.transition()
                                .attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex) * barWidth + 1;})
                                .attr(&quot;y&quot;, function(d){return height - yScale(d);})
                                .attr(&quot;width&quot;, barWidth - 3)
                                .attr(&quot;height&quot;, function(d){return yScale(d);})	
                                .attr(&quot;fill&quot;, that.getBarsFillColor(dataIndex))
                                .attr(&quot;stroke&quot;, that.getBarsStrokeColor(dataIndex))
                                .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; height);});
                                
                            
                            if (that.areLabelsVisible(dataIndex) &amp;&amp; barWidth &gt; that.getLabelsSize(dataIndex)){
                                labelsSet.transition()
                                    .text(function(d) {return that.__makeLabel__(d, dataIndex);})
                                    .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                    .attr(&quot;x&quot;, function(d, i){return initial_x + (i * that.__dataDim__ + dataIndex + 0.5) * barWidth + 1;})
                                    .attr(&quot;y&quot;, function(d){return height - yScale(d) + that.getLabelsSize(dataIndex) ;})
                                    .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                    .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                                    .attr(&quot;fill&quot;, that.getLabelColor(dataIndex));	
                            }else{
                                labelsSet.remove();
                            }
                                
                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                        });
                                   
                slidingBarChart.addProtectedMethod(&quot;__redrawInnerBackground__&quot;, 
                        &#x2F;** __redrawInnerBackground__()                            
                            
                            Properly redraws the background of the main chart area &lt;br&gt;
                            &lt;br&gt;
                            &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override
                                               this method to reflect its expected behaviour.
                            
                            @method __redrawInnerBackground__
                            @protected
                            @override
                            @return {undefined}
                          *&#x2F;
                        function(){
                            &#x2F;&#x2F;Nothing to do other than preventing super method execution                         
                            return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                        });                                              
            &#x2F;** __init__()
                
                Inits the chart;
                
                @method __init__
                @private
                @param {Object} chart   [Mandatory]
                                        The chart object that needs initialization;
                @param {Number} width   [Mandatory]
                                        Chart&#x27;s width;
                @param {Number} height  [Mandatory]
                                        Chart&#x27;s height;
                @return {undefined}
              *&#x2F;                
            function __init__(chart, width, height){

                &#x2F;&#x2F;Hides all labels by default
                for (var i=0; i&lt;chart.__dataDim__; i++){
                    chart.toggleLabels(i, false);
                }
                  
                var barWidth = width &#x2F; (chart.__dataDim__ * chart.__ticks__);
                        &#x2F;&#x2F;var barWidth = slidingBarChart.getBarWidth() ;
                        
                if (barWidth &lt;= 0){
                    throw &quot;Illegal Arguments combination: width too small to draw &#x27;ticks&#x27; values&quot;;
                }
                                        &#x2F;** 
                                            The width of each bar;
                                            
                                            @property __barWidth__
                                            @type {Number}
                                            @readOnly
                                            @protected                                              
                                            @override  FixedWidthBarChart.__barWidth__
                                          *&#x2F;
                Object.defineProperty(chart, &quot;__barWidth__&quot;, {
                                            value: barWidth,
                                            writable: false,
                                            enumerable: false,
                                            configurable: false
                                        });	
                                       
                &#x2F;&#x2F;Removes the background possibly set by super method:
                chart.__chartArea__.select(&quot;#innerBackground&quot;).attr(&quot;fill&quot;, &quot;white&quot;);                 
                                        
                var totalBarsNumber = chart.__ticks__ * chart.__dataDim__;

                &#x2F;&#x2F;Adds background bars
                chart.__selectBackgroundBars__()
                    .data(new Array(totalBarsNumber))
                    .enter().append(&quot;rect&quot;)
                    .attr(&quot;type&quot;, &quot;back&quot;)
                                                                &#x2F;&#x2F;Data enter form right
                    .property(&quot;d_index&quot;, function(d,i){return Math.floor((totalBarsNumber - i - 1) &#x2F; chart.__dataDim__);}) 
                    .attr(&quot;x&quot;, function(d, i){return i * barWidth;})
                    .attr(&quot;y&quot;, 0)	
                    .attr(&quot;width&quot;, barWidth - 1)
                    .attr(&quot;height&quot;, height)	
                    .attr(&quot;fill&quot;, chart.__innerBackgroundColor__);
                
                chart.setVerticalAxe(true, &quot;&quot;, 5, 2);   &#x2F;&#x2F;Default axe
                
                return; &#x2F;&#x2F;Private method, no need to return anything
            }


            __init__(slidingBarChart, slidingBarChart.__getChartAreaWidth__(), slidingBarChart.__getChartAreaHeight__());
            Object.seal(slidingBarChart);
            
            return slidingBarChart;
        }
        
        
        &#x2F;** 
            
            Advanced Chart: &lt;b&gt;TimeWheelChart&lt;&#x2F;b&gt;&lt;br&gt;
            Inherits from BasicBarChart redefining the drawing methods.&lt;br&gt;
            &lt;br&gt;
            Data is represented as bars drawn around a time wheel.&lt;br&gt;
            &lt;br&gt;
            It is possible to choose between having only a fixed number of values accepted,
            or if a certain number of the oldest values should be removed when the
            chart is full.
            
            @class TimeWheelChart
            @private
            @beta
            @extends FixedWidthBarChart
          *&#x2F;
        &#x2F;** TimeWheelChart(ticks, startTime, wheelRadius, width, height [, chartMargins, dataDim, parent])
            
            TimeWheelChart (pseudo)Constructor.
            
            @method TimeWheelChart
            @param {Number} ticks [Mandatory]
                            The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {String} startTime [Mandatory]
                            The reference for the label of the first point.&lt;br&gt;
                            Should be an incrementable value.                                
            @param {Number} width  [Mandatory]
                            The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {Number} height [Mandatory]
                            The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                            Can be any value that is or can be converted to a positive integer.
            @param {String} [chartMargins=&quot;&quot;] [Optional]
                            A String of 0 to 4 space-separated values that specifies the 4 margins of the chart.&lt;br&gt;
                            The string should respect the following format: &lt;b&gt;&quot;top right bottom left;&quot;&lt;&#x2F;b&gt; (notice the trailing semicolon)&lt;br&gt;
                            If less then 4 values are passed, only the covered subfield will be assigned using the input string,
                            while the remaining ones will take a default value specified as an inner attribute of the class.                               
            @param {Number} [dataDim=1] [Optional]
                            The dimension of the data space, i.e. the number of subvalues for each data entry;&lt;br&gt;
                            Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
            @param {Object} [parent=body]
                            [Optional]
                            The DOM element to which the diagram should be appended as a child
            @return {Object}    A new TimeWheelChart object
            @throws
                                -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                    (through setWidth or setHeight)
                                -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                -   Exception, if dataDim exceeds the maximum data dimension
                                -   Exception, if parent is passed but it is not a valid DOM element
          *&#x2F;
        function TimeWheelChart (ticks, startTime, wheelRadius, width, height, chartMargins, dataDim, parent){
           
            &#x2F;** 
                Length of notch lines, in pixels;
                @property TICK_LINES_LENGTH
                @for TimeWheelChart
                @type {Number}
                @default = 5
                @final
                @private     
              *&#x2F;            
            var TICK_LINES_LENGTH = 5;
            
            &#x2F;** 
                Margin between bars and their related labels;
                @property BAR_TEXT_MARGIN
                @for TimeWheelChart
                @type {Number}
                @default = 5
                @final
                @private     
              *&#x2F;             
            var BAR_TEXT_MARGIN = 5;
            
            var proto = FixedWidthBarChart(ticks, 0, width, height, chartMargins, dataDim, parent);
            &#x2F;&#x2F;proto_properties = 
            var timeWheelChart = Object.create(proto);
            
                                                            
            if (ChartUtils.validateTimeString(startTime)){
                                                      &#x2F;** 
                                                            Label stating the time corresponding to the first tick;
                                                            @property __startTime__
                                                            @type {String}
                                                            @protected                                                                                                         
                                                        *&#x2F;
                Object.defineProperty(timeWheelChart, &quot;__startTime__&quot;, {
                                        value: 	startTime,
                                        writable: true,
                                        enumerable: false,
                                        configurable: false
                                    });
            }
                                                  &#x2F;** 
                                                        Size in points of the static labels showing time references on the wheel;
                                                        @property __startTime__
                                                        @type {String}
                                                        @protected
                                                        @default data labels&#x27; size
                                                    *&#x2F;
            Object.defineProperty(timeWheelChart, &quot;__timeWheelLabelsSize__&quot;, {
                                    value: 	timeWheelChart.getLabelsSize(0),  &#x2F;&#x2F;Use the default value for value labels
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });
                                
            Object.defineProperty(timeWheelChart, &quot;setTimeWheelLabelsSize&quot;, {
                                            &#x2F;** setTimeWheelLabelsSize(size)
                                            
                                                Sets the size of the labels used for the wheel.
                                                
                                                @method setTimeWheelLabelsSize
                                                @chainable
                                                @param {Number} size    [Mandatory]
                                                                        The new size for the labels (must be an integer gt zero);
                                                @return {Object}        This chart object, to allow for method chaining;
                                                @throws    
                                                            - Illegal Argument Exception, if the argument is not valid (see above).
                                              *&#x2F;
                                    value: 	function(size){
                                                size = parseInt(size, 10);
                                                if (isNaN(size) || size &lt;= 0){
                                                    throw &quot;Illegal Argument: size&quot;;
                                                }
                                                if (this.hasOwnProperty(&quot;__timeWheelLabelsSize__&quot;)){
                                                    this.__timeWheelLabelsSize__ = size;
                                                }else{
                                                    &#x2F;&#x2F;Looks for object&#x27;s prototype
                                                    var proto = this.prototype ? this.prototype : this.__proto__;
                                                    if (proto &amp;&amp; proto.setTimeWheelLabelsSize){
                                                        proto.setTimeWheelLabelsSize(size);
                                                    }
                                                } 
                                                &#x2F;&#x2F;Now must update the static part of the wheel chart
                                                this.__updateWheelDrawing__();                                                    
                                                return this;    &#x2F;&#x2F;Method chaining support;
                                            },
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });                                     
                                                    &#x2F;** 
                                                        Color used for the static part of the wheel
                                                        @property __startTime__
                                                        @type {String|Object}
                                                        @protected
                                                        @default &quot;lightgrey&quot;                                                        
                                                      *&#x2F;
            Object.defineProperty(timeWheelChart, &quot;__timeWheelForeColor__&quot;, {
                                    value: 	&quot;lightgrey&quot;,  &#x2F;&#x2F;Defaults to lightgrey
                                    writable: true,
                                    enumerable: false,
                                    configurable: false
                                });                  

            timeWheelChart.addPublicMethod(&quot;setTimeWheelForeColor&quot;,
                                            &#x2F;** setTimeWheelForeColor(color)
                                            
                                                Sets the color used for the static part of the wheel&#x27;s drawing, 
                                                i.e. for labels and lines representing time ticks 
                                                of the time wheel.
                                                
                                                @method setTimeWheelForeColor
                                                @chainable
                                                @param {String|Object} color   [Mandatory]
                                                                                The new forecolor for the wheel;
                                                @return {Object}    This chart object, to allow for method chaining;
                                                @throws {Illegal Argument Exception} If color isn&#x27;t passed or is null.
                                              *&#x2F;
                                    function(color){
                                        if (Object.isUndefined(color) || color === null){
                                            throw &quot;Illegal Argument: color&quot;;
                                        }
                                        if (this.hasOwnProperty(&quot;__timeWheelForeColor__&quot;)){
                                            this.__timeWheelForeColor__ = color;
                                        }else{
                                            &#x2F;&#x2F;Looks for object&#x27;s prototype
                                            var proto = this.prototype ? this.prototype : this.__proto__;
                                            if (proto &amp;&amp; proto.setTimeWheelForeColor){
                                                proto.setTimeWheelForeColor(color);
                                            }
                                        }  
                                        &#x2F;&#x2F;Now must update the static part of the wheel chart
                                        this.__updateWheelDrawing__();
                                        return this;    &#x2F;&#x2F;Method chaining support;                                                    
                                    });    
                                
            Object.defineProperty(timeWheelChart, &quot;__timeLabelsVisible__&quot;, {
                                            &#x2F;** __timeLabelsVisible__()
                                                
                                                Checks whether or not the labels showing time references on the wheel
                                                should be drawn
                                                
                                                @method __timeLabelsVisible__
                                                @protected
                                                @return {Boolean} True &lt;=&gt; the time reference labels are visible.
                                                
                                              *&#x2F;
                                    value: 	function(){
                                                return !Object.isUndefined(this.__startTime__);
                                            },
                                    writable: false,
                                    enumerable: false,
                                    configurable: false
                                });
                           
            timeWheelChart.addPublicMethod(&quot;setBarWidth&quot;,
                &#x2F;** setBarWidth(barWidth)
                
                    Sets the width of this chart&#x27;s bars.
                    
                    @method setBarWidth
                    @chainable
                    @param {Number}  barWidth [Mandatory]
                                     The new bar width to be set;&lt;br&gt;
                                     MUST be a positive number or its base 10 string representation.
                    @return {Object}    This object, to allow for method chaining;
                    @throws    Illegal Argument Exception, if the argument isn&#x27;t valid (see above).
                    @override  BasicBarChart.setBarWidth
                  *&#x2F;
                function(barWidth){
                    barWidth = parseInt(barWidth, 10);
                    if (isNaN(barWidth) || barWidth &lt;= 0){
                        throw &quot;Illegal Argument: barWidth&quot;;
                    }
                    this.__barWidth__ = barWidth;
                    return this;		&#x2F;&#x2F;Method chaining oriented
                });	   
                                
            timeWheelChart.addPublicMethod(&quot;setWheelCenter&quot;,
                    &#x2F;** setWheelCenter(cx, cy)
                    
                        Sets the position of the center of the wheel.
                        If it is valid and it is different from the current position,
                        the drawing is moved to the new position
                        
                        @method setWheelCenter
                        @chainable
                        @param {Number} cx [Mandatory]
                                           x coordinate of the new center;&lt;br&gt;
                                           Only non negative integers or values that can be converted 
                                           to non negative integers are accepted;
                        @param {Number} cy [Mandatory]
                                           y coordinate of the new center;&lt;br&gt;
                                           Only non negative integers or values that can be converted 
                                           to non negative integers are accepted;
                        @return {Object}    This chart object, to allow for method chaining;
                        @throws     
                                    - Illegal Argument Exception, if cx or cy aren&#x27;t valid. 
                     *&#x2F;
                    function(cx, cy){
                        cx = parseInt(cx, 10);
                        cy = parseInt(cy, 10);
                        if (!isNaN(cx) &amp;&amp; !isNaN(cy)){
                            this.__moveWheelCenter__(cx, cy);
                        }else{
                            throw &quot;Illegal Arguments: cx, cy&quot;;
                        }                                    
                            
                        return this;	&#x2F;&#x2F;Method chaining oriented
                    });

            Object.defineProperty(timeWheelChart, &quot;__moveWheelCenter__&quot;, {
                            &#x2F;** __moveWheelCenter__(cx, cy)

                                When the center of the time wheel is moved,
                                it takes care of all the updates needed for the chart
                                
                                @method __moveWheelCenter__
                                @protected
                                @param {Number} cx [Mandatory]
                                                   x coordinate of the new center;
                                @param {Number} cy [Mandatory]
                                                   y coordinate of the new center;
                                @return {undefined}
                              *&#x2F;                                
                    value: 	function(cx, cy){
                                if (!Object.isNumber(cx) || !Object.isNumber(cy) ||    &#x2F;&#x2F;Extra precaution, since it&#x27;s not really a &quot;private&quot; method
                                    (this.__cx__ === cx &amp;&amp; this.__cy__ === cy)){ &#x2F;&#x2F;If values doesn&#x27;t change, no reason to hassle
                                      
                                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                                }
                                &#x2F;&#x2F;else

                                this.__wheel__.transition()&#x2F;&#x2F;.delay(250)
                                               .attr(&quot;x&quot;, cx - this.__r__).attr(&quot;y&quot;, cy - this.__r__);
                                this.__cx__ = cx;
                                this.__cy__ = cy;
                                
                                &#x2F;&#x2F;Now updates all the bars
                                
                                var newDataLength = this.__getDatasetLength__() * this.__dataDim__;
                                
                                &#x2F;&#x2F;The max is recomputed every time to retain the ability to switch on the fly between scaling locally and globally
                                var max_val;
                                
                                if (this.__scaleGlobally__){
                                    max_val = ChartUtils.fillArray(this.__maxVals__.max(), this.__dataDim__);
                                }else{
                                    max_val = this.__maxVals__;    &#x2F;&#x2F;Values aren&#x27;t going to be modified, so we can just copy the reference
                                }
                                
                                for (var j = 0; j &lt; this.__dataDim__; j++){  

                                    var dataSet = this.__selectData__(this.__data__, j);           
                                    var labelsSet = this.__selectLabels__(this.__data__, j);

                                    &#x2F;&#x2F;Computes the new X and Y scale
                                    this.__xScale__.domain([0, newDataLength]);        
                                    this.__yScale__[j].domain([0, 	max_val[j]]);
                                    this.__updateDrawing__(dataSet, labelsSet, j, this.__xScale__, this.__yScale__[j]);
                                }
                                
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this	
                            },  
                    writable: false,
                    enumerable: false,
                    configurable:false
                });   

            Object.defineProperty(timeWheelChart, &quot;__drawNewData__&quot;, {
                            &#x2F;** __drawNewData__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                                                           
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                   this method and __updateDrawing__ in order to obtain a custom chart.&lt;br&gt;
                                See base class for method signature and details.

                                @method __drawNewData__
                                @protected
                                @override   FixedWidthBarChart.__drawNewData__
                              *&#x2F;                
                    value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){
                                
                                var that = this;
                                
                                var initial_x = that.__cx__ + dataIndex * (that.__barWidth__ + 1), 
                                    initial_y = that.__cy__ - that.__r__ ;
                                
                                dataSet.enter().append(&quot;rect&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                    .attr(&quot;x&quot;, initial_x)
                                    .attr(&quot;y&quot;, initial_y)
                                    .attr(&quot;width&quot;, that.__barWidth__)
                                    .attr(&quot;height&quot;, 0)
                                    .attr(&quot;transform&quot;, function(d, i){ return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + 
                                                                              &quot; &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot;;})                                        
                                    .attr(&quot;fill&quot;, that.getBarsFillColor(dataIndex))
                                    .attr(&quot;stroke&quot;, that.getBarsStrokeColor(dataIndex))
                                    .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; that.__barHeight__);});
                                    
                                
                                if (that.areLabelsVisible(dataIndex) ){
                                    
                                    
                                    initial_x += that.getBarWidth();
                                    initial_y -= BAR_TEXT_MARGIN;
                                    labelsSet.enter()
                                        .append(&quot;text&quot;).attr(&quot;index&quot;, &quot;data_&quot; + dataIndex)
                                        .text(function(d) {return that.__makeLabel__(d, dataIndex);})      &#x2F;&#x2F;(&quot;&quot; + d).split(&quot;&quot;).reverse().join(&quot;&quot;) ;}) 
                                        .attr(&quot;text-anchor&quot;, &quot;left&quot;)
                                        .attr(&quot;x&quot;, initial_x)
                                        .attr(&quot;y&quot;, function(){return initial_y;})  
                                        .attr(&quot;transform&quot;,  function(d, i){  
                                                                return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + 
                                                                        &quot; &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot; +
                                                                        &quot;rotate(-90 &quot; + initial_x + &quot;, &quot; + initial_y +&quot;)&quot;;
                                                            })
                                        .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                        .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                                        .attr(&quot;fill&quot;, that.getLabelColor(dataIndex));
                                        &#x2F;&#x2F;.attr(&quot;class&quot;, &quot;wheelText&quot;)
                                }else{
                                    labelsSet.remove();
                                }
                                    
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false
                });
                    
            Object.defineProperty(timeWheelChart, &quot;__updateDrawing__&quot;, {
                            &#x2F;** __updateDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                                   this method and __drawNewData__ in order to obtain a custom chart.&lt;br&gt;
                                See base class for method signature and details.
                                 
                                @method  __updateDrawing__
                                @protected
                                @override  FixedWidthBarChart.__updateDrawing__
                              *&#x2F;					
                    value: 	function(dataSet, labelsSet, dataIndex, xScale, yScale){           
                    
                                var that = this; 
                                var initial_x = that.__cx__ + dataIndex * (that.__barWidth__ + 1);                              
                                
                                dataSet.transition()	
                                        .attr(&quot;x&quot;, initial_x)
                                        .attr(&quot;y&quot;, function(d){return that.__cy__ - that.__r__ - yScale(d);})
                                        .attr(&quot;height&quot;, function(d){return yScale(d);})
                                        .attr(&quot;transform&quot;, function(d, i){ return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + 
                                                                            &quot; &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot;;})                                       
                                        .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; that.__barHeight__);});

                                if (that.areLabelsVisible(dataIndex)){
                                    initial_x += that.getBarWidth();
                                    
                                    labelsSet.transition()
                                            .attr(&quot;y&quot;, function(d){return   that.__cy__ - that.__r__ - yScale(d) - BAR_TEXT_MARGIN; })
                                            .attr(&quot;x&quot;, initial_x)
                                            .attr(&quot;transform&quot;,  function(d, i){  
                                                                    return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + 
                                                                            &quot; &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot; +
                                                                            &quot;rotate(-90 &quot; + initial_x + &quot;, &quot; + (that.__cy__ - that.__r__ - yScale(d) - BAR_TEXT_MARGIN) +&quot;)&quot;;
                                                                });                                                
                                }else{
                                    labelsSet.remove();
                                }					
                                
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false
                });		
                
            timeWheelChart.addProtectedMethod(&quot;__refreshDrawing__&quot;,
                &#x2F;** __refreshDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale)
                                                               
                    Called by __redrawAll__() to redraw all the data-related drawings, once for
                    every data subcomponent.&lt;br&gt;
                    The difference with __updateDrawing__ is that the latter is incremental with respect to 
                    __drawNewData__ and updates only the properties used to provide animations of the drawing,
                    while this method redraws from scratch the data.
                    &lt;br&gt;
                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    if you inherit from this class you might want to override both
                                this method following __updateDrawing__  behaviour in order to obtain a custom chart.

                    @method __refreshDrawing__
                    @protected
                    @override   FixedWidthBarChart.__refreshDrawing__
                  *&#x2F;                
                function __refreshDrawing__(dataSet, labelsSet, dataIndex, xScale, yScale){
                    var that = this;
                    var initial_x = that.__cx__ + dataIndex * (that.__barWidth__ + 1), 
                        initial_y = that.__cy__ - that.__r__ ;
                    
                    dataSet.transition()
                        .attr(&quot;x&quot;, initial_x)
                        .attr(&quot;y&quot;, function(d){return that.__cy__ - that.__r__ - yScale(d);})
                        .attr(&quot;height&quot;, function(d){return yScale(d);})
                        .attr(&quot;transform&quot;, function(d, i){ return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + 
                                                                  &quot; &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot;;})                                        
                        .attr(&quot;fill&quot;, that.getBarsFillColor(dataIndex))
                        .attr(&quot;stroke&quot;, that.getBarsStrokeColor(dataIndex))
                        .attr(&quot;opacity&quot;, function(d){return that.__getBarOpacity__((0.0 + yScale(d)) &#x2F; that.__barHeight__);});
                        
                    
                    if (that.areLabelsVisible(dataIndex) ){
                        
                        
                        initial_x += that.getBarWidth();
                        initial_y -= BAR_TEXT_MARGIN;
                        labelsSet.transition()
                            .text(function(d) {return that.__makeLabel__(d, dataIndex);})      &#x2F;&#x2F;(&quot;&quot; + d).split(&quot;&quot;).reverse().join(&quot;&quot;) ;}) 
                            .attr(&quot;text-anchor&quot;, &quot;left&quot;)
                            .attr(&quot;x&quot;, initial_x)
                            .attr(&quot;y&quot;, function(d){return   that.__cy__ - that.__r__ - yScale(d) - BAR_TEXT_MARGIN; })
                            .attr(&quot;transform&quot;,  function(d, i){  
                                                    return &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * that.__tickStep__)) + 
                                                            &quot; &quot; + that.__cx__ +  &quot;, &quot; + that.__cy__ + &quot;)&quot; +
                                                            &quot;rotate(-90 &quot; + initial_x + &quot;, &quot; + (that.__cy__ - that.__r__ - yScale(d) - BAR_TEXT_MARGIN) +&quot;)&quot;;
                                                })
                            .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                            .attr(&quot;font-size&quot;, that.getLabelsSize(dataIndex))
                            .attr(&quot;fill&quot;, that.getLabelColor(dataIndex));
                            &#x2F;&#x2F;.attr(&quot;class&quot;, &quot;wheelText&quot;)
                    }else{
                        labelsSet.remove();
                    }
                        
                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                });                
                
        Object.defineProperty(timeWheelChart, &quot;__onClearData__&quot;, {            
                            &#x2F;** __onClearData__(n)
                                
                                [Protected method, not supposed to be used by consumers]
                                
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    Inherited objects MIGHT NEED to override this function&lt;br&gt;
                                                   See base class for method signature and details.
                                @method __onClearData__
                                @protected
                                @override BasicBarChart.__onClearData__
                              *&#x2F;
                    value:	function(n){
                                this.__timeLabels__.map(function(label){label.text(ChartUtils.addIntToTimeString(label.text(), n));});
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false
                });	
                
        Object.defineProperty(timeWheelChart, &quot;__updateWheelDrawing__&quot;, {            
                            &#x2F;** __updateWheelDrawing__()
                                
                                Updates the drawing of the static elements of the wheel&lt;br&gt;
                                &lt;br&gt;
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;:    Inherited objects MIGHT NEED to override this function
                                
                                @method __updateWheelDrawing__
                                @protected
                                @return {undefined}
                              *&#x2F;
                    value:	function(){
                                var that = this;
                                var tmpLabel;
                                &#x2F;&#x2F;Update labels text
                                this.__timeLabels__.map(function(label){
                                                            label.attr(&quot;fill&quot;, that.__timeWheelForeColor__)
                                                                 .attr(&quot;font-size&quot;, that.__timeWheelLabelsSize__);
                                                        });
                                &#x2F;&#x2F;Now updates their position
                                for (var i=0; i &lt; this.__timeLabels__.length; i++){
                                    tmpLabel = this.__timeLabels__[i];
                                    switch(tmpLabel.property(&quot;clock_time&quot;)){
                                        case &quot;12&quot;:
                                            tmpLabel
                                                   .attr(&quot;x&quot;, this.__r__)
                                                   .attr(&quot;y&quot;, TICK_LINES_LENGTH + this.__timeWheelLabelsSize__);
                                            break;
                                        case &quot;3&quot;:
                                            tmpLabel
                                                .attr(&quot;x&quot;, 2 * this.__r__ - TICK_LINES_LENGTH - this.__timeLabels__[i].node().getComputedTextLength() )
                                                .attr(&quot;y&quot;, this.__r__ + this.__timeWheelLabelsSize__ &#x2F; 2);                                             
                                            break;
                                        case &quot;6&quot;:
                                            tmpLabel
                                                .attr(&quot;x&quot;, this.__r__)
                                                .attr(&quot;y&quot;, 2 * this.__r__ - TICK_LINES_LENGTH);
                                            break;
                                        case &quot;9&quot;:
                                            tmpLabel
                                                .attr(&quot;x&quot;, TICK_LINES_LENGTH )
                                                .attr(&quot;y&quot;, this.__r__ + this.__timeWheelLabelsSize__ &#x2F; 2);                                         
                                            break;                                                
                                    }
                                }                                 

                                
                                &#x2F;&#x2F;Updates wheel tick lines                        
                                this.__wheel__.selectAll(&quot;line&quot;)
                                                    .attr(&quot;stroke&quot;, this.__timeWheelForeColor__);
                                &#x2F;&#x2F;Updates wheel tick lines                        
                                this.__wheel__.selectAll(&quot;circle&quot;)
                                                    .attr(&quot;stroke&quot;, this.__timeWheelForeColor__);                                                        
                                return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                            },
                    writable: false,
                    enumerable: false,
                    configurable:false
                }); 

            timeWheelChart.addProtectedMethod(&quot;__updateAxes__&quot;, 
                &#x2F;** __updateAxes__(yScale)
               
                    Called by appendData() to update the labels of the vertical axe
                    when vertical scale changes;&lt;br&gt;
                    &lt;br&gt;
                    &lt;b&gt;WARNING&lt;&#x2F;b&gt;:     if you inherit from this class you might want to override
                                        this method as well as __drawNewData__ and __updateDrawing__ 
                                        in order to obtain a custom chart.
                              
                    @method __updateAxes__
                    @protected
                    @chainable
                    @override FixedWidthBarChart.__updateAxes__
                    @param {Object} yScale  [Mandatory]
                                            D3 scale object for Y axis;
                    @return {undefined}
                  *&#x2F;
                function __updateAxes__(&#x2F;*yScale*&#x2F;){
                    &#x2F;&#x2F;Nothing to do for this class
                    
                    return;     &#x2F;&#x2F;(Pseudo)Private method, no need to return this
                });                
                            
            timeWheelChart.addPublicMethod(&quot;setHorizontalAxe&quot;, 
                &#x2F;** setHorizontalAxe()
          
                    @method setHorizontalAxe
                    @protected
                    @deprecated Ortogonal axes can&#x27;t be added for charts of this class.
                    @override BasicBarChart.setHorizontalAxe
                    @return {Exception}    To make explicit the fact that this method &lt;b&gt;isn&#x27;t available&lt;&#x2F;b&gt; for this class.
                    @throws {Deprecated Method Exception}
                  *&#x2F;
                function setHorizontalAxe(){
                    &#x2F;&#x2F;Nothing to do for this class
                    throw &quot;Deprecated Method&quot;;
                });  
                
            timeWheelChart.addPublicMethod(&quot;setVerticalAxe&quot;, 
                &#x2F;** setVerticalAxe()
        
                    @method setVerticalAxe
                    @protected
                    @deprecated Ortogonal axes can&#x27;t be added for charts of this class.
                    @override BasicBarChart.setVerticalAxe
                    @return {Exception}    To make explicit the fact that this method &lt;b&gt;isn&#x27;t available&lt;&#x2F;b&gt; for this class.
                    @throws {Deprecated Method Exception}
                  *&#x2F;
                function setVerticalAxe(){
                    &#x2F;&#x2F;Nothing to do for this class
                    throw &quot;Deprecated Method&quot;;
                });                
                
            Object.defineProperty(timeWheelChart, &quot;destroy&quot;, {
                            &#x2F;** destroy()
                                
                                Object&#x27;s destructor: helps garbage collector freeing memory, and removes chart DOM elements.&lt;br&gt;
                                &lt;br&gt;
                                &lt;b&gt;WARNING&lt;&#x2F;b&gt;: calling destroy on an object will force any further reference 
                                                to its attributes &#x2F; methods to throw exceptions.&lt;br&gt;
                                &lt;br&gt;
                                &lt;b&gt;NOTE&lt;&#x2F;b&gt;:   This function should be override by any class inheriting from this chart.&lt;br&gt;
                                               In order to properly work, any overriding destroyer should:
                                                &lt;ol&gt;
                                                    &lt;li&gt; Free any array specific to the object on which is called;&lt;&#x2F;li&gt;
                                                    &lt;li&gt; Remove any event listener on chart objects;&lt;&#x2F;li&gt;
                                                    &lt;li&gt; Call super object&#x27;s destroy method.&lt;&#x2F;li&gt;
                                                &lt;&#x2F;ol&gt;
                                @method destroy
                                @return {null} to state that the object has been destroyed.
                                @override BasicBarChart.destroy()
                              *&#x2F;                         
                    value: 	function(){
                                        &#x2F;&#x2F;Deletes all the elements from object&#x27;s arrays
                                        if (this.__timeLabels__){
                                            this.__timeLabels__.length = 0;
                                        }
                                        
                                        &#x2F;&#x2F;Removes DOM objects
                                        this.__wheel__.remove();
                                        &#x2F;&#x2F;Looks for object&#x27;s prototype destructor
                                        var proto = this.prototype ? this.prototype : this.__proto__;
                                        if (proto &amp;&amp; proto.destroy){
                                            proto.destroy();
                                        }
                                        return null;
                                    },
                    writable: false,
                    enumerable: false,
                    configurable: false
                });		
            
            
            &#x2F;** __init__()
                
                Inits the chart;
                
                @method __init__
                @private
                @param {Object} chart   [Mandatory]
                                        The chart that need initialization;
                @param {Number} width   [Mandatory]
                                        Chart&#x27;s width;
                @param {Number} height  [Mandatory]
                                        Chart&#x27;s height;
                @param {Number} wheelRadius  [Mandatory]   
                                            Wheel inner radius;
                @return {undefined}
              *&#x2F;      
            function __init__(chart, width, height, wheelRadius){
                var __r__, __barHeight__;
                &#x2F;&#x2F;Computes drawing related object contants
                                            &#x2F;** 
                                                Chart&#x27;s bars&#x27; width, in pixel &lt;br&gt;
                                                Can be changed at runtime
                                                @property __barWidth__
                                                @type {Number}
                                                @protected
                                                @default 8
                                                @override  FixedWidthBarChart.__barWidth__  
                                              *&#x2F;
                Object.defineProperty(chart, &quot;__barWidth__&quot;, {
                                            value: 8,
                                            writable: true,
                                            enumerable: false,
                                            configurable: false
                                        });	
                                            &#x2F;** 
                                                X coordinate of the center of the wheel
                                                Can be changed at runtime
                                                
                                                @property __cx__
                                                @type {Number}
                                                @protected
                                                @default the horizontal center of the chart                                                
                                              *&#x2F;
                Object.defineProperty(chart, &quot;__cx__&quot;, {
                                            value: width &#x2F; 2, &#x2F;&#x2F;Aligns left by default
                                            writable: true,                     &#x2F;&#x2F;to allow enough space for the legend
                                            enumerable: false,
                                            configurable:false
                                        });
                                        
                                            &#x2F;** 
                                                Y coordinate of the center of the wheel&lt;br&gt;
                                                Can be changed at runtime
                                                @property __cy__
                                                @type {Number}
                                                @protected
                                                @default the vertical center of the chart                                                  
                                              *&#x2F;
                Object.defineProperty(chart, &quot;__cy__&quot;, {
                                            value: height &#x2F; 2,
                                            writable: true,
                                            enumerable: false,
                                            configurable:false
                                        });    
                                        
                wheelRadius = parseInt(wheelRadius, 10);

                if (!isNaN(wheelRadius) &amp;&amp; wheelRadius &gt; 0){
                    &#x2F;&#x2F;If a value for the wheel radius is set, then computes the height accordingly...                                                                    
                    __r__ = wheelRadius;
                    __barHeight__ = ((Math.min(width, height) - 2 * wheelRadius) &#x2F; 2) * 0.75;
                    
                }else{
                    &#x2F;&#x2F;...Otherwise makes the radius 3&#x2F;4 of the available height;
                    __barHeight__ = Math.min(width, height) &#x2F; 4;
                    __r__ = __barHeight__ * 0.75;
                }
                
                                            &#x2F;** 
                                                Radius of the wheel&lt;br&gt;
                                                &lt;b&gt;CAN NOT&lt;&#x2F;b&gt; be changed at runtime
                                                @property __r__
                                                @type {Number}
                                                @protected    
                                                @readOnly
                                              *&#x2F;
                Object.defineProperty(chart, &quot;__r__&quot;, {
                                            value: __r__,
                                            writable: false,
                                            enumerable: false,
                                            configurable:false
                                        }); 
                                            &#x2F;** 
                                                Maximum height for each bar&lt;br&gt;
                                                &lt;b&gt;CAN NOT&lt;&#x2F;b&gt; be changed at runtime
                                                @property __barHeight__
                                                @type {Number}
                                                @protected    
                                                @readOnly
                                              *&#x2F;                                                                    
                Object.defineProperty(chart, &quot;__barHeight__&quot;, {
                                            value: __barHeight__,
                                            writable: false,
                                            enumerable: false,
                                            configurable:false
                                        });                 
                
                &#x2F;&#x2F;Modify the range for each of the data components
                for (var i=0; i &lt; chart.__dataDim__; i++){
                    chart.__yScale__[i].range([0, chart.__barHeight__]);
                }
                
                &#x2F;&#x2F;Computes the angle between two consecutive ticks
                                            &#x2F;** 
                                                The angle between two consecutive ticks&lt;br&gt;
                                                &lt;b&gt;CAN NOT&lt;&#x2F;b&gt; be changed at runtime
                                                
                                                @property __tickStep__
                                                @type {Number}
                                                @protected    
                                                @readOnly
                                              *&#x2F;  
                Object.defineProperty(chart, &quot;__tickStep__&quot;, {
                                            value: Math.PI &#x2F; (chart.__ticks__), &#x2F;&#x2F; == 2 * Math.PI &#x2F; (chart.__ticks__ * 2)
                                            writable: false,
                                            enumerable: false,
                                            configurable:false
                                        });   
                
                var     initial_x = chart.__cx__ - chart.__r__, 
                        initial_y = chart.__cy__ - chart.__r__;
                                           
                                           &#x2F;** 
                                                The actual svg object for the static part of the wheel
                                                
                                                @property __wheel__
                                                @type {Object}
                                                @protected    
                                                @readOnly                                                
                                              *&#x2F;
                Object.defineProperty(chart, &quot;__wheel__&quot;, {
                                            value: chart.__chartArea__.append(&quot;svg&quot;)
                                                                  .attr(&quot;id&quot;, &quot;timeWheel&quot;)
                                                                  .attr(&quot;x&quot;, initial_x)
                                                                  .attr(&quot;y&quot;, initial_y),
                                            writable: false,
                                            enumerable: false,
                                            configurable:false
                                        });  
                                        
                &#x2F;&#x2F;Appends an inner circle to represent the wheel
                chart.__wheel__.append(&quot;circle&quot;)
                               .attr(&quot;id&quot;, &quot;timeWheel&quot;)
                               .attr(&quot;cx&quot;, chart.__r__)
                               .attr(&quot;cy&quot;, chart.__r__)
                               .attr(&quot;stroke&quot;, chart.__timeWheelForeColor__)
                               .attr(&quot;stroke-dasharray&quot;, &quot;2, 4&quot;)
                               .attr(&quot;fill&quot;, &quot;none&quot;)
                               .attr(&quot;r&quot;, chart.__r__)
                               .attr(&quot;stroke-width&quot;, 1);
                               
                
                chart.__wheel__.selectAll(&quot;line&quot;).data(d3.range(chart.__ticks__))
                                .enter()
                                .append(&quot;svg:line&quot;)
                                .attr(&quot;x1&quot;, chart.__r__)
                                .attr(&quot;y1&quot;, 0)
                                .attr(&quot;x2&quot;, chart.__r__)
                                .attr(&quot;y2&quot;, TICK_LINES_LENGTH)
                                .attr(&quot;stroke&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;transform&quot;,      function(d, i){
                                                            return  &quot;rotate(&quot; + (180 &#x2F; Math.PI * (2 * i * chart.__tickStep__)) +
                                                                    &quot; &quot; + chart.__r__ + &quot;, &quot; + chart.__r__ +&quot;)&quot;;
                                                        });
                                                        
                if (chart.__timeLabelsVisible__()){
                    var timeLabels = [];
                    timeLabels.push(
                            chart.__wheel__
                                .append(&quot;text&quot;)
                                .property(&quot;clock_time&quot;, &quot;12&quot;)
                                .text(chart.__startTime__)
                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                .attr(&quot;font-size&quot;, chart.__timeWheelLabelsSize__)   
                                .attr(&quot;fill&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                .attr(&quot;x&quot;, chart.__r__)
                                .attr(&quot;y&quot;, TICK_LINES_LENGTH + chart.__timeWheelLabelsSize__)
                            );
                            
                    &#x2F;&#x2F;For the &quot;3 o&#x27;clock&quot; label we must take particular care because it needs to be aligned &quot;right&quot;
                    &#x2F;&#x2F;So we need to move it after creation, once we know its size
                    var tmpLabel = chart.__wheel__
                                .append(&quot;text&quot;)
                                .property(&quot;clock_time&quot;, &quot;3&quot;)
                                .text(ChartUtils.addIntToTimeString(chart.__startTime__, Math.floor(chart.__ticks__&#x2F;4)))
                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                .attr(&quot;font-size&quot;, chart.__timeWheelLabelsSize__)   
                                .attr(&quot;fill&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;text-anchor&quot;, &quot;left&quot;);
                    timeLabels.push(tmpLabel);
                            
                            tmpLabel.attr(&quot;x&quot;, 2 * chart.__r__ - TICK_LINES_LENGTH - tmpLabel.node().getComputedTextLength() )
                                    .attr(&quot;y&quot;, chart.__r__ + chart.__timeWheelLabelsSize__ &#x2F; 2);                                                       

                    timeLabels.push(
                            chart.__wheel__
                                .append(&quot;text&quot;)
                                .property(&quot;clock_time&quot;, &quot;6&quot;)
                                .text(ChartUtils.addIntToTimeString(chart.__startTime__, chart.__ticks__&#x2F;2))
                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                .attr(&quot;font-size&quot;, chart.__timeWheelLabelsSize__)   
                                .attr(&quot;fill&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;text-anchor&quot;, &quot;middle&quot;)
                                .attr(&quot;x&quot;, chart.__r__)
                                .attr(&quot;y&quot;, 2 * chart.__r__ - TICK_LINES_LENGTH)                                                       
                            );  
                    timeLabels.push(
                            chart.__wheel__
                                .append(&quot;text&quot;)
                                .property(&quot;clock_time&quot;, &quot;9&quot;)
                                .text(ChartUtils.addIntToTimeString(chart.__startTime__, Math.floor(3 * chart.__ticks__ &#x2F; 4)))
                                .attr(&quot;font-family&quot;, &quot;sans-serif&quot;)
                                .attr(&quot;font-size&quot;, chart.__timeWheelLabelsSize__)   
                                .attr(&quot;fill&quot;, chart.__timeWheelForeColor__)
                                .attr(&quot;text-anchor&quot;, &quot;left&quot;)
                                .attr(&quot;x&quot;, TICK_LINES_LENGTH )
                                .attr(&quot;y&quot;, chart.__r__ + chart.__timeWheelLabelsSize__ &#x2F; 2)                                                       
                            ); 

                                                &#x2F;** 
                                                    List of labels for wheel&#x27;s time references
                                                    
                                                    @property __timeLabels__
                                                    @type {Array}
                                                    @protected    
                                                    @readOnly                                                           
                                                  *&#x2F;
                    Object.defineProperty(chart, &quot;__timeLabels__&quot;, {
                                            value: timeLabels,
                                            writable: false,
                                            enumerable: false,
                                            configurable:false
                                        });  
                }
                return ;
            }

            
            __init__(timeWheelChart, timeWheelChart.__getChartAreaWidth__(), timeWheelChart.__getChartAreaHeight__(), wheelRadius);
            Object.seal(timeWheelChart);

            return timeWheelChart;
        }		
		
		var modulePrototype = {
            &#x2F;** 
                @method BasicBarChart
                @for DynamicChart
                @beta
                @chainable

                @param {Number} width [Mandatory]
                                The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} height [Mandatory]
                                The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {String} [chartMargins=&quot;&quot;] [Optional]
                                A String of 0 to 4 space-separated values that specifies the 4 margins of the chart.&lt;br&gt;
                                The string should respect the following format: &lt;b&gt;&quot;top right bottom left;&quot;&lt;&#x2F;b&gt; (notice the trailing semicolon)&lt;br&gt;
                                If less then 4 values are passed, only the covered subfield will be assigned using the input string,
                                while the remaining ones will take a default value specified as an inner attribute of the class.                                  
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                                Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
                @param {Object} [parent=body] [Optional]
                                The DOM element to which the diagram should be appended as a child                                                              
                @return {Object} A (wrapped-in-a-proxy version of a) BasicBarChart object
                @throws
                                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                    -   Illegal Argument exception , if width or height aren&#x27;t valid (numeric, positive) values 
                                        (through setWidth or setHeight)
                                    -   Illegal Argument exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension
                                    -   Exception, if parent is passed but it is not a valid DOM element                             
              *&#x2F;
            BasicBarChart: function(){
                               return BasicBarChart.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy(true);
                           },
            &#x2F;** 
                @method FixedWidthBarChart
                @for DynamicChart
                @beta
                @chainable
                
                @param {Number} ticks [Mandatory]
                                The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} startingPoint [Mandatory, but not used at the moment: inserted for future back-compatibility]&lt;br&gt;
                                The reference for the label of the first point.&lt;br&gt;
                                Should be an incrementable value;
                @param {Number} width [Mandatory]
                                The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} height [Mandatory]
                                The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {String} [chartMargins=&quot;&quot;] [Optional]
                                A String of 0 to 4 space-separated values that specifies the 4 margins of the chart.&lt;br&gt;
                                The string should respect the following format: &lt;b&gt;&quot;top right bottom left;&quot;&lt;&#x2F;b&gt; (notice the trailing semicolon)&lt;br&gt;
                                If less then 4 values are passed, only the covered subfield will be assigned using the input string,
                                while the remaining ones will take a default value specified as an inner attribute of the class.                                  
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                                Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
                @param {Object} [parent=body] [Optional]
                                The DOM element to which the diagram should be appended as a child
                @return {Object} A properly initialized (wrapped-in-a-proxy version of a) FixedWidthBarChart object
                @throws
                                    -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                    -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                        (through setWidth or setHeight)
                                    -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension
                                    -   Exception, if parent is passed but it is not a valid DOM element                
              *&#x2F;                           
            FixedWidthBarChart: function(){
                               return FixedWidthBarChart.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy(true);
                           },
            &#x2F;** 
                @method SlidingBarChart
                @for DynamicChart
                @beta
                @chainable
                
                @param {Number} ticks [Mandatory]
                                The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} width [Mandatory]
                                The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} height [Mandatory]
                                The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {String} [chartMargins=&quot;&quot;] [Optional]
                                A String of 0 to 4 space-separated values that specifies the 4 margins of the chart.&lt;br&gt;
                                The string should respect the following format: &lt;b&gt;&quot;top right bottom left;&quot;&lt;&#x2F;b&gt; (notice the trailing semicolon)&lt;br&gt;
                                If less then 4 values are passed, only the covered subfield will be assigned using the input string,
                                while the remaining ones will take a default value specified as an inner attribute of the class. 
                                For this particular chart the right margin can&#x27;t be less than AXES_LABEL_WIDTH pixel wide (if a smaller
                                value is passed, it will be overwritten).                                
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues for each data entry &lt;br&gt;
                                Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
                @param {Object} [parent=body] The DOM element to which the diagram should be appended as a child
                @return {Object} A properly initialized (wrapped-in-a-proxy version of a) SlidingBarChart object
                @throws
                                    -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                    -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                        (through setWidth or setHeight)
                                    -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension
                                    -   Exception, if the ratio between chart&#x27;s width and number of ticks is such
                                        that the computed bar height is smaller than 1 pixel
                                    -   Exception, if parent is passed but it is not a valid DOM element                
              *&#x2F;                              
            SlidingBarChart: function(){
                               return SlidingBarChart.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy(true);
                           },
            &#x2F;** 
                @method TimeWheelChart
                @for DynamicChart
                @beta
                @chainable
                
                @param {Number} ticks [Mandatory]
                                The number of values that can be drawn at the same time (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)
                                Can be any value that is or can be converted to a positive integer.
                @param {String} startTime [Mandatory]
                                The reference for the label of the first point.&lt;br&gt;
                                Should be an incrementable value.                                
                @param {Number} width [Mandatory]
                                The desired width for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {Number} height [Mandatory]
                                The desired height for the chart (&lt;b&gt;can&#x27;t be changed later&lt;&#x2F;b&gt;)&lt;br&gt;
                                Can be any value that is or can be converted to a positive integer.
                @param {String} [chartMargins=&quot;&quot;] [Optional]
                                A String of 0 to 4 space-separated values that specifies the 4 margins of the chart.&lt;br&gt;
                                The string should respect the following format: &lt;b&gt;&quot;top right bottom left;&quot;&lt;&#x2F;b&gt; (notice the trailing semicolon)&lt;br&gt;
                                If less then 4 values are passed, only the covered subfield will be assigned using the input string,
                                while the remaining ones will take a default value specified as an inner attribute of the class.&lt;br&gt;
                @param {Number} [dataDim=1] [Optional]
                                The dimension of the data space, i.e. the number of subvalues for each data entry&lt;br&gt;
                                Can be any value that is or can be converted to an integer between 1 and MAX_SPACE_DIMENSION.
                @param {Object} [parent=body] [Optional]
                                The DOM element to which the diagram should be appended as a child&lt;br&gt;
                @return {Object} A properly initialized (wrapped-in-a-proxy version of a) TimeWheelChart object
                @throws
                                    -   Illegal Argument Exception, if ticks isn&#x27;t a positive integer
                                    -   Wrong number of arguments Exception, if width or height are not passed as arguments (directly)
                                    -   Illegal Argument Exception, if width or height aren&#x27;t valid (numeric, positive) values 
                                        (through setWidth or setHeight)
                                    -   Illegal Argument Exception, if dataDim is passed but it&#x27;s invalid (not numeric or not positive)
                                    -   Exception, if dataDim exceeds the maximum data dimension
                                    -   Exception, if parent is passed but it is not a valid DOM element                
              *&#x2F;                            
            TimeWheelChart: function(){
                               return TimeWheelChart.apply(null, Array.prototype.slice.apply(arguments, [0])).createSafeProxy(true);
                           }                          
        };
		
		Object.freeze(modulePrototype);
		
		return Object.create(modulePrototype);
	})();

	Object.freeze(DynamicChart);
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
